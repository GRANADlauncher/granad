<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>2. List-based Simulations - GRANAD</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "2. List-based Simulations";
        var mkdocs_page_input_path = "tutorials/b_list_based_simulations.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> GRANAD
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../about/">About</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../api/">API</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../units/">Units</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../a_getting_started/">1. Getting started</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">2. List-based Simulations</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#orbitals-a-recap">Orbitals: A Recap</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#orbital-lists">Orbital lists</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#coupling-orbitals">Coupling orbitals</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#simulation-parameters">Simulation Parameters</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#lazy-computation">Lazy computation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#simulations">Simulations</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../c_plotting/">3. Plotting</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../d_basis_handling/">10. Basis Handling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../e_electric_fields/">5. Electric Fields</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../f_cutting/">4. Cutting</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../g_td_sim/">6. Time-Domain simulations</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../h_rabi_oscillations/">7. Rabi Oscillations</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../i_linear_response/">8. Linear response</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../j_defining_materials/">9. Defining Materials</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">GRANAD</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Tutorials</li>
      <li class="breadcrumb-item active">2. List-based Simulations</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="2-list-based-simulations">2. List-based Simulations</h1>
<p>We detail the main datatype of GRANAD.</p>
<h2 id="orbitals-a-recap">Orbitals: A Recap</h2>
<p>As already explained in the "Getting Started" Tutorial, Orbitals are the basic building blocks of orbital lists. Let's inspect the class</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="kn">from</span> <span class="nn">granad</span> <span class="kn">import</span> <span class="o">*</span>
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="nb">print</span><span class="p">(</span><span class="n">Orbital</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>    Represents the quantum state of an electron in an atom with specific properties.

    Attributes:
        position (jax.Array): The position of the orbital in space, initialized by default to a zero position.
                              This field is not used in hashing or comparison of instances.
        layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom,
                                     may be None if not specified.
        tag (Optional[str]): An optional tag for additional identification or categorization of the orbital,
                             defaults to None.
        energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital,
                                      can be None.
        angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital,
                                          optional and can be None.
        angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital&#39;s
                                            angular momentum, optional.
        spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum,
                              optional and may be None.
        atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable.
        group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class
                        default factory method. For example, all pz orbitals in a single graphene flake get the same 
                        group_id.

    Key Functionality:
        The most important attributes of an orbtial are

        group_id (automatically generated, not recommended to be set it by the user)
        tag (user-defined or predefined for existing materials)
</code></pre></div>
<h2 id="orbital-lists">Orbital lists</h2>
<p>To group orbitals, we put them in a list. </p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="nb">print</span><span class="p">(</span><span class="n">OrbitalList</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>    A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list,
    while also maintaining additional functionalities for coupling orbitals and managing their relationships.

    The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries,
    where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float
    or a function representing the coupling strength or mechanism between the orbitals).

    The class also stores simulation parameters like the number of electrons and temperature in a dataclass.

    The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is 
    a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute
    for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so
    quantity_x == quantity.

    The class exposes simulation methods.

    Attributes:
        orbitals (list): The underlying list that stores the orbitals.
        couplings (dict): A dictionary where keys are tuples of orbital identifiers and values are the couplings
                          (either float values or functions).

    Key Functionalities:
        - **Orbital Identification**: Orbitals can be identified either by their group_id, a direct
          reference to the orbital object itself, or via a user-defined tag.
        - **Index Access**: Orbitals can be accessed and managed by their index in the list, allowing for
          list-like manipulation (addition, removal, access).
        - **Coupling Definition**: Allows for the definition and adjustment of couplings between pairs of orbitals,
          identified by a tuple of their respective identifiers. These couplings can dynamically represent the
          interaction strength or be a computational function that defines the interaction.

    Note:
        The coupling values can be dynamically modified. When two orbital lists are added, their couplings are merged, 
        and their simulation parameters are wiped.
</code></pre></div>
<p>So the docstring tells us that orbital lists</p>
<ol>
<li>allow to couple orbitals </li>
<li>store simulation parameters in a dataclass</li>
<li>compute physical observables lazily (it also talks about bases, but see the seperate tutorial).</li>
<li>let us simulate things</li>
</ol>
<p>We will look at these remaining points below.</p>
<h2 id="coupling-orbitals">Coupling orbitals</h2>
<p>Say we want to create a stack of two graphene flakes.</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="n">flake</span> <span class="o">=</span> <span class="n">MaterialCatalog</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;graphene&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">cut_flake</span><span class="p">(</span> <span class="n">Rectangle</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">)</span>
</span></code></pre></div>
<p>How do we create the second flake and stack it on top? First of all, we duplicate the existing flake</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="n">flake_shifted</span> <span class="o">=</span> <span class="n">MaterialCatalog</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;graphene&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">cut_flake</span><span class="p">(</span> <span class="n">Rectangle</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">)</span>
</span></code></pre></div>
<p>We then inspect its orbitals.</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="nb">print</span><span class="p">(</span><span class="n">flake_shifted</span><span class="p">)</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>List with 68 orbitals, 68 electrons.
[0] electrons excited from [0] to [0].
group id 2 : 68 orbitals
</code></pre></div>
<p>When the orbitals in a flake are instantiated, they are automatically assigned a group id that has not been in use before. This flake contains only one group for all pz orbitals in the flake. We can check this</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="nb">print</span><span class="p">(</span><span class="n">flake_shifted</span><span class="o">.</span><span class="n">get_group_ids</span><span class="p">())</span> <span class="c1"># the i-th entry is the group of the i-th orbital</span>
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="nb">print</span><span class="p">(</span><span class="n">flake_shifted</span><span class="o">.</span><span class="n">get_unique_group_ids</span><span class="p">())</span> <span class="c1"># this is just jnp.unique on the previous array</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
[2]
</code></pre></div>
<p>So, we know that all orbitals in the flake have the same group_id. As such, we can group them and shift them together.</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="n">group_id_upper</span> <span class="o">=</span> <span class="n">flake_shifted</span><span class="o">.</span><span class="n">get_unique_group_ids</span><span class="p">()</span>
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a>
</span><span id="__span-6-3"><a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a><span class="c1"># this shift will be applied to all orbitals with the same group =&gt; the flake is lifted in z-direction</span>
</span><span id="__span-6-4"><a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a><span class="n">flake_shifted</span><span class="o">.</span><span class="n">shift_by_vector</span><span class="p">(</span> <span class="n">group_id_upper</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
</span></code></pre></div>
<p>Creating the stack is easy now</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a><span class="n">stack</span> <span class="o">=</span> <span class="n">flake</span> <span class="o">+</span> <span class="n">flake_shifted</span>
</span><span id="__span-7-2"><a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a><span class="n">stack</span><span class="o">.</span><span class="n">show_3d</span><span class="p">()</span>
</span></code></pre></div>
<p><img alt="png" src="../b_list_based_simulations_files/b_list_based_simulations_21_0.png" /></p>
<p>Okay, we have the geometry right, but what about the coupling? If we inspect the energies</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a><span class="n">stack</span><span class="o">.</span><span class="n">show_energies</span><span class="p">()</span>
</span></code></pre></div>
<p><img alt="png" src="../b_list_based_simulations_files/b_list_based_simulations_23_0.png" /></p>
<p>We see that we get every point twice: the interlayer coupling is zero by default, so we have a two-fold degenerate spectrum. To lift this degeneracy, we need to couple the layers. We do this via a function depending on distance. Say, you want to couple only nearest neighbors in a layer with a strength of -2.66. Interlayer nearest neighbors are separated by a distance of 1 Angström. So, one way to express the coupling as a function is by a narrow gaussian around 1.0</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-9-1"><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a><span class="k">def</span> <span class="nf">interlayer_hopping</span><span class="p">(</span> <span class="n">distance</span> <span class="p">):</span>
</span><span id="__span-9-2"><a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a>    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">distance</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
</span></code></pre></div>
<p>If the distance is (sufficiently close to) 1.0, we couple with -2.66, otherwise we don't couple. So, we want to couple two groups: the lower group of pz orbitals (the flake in the xy-plane) and the upper group. We do this like this:</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-10-1"><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a><span class="n">lower_id</span> <span class="o">=</span> <span class="n">flake</span><span class="o">.</span><span class="n">get_unique_group_ids</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="__span-10-2"><a id="__codelineno-10-2" name="__codelineno-10-2" href="#__codelineno-10-2"></a><span class="n">upper_id</span> <span class="o">=</span> <span class="n">flake_shifted</span><span class="o">.</span><span class="n">get_unique_group_ids</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="__span-10-3"><a id="__codelineno-10-3" name="__codelineno-10-3" href="#__codelineno-10-3"></a><span class="n">stack</span><span class="o">.</span><span class="n">set_groups_hopping</span><span class="p">(</span> <span class="n">lower_id</span><span class="p">,</span> <span class="n">upper_id</span><span class="p">,</span> <span class="n">interlayer_hopping</span> <span class="p">)</span>
</span><span id="__span-10-4"><a id="__codelineno-10-4" name="__codelineno-10-4" href="#__codelineno-10-4"></a><span class="n">stack</span><span class="o">.</span><span class="n">show_energies</span><span class="p">()</span>
</span></code></pre></div>
<p><img alt="png" src="../b_list_based_simulations_files/b_list_based_simulations_27_0.png" /></p>
<p>The degeneracy is lifted! Consider now an adatom</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-11-1"><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a><span class="n">lower_level</span> <span class="o">=</span> <span class="n">Orbital</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;atom&quot;</span><span class="p">)</span>
</span><span id="__span-11-2"><a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a><span class="n">upper_level</span> <span class="o">=</span> <span class="n">Orbital</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;atom&quot;</span><span class="p">)</span>
</span><span id="__span-11-3"><a id="__codelineno-11-3" name="__codelineno-11-3" href="#__codelineno-11-3"></a><span class="n">atom</span> <span class="o">=</span> <span class="n">OrbitalList</span><span class="p">([</span><span class="n">lower_level</span><span class="p">,</span> <span class="n">upper_level</span><span class="p">])</span>
</span><span id="__span-11-4"><a id="__codelineno-11-4" name="__codelineno-11-4" href="#__codelineno-11-4"></a><span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>List with 2 orbitals, 2 electrons.
[0] electrons excited from [0] to [0].
group id 3 : 1 orbitals
group id 4 : 1 orbitals
</code></pre></div>
<p>For now, we have two electrons. We learn how to change this below. Each orbital has its own group_id. Don't change these, GRANAD handles these by default. We want to set energies of this adatom, i.e. its hamiltonian. If we just want a TLS with energies <span class="arithmatex">\(\pm 0.5\)</span>, we have a <span class="arithmatex">\(2x2\)</span> matrix, where H[0,0] = -0.5, and H[1,1] = 0.5. We can set the hamiltonian elements directly</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-12-1"><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a><span class="n">atom</span><span class="o">.</span><span class="n">set_hamiltonian_element</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
</span><span id="__span-12-2"><a id="__codelineno-12-2" name="__codelineno-12-2" href="#__codelineno-12-2"></a><span class="n">atom</span><span class="o">.</span><span class="n">set_hamiltonian_element</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span> 
</span><span id="__span-12-3"><a id="__codelineno-12-3" name="__codelineno-12-3" href="#__codelineno-12-3"></a><span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">)</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>[[-0.5+0.j  0. +0.j]
 [ 0. +0.j  0.5+0.j]]
</code></pre></div>
<p>We can also set the elements by directly referencing the orbitals</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-13-1"><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a><span class="n">atom</span><span class="o">.</span><span class="n">set_hamiltonian_element</span><span class="p">(</span> <span class="n">upper_level</span><span class="p">,</span> <span class="n">upper_level</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>
</span><span id="__span-13-2"><a id="__codelineno-13-2" name="__codelineno-13-2" href="#__codelineno-13-2"></a><span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">)</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>[[-0.5+0.j  0. +0.j]
 [ 0. +0.j  0.8+0.j]]
</code></pre></div>
<p>You can do the same thing for any element of the graphene flake btw. Talking about it, let's couple the atom to it. First, we combine the lists</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-14-1"><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a><span class="n">stack_with_atom</span> <span class="o">=</span> <span class="n">stack</span> <span class="o">+</span> <span class="n">atom</span>
</span></code></pre></div>
<p>Now, we move the atom somewhere in between the two flakes</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-15-1"><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a><span class="n">stack_with_atom</span><span class="o">.</span><span class="n">show_3d</span><span class="p">(</span> <span class="n">show_index</span> <span class="o">=</span> <span class="kc">True</span> <span class="p">)</span>
</span></code></pre></div>
<p><img alt="png" src="../b_list_based_simulations_files/b_list_based_simulations_37_0.png" /></p>
<p>We pick two indices we like and put the atom in between. To move all orbitals on the atom, we use the tag we just defined.</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-16-1"><a id="__codelineno-16-1" name="__codelineno-16-1" href="#__codelineno-16-1"></a><span class="n">new_atom_position</span> <span class="o">=</span> <span class="n">stack_with_atom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]</span> <span class="p">)</span>
</span><span id="__span-16-2"><a id="__codelineno-16-2" name="__codelineno-16-2" href="#__codelineno-16-2"></a><span class="n">stack_with_atom</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s2">&quot;atom&quot;</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="n">new_atom_position</span><span class="p">)</span>
</span><span id="__span-16-3"><a id="__codelineno-16-3" name="__codelineno-16-3" href="#__codelineno-16-3"></a><span class="n">stack_with_atom</span><span class="o">.</span><span class="n">show_3d</span><span class="p">()</span>
</span></code></pre></div>
<p><img alt="png" src="../b_list_based_simulations_files/b_list_based_simulations_39_0.png" /></p>
<p>Now, we look at the energies</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-17-1"><a id="__codelineno-17-1" name="__codelineno-17-1" href="#__codelineno-17-1"></a><span class="n">stack_with_atom</span><span class="o">.</span><span class="n">show_energies</span><span class="p">()</span>
</span></code></pre></div>
<p><img alt="png" src="../b_list_based_simulations_files/b_list_based_simulations_41_0.png" /></p>
<p>Not much of a change, but the reason is that we forgot to couple the atom to the flakes. So let's do that. We couple it just to its nearest neighbors.</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-18-1"><a id="__codelineno-18-1" name="__codelineno-18-1" href="#__codelineno-18-1"></a><span class="n">stack_with_atom</span><span class="o">.</span><span class="n">set_hamiltonian_element</span><span class="p">(</span> <span class="n">lower_level</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span> <span class="p">)</span> <span class="c1"># we can even mix orbitals and indices</span>
</span><span id="__span-18-2"><a id="__codelineno-18-2" name="__codelineno-18-2" href="#__codelineno-18-2"></a><span class="n">stack_with_atom</span><span class="o">.</span><span class="n">set_hamiltonian_element</span><span class="p">(</span> <span class="n">upper_level</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span> <span class="p">)</span>
</span><span id="__span-18-3"><a id="__codelineno-18-3" name="__codelineno-18-3" href="#__codelineno-18-3"></a>
</span><span id="__span-18-4"><a id="__codelineno-18-4" name="__codelineno-18-4" href="#__codelineno-18-4"></a><span class="n">stack_with_atom</span><span class="o">.</span><span class="n">set_hamiltonian_element</span><span class="p">(</span> <span class="n">upper_level</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mf">0.3</span> <span class="p">)</span>
</span><span id="__span-18-5"><a id="__codelineno-18-5" name="__codelineno-18-5" href="#__codelineno-18-5"></a><span class="n">stack_with_atom</span><span class="o">.</span><span class="n">set_hamiltonian_element</span><span class="p">(</span> <span class="n">upper_level</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mf">0.3</span> <span class="p">)</span>
</span><span id="__span-18-6"><a id="__codelineno-18-6" name="__codelineno-18-6" href="#__codelineno-18-6"></a><span class="n">stack</span><span class="o">.</span><span class="n">show_energies</span><span class="p">()</span>
</span></code></pre></div>
<p><img alt="png" src="../b_list_based_simulations_files/b_list_based_simulations_43_0.png" /></p>
<p>Setting coulomb elements works analogously. To wrap up, we can couple by </p>
<ol>
<li>setting matrix elements indexing via orbitals or their list indices</li>
<li>setting coupling functions via group ids (you can also pass orbitals to these functions, but the behavior is a bit weirder).</li>
</ol>
<h2 id="simulation-parameters">Simulation Parameters</h2>
<p>Let's revisit the adatom we just built.</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-19-1"><a id="__codelineno-19-1" name="__codelineno-19-1" href="#__codelineno-19-1"></a><span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>List with 2 orbitals, 2 electrons.
[0] electrons excited from [0] to [0].
group id 3 : 1 orbitals
group id 4 : 1 orbitals
</code></pre></div>
<p>We have two electrons, but a traditional TLS should only have one. We can do this like that</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-20-1"><a id="__codelineno-20-1" name="__codelineno-20-1" href="#__codelineno-20-1"></a><span class="n">atom</span><span class="o">.</span><span class="n">set_electrons</span><span class="p">(</span> <span class="n">atom</span><span class="o">.</span><span class="n">electrons</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span>
</span><span id="__span-20-2"><a id="__codelineno-20-2" name="__codelineno-20-2" href="#__codelineno-20-2"></a><span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>List with 2 orbitals, 1 electrons.
[0] electrons excited from [0] to [0].
group id 3 : 1 orbitals
group id 4 : 1 orbitals
</code></pre></div>
<p>This looks better. Let's excite the transition (in our lingo, this is HOMO-LUMO)</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-21-1"><a id="__codelineno-21-1" name="__codelineno-21-1" href="#__codelineno-21-1"></a><span class="n">atom</span><span class="o">.</span><span class="n">set_excitation</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="__span-21-2"><a id="__codelineno-21-2" name="__codelineno-21-2" href="#__codelineno-21-2"></a><span class="n">atom</span><span class="o">.</span><span class="n">show_energies</span><span class="p">()</span>
</span></code></pre></div>
<p><img alt="png" src="../b_list_based_simulations_files/b_list_based_simulations_52_0.png" /></p>
<p>This works. Let's now combine it with another TLS</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-22-1"><a id="__codelineno-22-1" name="__codelineno-22-1" href="#__codelineno-22-1"></a><span class="n">a</span> <span class="o">=</span> <span class="n">Orbital</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;atom2&quot;</span><span class="p">)</span>
</span><span id="__span-22-2"><a id="__codelineno-22-2" name="__codelineno-22-2" href="#__codelineno-22-2"></a><span class="n">b</span> <span class="o">=</span> <span class="n">Orbital</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;atom2&quot;</span><span class="p">)</span>
</span><span id="__span-22-3"><a id="__codelineno-22-3" name="__codelineno-22-3" href="#__codelineno-22-3"></a><span class="n">atom2</span> <span class="o">=</span> <span class="n">OrbitalList</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
</span><span id="__span-22-4"><a id="__codelineno-22-4" name="__codelineno-22-4" href="#__codelineno-22-4"></a>
</span><span id="__span-22-5"><a id="__codelineno-22-5" name="__codelineno-22-5" href="#__codelineno-22-5"></a><span class="n">atoms</span> <span class="o">=</span> <span class="n">atom</span> <span class="o">+</span> <span class="n">atom2</span>
</span><span id="__span-22-6"><a id="__codelineno-22-6" name="__codelineno-22-6" href="#__codelineno-22-6"></a><span class="nb">print</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">energies</span><span class="p">)</span>
</span><span id="__span-22-7"><a id="__codelineno-22-7" name="__codelineno-22-7" href="#__codelineno-22-7"></a><span class="nb">print</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>[-0.5  0.   0.   0.8]
List with 4 orbitals, 4 electrons.
[0] electrons excited from [0] to [0].
group id 3 : 1 orbitals
group id 4 : 1 orbitals
group id 5 : 1 orbitals
group id 6 : 1 orbitals
</code></pre></div>
<p>WAIT! We are back to 2 + 2 = 4 electrons, i.e. one per orbital? Why is this? The reason is that addition for orbital lists is defined as, schematically</p>
<ol>
<li>orb1 + orb2 = [orb1, orb2]</li>
<li>coupling1 + coupling2 = [coupling1, coupling2]</li>
<li>param1 + param2  = default_params</li>
</ol>
<p>This might change in the future allowing you to define your own addition for all orbital list attributes. For now, we need to reset to the correct orbital number manually</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-23-1"><a id="__codelineno-23-1" name="__codelineno-23-1" href="#__codelineno-23-1"></a><span class="n">atoms</span><span class="o">.</span><span class="n">set_electrons</span><span class="p">(</span> <span class="n">atoms</span><span class="o">.</span><span class="n">electrons</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></code></pre></div>
<p>Another peculiarity of orbital lists is: they can contain each orbital only one time. So, if you try:</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-24-1"><a id="__codelineno-24-1" name="__codelineno-24-1" href="#__codelineno-24-1"></a><span class="c1"># updated_stack = stack_with_atom + atoms</span>
</span></code></pre></div>
<p>This will fail, because stack_with_atom already contains the atom contained in atoms. Admittedly, this is weird.</p>
<p>If you are interested in the simulation parameters</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-25-1"><a id="__codelineno-25-1" name="__codelineno-25-1" href="#__codelineno-25-1"></a><span class="nb">print</span><span class="p">(</span><span class="n">SimulationParams</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>    A data class for storing parameters necessary for running a simulation involving electronic states and transitions.

    Attributes:
        from_state (jax.Array): An array where each element is the index of an electronic state from which
                                electrons are excited. Defaults to an array containing a single zero.
        to_state (jax.Array): An array where each element is the index of an electronic state to which
                              electrons are excited. Defaults to an array containing a single zero.
        excited_electrons (jax.Array): An array where each element indicates the number of electrons excited
                                       between the corresponding states in `from_state` and `to_state`.
                                       Defaults to an array containing a single zero.
        eps (float): Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5.
        beta (float): Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to
                      `jax.numpy.inf` by default, implying zero temperature.
        self_consistency_params (dict): A dictionary to hold additional parameters required for self-consistency
                                        calculations within the simulation. Defaults to an empty dictionary.
        spin_degeneracy (float): Factor to account for the degeneracy of spin states in the simulation. Typically
                               set to 2, considering spin up and spin down. 
        electrons (Optional[int]): The total number of electrons in the structure. If not provided, it is assumed
                                   that the system&#39;s electron number needs to be calculated or is managed elsewhere.

    Note:
        This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state
        of OrbitalList.
</code></pre></div>
<p>So, they encapsulate the state of the simulation. Just remember to set them directly before you simulate.</p>
<h2 id="lazy-computation">Lazy computation</h2>
<p>This is quickly explained: we have used it all the time!</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-26-1"><a id="__codelineno-26-1" name="__codelineno-26-1" href="#__codelineno-26-1"></a><span class="n">atom</span><span class="o">.</span><span class="n">set_hamiltonian_element</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span> <span class="c1"># doesnt compute anything</span>
</span><span id="__span-26-2"><a id="__codelineno-26-2" name="__codelineno-26-2" href="#__codelineno-26-2"></a><span class="n">atom</span><span class="o">.</span><span class="n">set_hamiltonian_element</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span> <span class="c1"># still, nothing computed</span>
</span><span id="__span-26-3"><a id="__codelineno-26-3" name="__codelineno-26-3" href="#__codelineno-26-3"></a><span class="n">atom</span><span class="o">.</span><span class="n">energies</span> <span class="c1"># now, we need to compute</span>
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code>Array([0.8, 1. ], dtype=float64)
</code></pre></div>
<h2 id="simulations">Simulations</h2>
<p>Simulations don't change anything about the orbitals, so we can do the same time propagation with two different relaxation rates etc. The only methods that change anything about the list explicitly tell you so by starting with "set".</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../a_getting_started/" class="btn btn-neutral float-left" title="1. Getting started"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../c_plotting/" class="btn btn-neutral float-right" title="3. Plotting">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../a_getting_started/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../c_plotting/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../javascripts/mathjax.js"></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
