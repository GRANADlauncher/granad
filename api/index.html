<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>API - GRANAD</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "API";
        var mkdocs_page_input_path = "api.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> GRANAD
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">API</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#granad.orbitals">orbitals</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#granad.orbitals.Orbital">Orbital</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#granad.orbitals.OrbitalList">OrbitalList</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.dipole_operator">dipole_operator</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.quadrupole_operator">quadrupole_operator</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.transition_energies">transition_energies</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.velocity_operator">velocity_operator</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.wigner_weisskopf_transition_rates">wigner_weisskopf_transition_rates</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.append">append</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_charge">get_charge</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_density_matrix_time_domain">get_density_matrix_time_domain</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_dos">get_dos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_epi">get_epi</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_expectation_value">get_expectation_value</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_expectation_value_frequency_domain">get_expectation_value_frequency_domain</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_expectation_value_time_domain">get_expectation_value_time_domain</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_group_ids">get_group_ids</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_induced_field">get_induced_field</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_ldos">get_ldos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_polarizability_rpa">get_polarizability_rpa</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_susceptibility_rpa">get_susceptibility_rpa</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.get_unique_group_ids">get_unique_group_ids</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.make_self_consistent">make_self_consistent</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.set_coulomb_element">set_coulomb_element</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.set_dipole_transition">set_dipole_transition</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.set_excitation">set_excitation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.set_groups_coulomb">set_groups_coulomb</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.set_groups_hopping">set_groups_hopping</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.set_hamiltonian_element">set_hamiltonian_element</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.shift_by_vector">shift_by_vector</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.transform_to_energy_basis">transform_to_energy_basis</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#granad.orbitals.OrbitalList.transform_to_site_basis">transform_to_site_basis</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../units/">Units</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/getting_started/">Getting started</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/linear_response_absorption_cross_section_with_td_and_rpa_simulations/">Linear response absorption cross section with td and rpa simulations</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/rabi_oscillations_in_tls/">Rabi oscillations in tls</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">GRANAD</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">API</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="api">API</h1>


<div class="doc doc-object doc-module">



<a id="granad.orbitals"></a>
  <div class="doc doc-contents first">

  

  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="granad.orbitals.Orbital" class="doc doc-heading">
          <code>Orbital</code>

  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


  <div class="doc doc-contents ">

  
      <p>Represents the quantum state of an electron in an atom with specific properties.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Attributes:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>position</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The position of the orbital in space, initialized by default to a zero position.
                  This field is not used in hashing or comparison of instances.</p>
              </div>
            </li>
            <li>
              <b><code>layer_index</code></b>
                  (<code><span title="typing.Optional">Optional</span>[int]</code>)
              â€“
              <div class="doc-md-description">
                <p>An optional index representing the layer of the orbital within its atom,
                         may be None if not specified.</p>
              </div>
            </li>
            <li>
              <b><code>tag</code></b>
                  (<code><span title="typing.Optional">Optional</span>[str]</code>)
              â€“
              <div class="doc-md-description">
                <p>An optional tag for additional identification or categorization of the orbital,
                 defaults to None.</p>
              </div>
            </li>
            <li>
              <b><code>energy_level</code></b>
                  (<code><span title="typing.Optional">Optional</span>[int]</code>)
              â€“
              <div class="doc-md-description">
                <p>The principal quantum number indicating the energy level of the orbital,
                          can be None.</p>
              </div>
            </li>
            <li>
              <b><code>angular_momentum</code></b>
                  (<code><span title="typing.Optional">Optional</span>[int]</code>)
              â€“
              <div class="doc-md-description">
                <p>The quantum number representing the angular momentum of the orbital,
                              optional and can be None.</p>
              </div>
            </li>
            <li>
              <b><code>angular_momentum_z</code></b>
                  (<code><span title="typing.Optional">Optional</span>[int]</code>)
              â€“
              <div class="doc-md-description">
                <p>The magnetic quantum number related to the z-component of the orbital's
                                angular momentum, optional.</p>
              </div>
            </li>
            <li>
              <b><code>spin</code></b>
                  (<code><span title="typing.Optional">Optional</span>[int]</code>)
              â€“
              <div class="doc-md-description">
                <p>The spin quantum number of the orbital, indicating its intrinsic angular momentum,
                  optional and may be None.</p>
              </div>
            </li>
            <li>
              <b><code>atom_name</code></b>
                  (<code><span title="typing.Optional">Optional</span>[str]</code>)
              â€“
              <div class="doc-md-description">
                <p>The name of the atom this orbital belongs to, can be None if not applicable.</p>
              </div>
            </li>
            <li>
              <b><code>group_id</code></b>
                  (<code>int</code>)
              â€“
              <div class="doc-md-description">
                <p>A group identifier for the orbital, automatically assigned by a Watchdog class
            default factory method.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>src/granad/orbitals.py</code></summary>
              <pre class="highlight"><code class="language-python">@dataclass
class Orbital:
    """
    Represents the quantum state of an electron in an atom with specific properties.

    Attributes:
        position (jax.Array): The position of the orbital in space, initialized by default to a zero position.
                              This field is not used in hashing or comparison of instances.
        layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom,
                                     may be None if not specified.
        tag (Optional[str]): An optional tag for additional identification or categorization of the orbital,
                             defaults to None.
        energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital,
                                      can be None.
        angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital,
                                          optional and can be None.
        angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's
                                            angular momentum, optional.
        spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum,
                              optional and may be None.
        atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable.
        group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class
                        default factory method.
    """
    position: jax.Array = field(default_factory=lambda : jnp.array([0, 0, 0]), hash=False, compare=False)
    layer_index: Optional[int] = None
    tag: Optional[str] = None
    energy_level: Optional[int] = None
    angular_momentum: Optional[int] = None
    angular_momentum_z: Optional[int] = None
    spin: Optional[int] = None
    atom_name: Optional[str] = None
    group_id: int = field(default_factory=_watchdog._Watchdog.next_value)

    def __post_init__(self):
        object.__setattr__(self, "position", jnp.array(self.position).astype(float))

    def __hash__(self):
        # Include only immutable fields in hash calculation
        return hash(
            (
                self.layer_index,
                self.tag,
                self.energy_level,
                self.angular_momentum,
                self.angular_momentum_z,
                self.angular_momentum,
                self.spin,
                self.atom_name,
                self.group_id,
            )
        )

    def __str__(self):
        return pformat(vars(self), sort_dicts=False)

    # TODO: bla bla bla ... this should be shorter but im too tired
    def __eq__(self, other):
        if not isinstance(other, Orbital):
            return NotImplemented
        return self.group_id == other.group_id and self.layer_index == other.layer_index

    def __lt__(self, other):
        if not isinstance(other, Orbital):
            return NotImplemented
        return self.group_id &lt; self.group_id

    def __le__(self, other):
        return self &lt; other or self == other

    def __gt__(self, other):
        return not self &lt;= other

    def __ge__(self, other):
        return not self &lt; other

    def __ne__(self, other):
        return not self == other</code></pre>
            </details>

  

  <div class="doc doc-children">











  </div>

  </div>


</div>

<div class="doc doc-object doc-class">



<h2 id="granad.orbitals.OrbitalList" class="doc doc-heading">
          <code>OrbitalList</code>


</h2>


  <div class="doc doc-contents ">

  
      <p>A list of orbitals.</p>

            <details class="quote">
              <summary>Source code in <code>src/granad/orbitals.py</code></summary>
              <pre class="highlight"><code class="language-python">@plotting_methods
class OrbitalList:
    """A list of orbitals."""

    def __init__(self, orbs, _hopping_dict=None, _coulomb_dict=None):
        # couplings are dicts mapping orbital pairs to couplings
        self._hopping_dict = (
            _hopping_dict if _hopping_dict is not None else _SortedTupleDict()
        )
        self._coulomb_dict = (
            _coulomb_dict if _coulomb_dict is not None else _SortedTupleDict()
        )
        self._transitions = _SortedTupleDict()

        # contains all high-level simulation information
        self._list = list(orbs) if orbs is not None else []

        # flag for recomputing state
        self._recompute = True

        # TODO: this is a bunch of stuff and must be better doable
        self.from_state = jnp.array([0])
        self.to_state = jnp.array([0])
        self.excited_electrons = jnp.array([0])
        self.eps = 1e-5
        self.beta = jnp.inf
        self.self_consistency_params = {}
        self.spin_degeneracy = 2.0
        self.electrons = len(self._list)

    def __len__(self):
        return len(self._list)

    # can't mutate, because orbitals are immutable
    def __getitem__(self, position):
        return self._list[position]

    def __repr__(self):
        return repr(self._list)

    # TODO: hmmm
    def __str__(self):
        info = f"List with {len(self)} orbitals, {self.electrons} electrons."
        excited = f"{self.excited_electrons} electrons excited from {self.from_state} to {self.to_state}."
        groups = "\n".join(
            [
                f"group id {key} : {val} orbitals"
                for key, val in Counter(self.get_group_ids()).items()
            ]
        )
        return "\n".join((info, excited, groups))

    def __iter__(self):
        return iter(self._list)

    # TODO: uff, addition, or, in general, mutation should wipe all attributes except for coupling
    def __add__(self, other):
        if not self._are_orbs(other):
            raise TypeError

        if any(orb in other for orb in self._list):
            raise ValueError

        if isinstance(other, OrbitalList):
            new_hopping_dict = self._hopping_dict.copy()
            new_hopping_dict.update(other._hopping_dict)
            new_coulomb_dict = self._coulomb_dict.copy()
            new_coulomb_dict.update(other._coulomb_dict)

        return OrbitalList(
            (self._list + list(other)).copy(),
            _SortedTupleDict(new_hopping_dict),
            _SortedTupleDict(new_coulomb_dict),
        )

    @mutates
    def __setitem__(self, position, value):
        if isinstance(value, Orbital):
            self._list[position] = value
        raise TypeError

    def _delete_coupling(self, orb, coupling):
        keys_to_remove = [key for key in coupling if orb in key]
        for key in keys_to_remove:
            del coupling[key]

    @mutates
    def __delitem__(self, position):
        orb = self._list[position]
        self._delete_coupling(orb, self._hopping_dict)
        self._delete_coupling(orb, self._coulomb_dict)
        del self._list[position]

    @staticmethod
    def _are_orbs(candidate):
        return all(isinstance(orb, Orbital) for orb in candidate)

    @mutates
    def _set_coupling(self, orb_or_group_id1, orb_or_group_id2, val_or_func, coupling):
        coupling[(orb_or_group_id1, orb_or_group_id2)] = val_or_func

    # TODO: we may want to differentiate through this, also this is private so better not wrap return val into container
    def _hamiltonian_coulomb(self):

        def fill_matrix(matrix, coupling_dict):

            # TODO: there should be an internal
            dummy = jnp.arange(len(self))
            triangle_mask = dummy[:, None] &gt;= dummy

            # TODO: in principle we can build a big tensor NxNxgroups, vmap over the last axis and sum the groups
            # first, we loop over all group_id couplings =&gt; interactions between groups
            for key, function in coupling_dict.group_id_items():
                # TODO:  big uff:  we rely on the correct ordering of the group_ids for cols and rows, first key is always smaller than last keys =&gt; we get upper triangular valid indices
                # if it were the other way around, these would be zeroed by the triangle mask
                cols = group_ids == key[0]
                rows = (group_ids == key[1])[:, None]
                combination_indices = jnp.logical_and(rows, cols)
                valid_indices = jnp.logical_and(triangle_mask, combination_indices)
                function = jax.vmap(function)
                matrix = matrix.at[valid_indices].set(
                    function(distances[valid_indices])
                )

            # we now set single elements
            rows, cols, vals = [], [], []
            for key, val in coupling_dict.orbital_items():
                rows.append(self._list.index(key[0]))
                cols.append(self._list.index(key[1]))
                vals.append(val)

            matrix = matrix.at[rows, cols].set(vals)

            return matrix + matrix.conj().T - jnp.diag(jnp.diag(matrix))

        # TODO: oh noes rounding again, but don't know what to do else
        positions = self._get_positions()
        distances = jnp.round(
            jnp.linalg.norm(positions - positions[:, None], axis=-1), 6
        )
        group_ids = jnp.array(self.get_group_ids())

        hamiltonian = fill_matrix(
            jnp.zeros((len(self), len(self))).astype(complex), self._hopping_dict
        )
        coulomb = fill_matrix(
            jnp.zeros((len(self), len(self))).astype(complex), self._coulomb_dict
        )

        return hamiltonian, coulomb

    def _get_positions(self):
        return jnp.array([orb.position for orb in self._list])

    def _ensure_complex(self, func_or_val):
        if callable(func_or_val):
            return lambda x: func_or_val(x) + 0.0j
        if isinstance(func_or_val, (int, float, complex)):
            return func_or_val + 0.0j
        raise TypeError

    # TODO: bla bla bla ... incredibly verbose, but couldn't think of anything better yet
    def _maybe_orbs_to_group_ids(self, maybe_orbs):
        def convert(maybe_orb):
            # TODO: check if this is really a group_id
            if isinstance(maybe_orb, int):
                return maybe_orb
            if isinstance(maybe_orb, Orbital):
                return maybe_orb.group_id
            return "You have passed something that is neither an orbital nor a group_id"
        return [convert(x) for x in maybe_orbs]


    def _maybe_indices_to_orbs(self, maybe_indices):
        def convert(maybe_index):
            if isinstance(maybe_index, int):
                return self._list[maybe_index]
            if isinstance(maybe_index, Orbital):
                return maybe_index
            return "You have passed something that is neither an orbital nor an index"
        return [convert(x) for x in maybe_indices]

    def _build(self):

        # TODO: uff
        assert len(self) &gt; 0
        self._positions = self._get_positions()

        self._hamiltonian, self._coulomb = self._hamiltonian_coulomb()

        self._eigenvectors, self._energies = jax.lax.linalg.eigh(self._hamiltonian)

        self._initial_density_matrix = _numerics._density_matrix(
            self._energies,
            self.electrons,
            self.spin_degeneracy,
            self.eps,
            self.from_state,
            self.to_state,
            self.excited_electrons,
            self.beta,
        )
        self._stationary_density_matrix = _numerics._density_matrix(
            self._energies,
            self.electrons,
            self.spin_degeneracy,
            self.eps,
            jnp.array([0]),
            jnp.array([0]),
            jnp.array([0]),
            self.beta,
        )

        # TODO: uff
        if self.self_consistency_params:
            (
                self._hamiltonian,
                self._initial_density_matrix,
                self._stationary_density_matrix,
                self._energies,
                self._eigenvectors,
            ) = _get_self_consistent(
                self._hamiltonian,
                self._coulomb,
                self._positions,
                self.spin_degeneracy,
                self.electrons,
                self.eps,
                self._eigenvectors,
                self._static_density_matrix,
                **self.self_consistent_params,
            )

    def get_group_ids(self):
        """
        Retrieves a list of group IDs for all orbitals managed by this object.

        Returns:
            List[int]: A list of group IDs for each orbital.
        """
        return [orb.group_id for orb in self._list]

    def get_unique_group_ids(self):
        """
        Retrieves a unique set of group IDs from all orbitals.

        Returns:
            List[int]: A list of unique group IDs.
        """
        return list(set(self.get_group_ids()))

    def set_groups_hopping(self, orb_or_group_id1, orb_or_group_id2, func):
        """
        Sets the hopping coupling between two groups of orbitals.

        Parameters:
            orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group.
            orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group.
            func (callable): Function that defines the hopping interaction.

        Notes:
            The function `func` should be complex-valued.
        """
        group_id1, group_id2 = self._maybe_orbs_to_group_ids(
            (orb_or_group_id1, orb_or_group_id2)
        )
        self._set_coupling(
            group_id1, group_id2, self._ensure_complex(func), self._hopping_dict
        )

    def set_groups_coulomb(self, orb_or_group_id1, orb_or_group_id2, func):
        """
        Sets the Coulomb coupling between two groups of orbitals.

        Parameters:
            orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group.
            orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group.
            func (callable): Function that defines the Coulomb interaction.

        Notes:
            The function `func` should be complex-valued.
        """
        group_id1, group_id2 = self._maybe_orbs_to_group_ids(
            (orb_or_group_id1, orb_or_group_id2)
        )
        self._set_coupling(
            group_id1, group_id2, self._ensure_complex(func), self._coulomb_dict
        )

    def set_hamiltonian_element(self, orb_or_index1, orb_or_index2, val):
        """
        Sets an element of the Hamiltonian matrix between two orbitals or indices.

        Parameters:
            orb_or_index1 (int or Orbital): Identifier or orbital for the first element.
            orb_or_index2 (int or Orbital): Identifier or orbital for the second element.
            val (complex): The complex value to set for the Hamiltonian element.
        """
        orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2))
        self._set_coupling(orb1, orb2, self._ensure_complex(val), self._hopping_dict)

    def set_coulomb_element(self, orb_or_index1, orb_or_index2, val):
        """
        Sets a Coulomb interaction element between two orbitals or indices.

        Parameters:
            orb_or_index1 (int or Orbital): Identifier or orbital for the first element.
            orb_or_index2 (int or Orbital): Identifier or orbital for the second element.
            val (complex): The complex value to set for the Coulomb interaction element.
        """
        orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2))
        self._set_coupling(orb1, orb2, self._ensure_complex(val), self._coulomb_dict)

    @mutates
    def append(self, other):
        """
        Appends an orbital to the list, ensuring it is not already present.

        Parameters:
            other (Orbital): The orbital to append.

        Raises:
            TypeError: If `other` is not an instance of Orbital.
            ValueError: If `other` is already in the list.
        """
        if not isinstance(other, Orbital):
            raise TypeError
        if other in self:
            raise ValueError
        self._list.append(other)

    # TODO: remove this once better position handling is done
    @mutates
    def shift_by_vector(self, tag, translation_vector):
        """
        Shifts all orbitals with a specific tag by a given vector.

        Parameters:
            tag (str): The tag to match orbitals.
            translation_vector (jax.Array): The vector by which to translate the orbital positions.

        Notes:
            This operation mutates the positions of the matched orbitals.
        """
        orbs = [orb for orb in self._list if orb.tag == tag]
        for orb in orbs:
            orb.position += translation_vector

    # TODO: validate
    @mutates
    def make_self_consistent(self, sc_params):
        """
        Configures the list for self-consistent field calculations.

        Parameters:
            sc_params (dict): Parameters for self-consistency.
        """
        self.self_consistency_params = sc_params

    # TODO: uff
    @mutates
    def set_excitation(self, from_state, to_state, excited_electrons):
        """
        Sets up an excitation process from one state to another with specified electrons.

        Parameters:
            from_state (int, list, or jax.Array): The initial state index or indices.
            to_state (int, list, or jax.Array): The final state index or indices.
            excited_electrons (int, list, or jax.Array): The indices of electrons to be excited.

        Notes:
            The states and electron indices may be specified as scalars, lists, or arrays.
        """
        def maybe_int_to_arr(maybe_int):
            if isinstance(maybe_int, int):
                return jnp.array([maybe_int])
            if isinstance(maybe_int, list):
                maybe_int = jnp.array(maybe_int)
            if isinstance(maybe_int, jax.Array):
                return (
                    jnp.array(maybe_int)
                    if maybe_int.ndim &gt; 1
                    else jnp.array([maybe_int])
                )
            raise TypeError

        self.from_state = maybe_int_to_arr(from_state)
        self.to_state = maybe_int_to_arr(to_state)
        self.excited_electrons = maybe_int_to_arr(excited_electrons)

    @mutates
    def set_dipole_transition(self, orb_or_index1, orb_or_index2, arr):
        """
        Sets a dipole transition for specified orbital or index pairs.

        Parameters:
            orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition.
            orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition.
            arr (jax.Array): The 3-element array containing dipole transition elements.
        """
        orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2))
        self._transitions[(orb_or_index1, orb_or_index2)] = jnp.array(arr).astype(
            complex
        )

    # TODO: bla bla bla
    @property
    @recomputes
    def homo(self):
        # TODO: hmmm
        return jnp.diag(self._stationary_density_matrix).nonzero()[0][-1]

    @property
    @recomputes
    def positions(self):
        return self._positions

    @property
    @recomputes
    def eigenvectors(self):
        return self._eigenvectors

    @property
    @recomputes
    def energies(self):
        return self._energies

    # TODO: uff decorator inception, also should return copies to avoid weirdness
    @property
    @recomputes
    def hamiltonian(self):
        return self._hamiltonian

    @property
    @recomputes
    def coulomb(self):
        return self._coulomb

    @property
    @recomputes
    def initial_density_matrix(self):
        return self._initial_density_matrix

    @property
    @recomputes
    def stationary_density_matrix(self):
        return self._stationary_density_matrix

    @property
    @recomputes
    def quadrupole_operator(self):
        """
        Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components.

        Returns:
           jax.Array: A tensor representing the quadrupole operator.
        """

        dip = self.dipole_operator
        term = jnp.einsum("ijk,jlm-&gt;ilkm", dip, dip)
        diag = jnp.einsum("ijk,jlk-&gt;il", dip, dip)
        diag = jnp.einsum("ij,kl-&gt;ijkl", diag, jnp.eye(term.shape[-1]))
        return 3 * term - diag

    @property
    @recomputes
    def dipole_operator(self):
        """
        Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values.

        Returns:
           jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated.
        """

        N = self.positions.shape[0]
        dipole_operator = jnp.zeros((3, N, N)).astype(complex)
        for i in range(3):
            dipole_operator = dipole_operator.at[i, :, :].set(
                jnp.diag(self._positions[:, i] / 2)
            )
        for orbital_combination, value in self._transitions.items():
            i, j = self._list.index(orbital_combination[0]), self._list.index(
                orbital_combination[1]
            )
            k = value.nonzero()[0]
            dipole_operator = dipole_operator.at[k, i, j].set(value[k])
        return dipole_operator + jnp.transpose(dipole_operator, (0, 2, 1)).conj()

    @property
    @recomputes
    def velocity_operator(self):
        """
        Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications.

        Returns:
           jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian.
        """

        if self._transitions is None:
            x_times_h = jnp.einsum("ij,iL-&gt;ijL", self._hamiltonian, self._positions)
            h_times_x = jnp.einsum("ij,jL-&gt;ijL", self._hamiltonian, self._positions)
        else:
            positions = self.dipole_operator
            x_times_h = jnp.einsum("kj,Lik-&gt;Lij", self._hamiltonian, positions)
            h_times_x = jnp.einsum("ik,Lkj-&gt;Lij", self._hamiltonian, positions)
        return -1j * (x_times_h - h_times_x)

    @property
    @recomputes
    def transition_energies(self):
        """
        Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack.

        Returns:
           jax.Array: The element `arr[i,j]` contains the transition energy from `i` to `j`.
        """
        return self._energies[:, None] - self._energies

    @property
    @recomputes
    def wigner_weisskopf_transition_rates(self):
        """
        Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis.

        Returns:
           jax.Array: The element `arr[i,j]` contains the transition rate from `i` to `j`.
        """
        charge = 1.602e-19
        eps_0 = 8.85 * 1e-12
        hbar = 1.0545718 * 1e-34
        c = 3e8  # 137 (a.u.)
        factor = 1.6e-29 * charge / (3 * jnp.pi * eps_0 * hbar**2 * c**3)
        te = self.transition_energies
        transition_dipole_moments = self.transform_to_energy_basis(self.dipole_operator)
        return (
            (te * (te &gt; self.eps)) ** 3
            * jnp.squeeze(transition_dipole_moments**2)
            * factor
        )

    @staticmethod
    def _transform_basis(observable, vectors):
        dims_einsum_strings = {2: "ij,jk,lk-&gt;il", 3: "ij,mjk,lk-&gt;mil"}
        einsum_string = dims_einsum_strings[(observable.ndim)]
        return jnp.einsum(einsum_string, vectors, observable, vectors.conj())

    def transform_to_site_basis(self, observable):
        """
        Transforms an observable to the site basis using eigenvectors of the system.

        Parameters:
           observable (jax.Array): The observable to transform.

        Returns:
           jax.Array: The transformed observable in the site basis.
        """
        return self._transform_basis(observable, self._eigenvectors)

    def transform_to_energy_basis(self, observable):#
        """
        Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors.

        Parameters:
           observable (jax.Array): The observable to transform.

        Returns:
           jax.Array: The transformed observable in the energy basis.
        """

        return self._transform_basis(observable, self._eigenvectors.conj().T)

    @recomputes
    def get_charge(density_matrix: None):
        """
        Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified.

        Parameters:
           density_matrix (jax.Array, optional): The density matrix to use for calculating charge.

        Returns:
           jax.Array: A diagonal array representing charges at each site.
        """
        if density_matrix is None:
            return jnp.diag(
                self.transform_to_site_basis(self.initial_density_matrix)
                * self.electrons
            )
        else:
            return jnp.diag(density_matrix * self.electrons)

    @recomputes
    def get_dos(self, omega: float, broadening: float = 0.1):
        """
        Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening.

        Parameters:
           omega (float): The frequency at which to evaluate the DOS.
           broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas.

        Returns:
           float: The integrated density of states at the specified frequency.
        """

        broadening = 1 / broadening
        prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening)
        gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2)
        return prefactor * jnp.sum(gaussians)

    # TODO: make compatbile with orbital
    @recomputes
    def get_ldos(self, omega: float, site_index: int, broadening: float = 0.1):
        """
        Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack.

        Parameters:
           omega (float): The frequency at which to evaluate the LDOS.
           site_index (int): The site index to evaluate the LDOS at.
           broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas.

        Returns:
           float: The local density of states at the specified site and frequency.
        """

        broadening = 1 / broadening
        weight = jnp.abs(self._eigenvectors[site_index, :]) ** 2
        prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening)
        gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2)
        return prefactor * jnp.sum(weight * gaussians)

    @recomputes
    def get_epi(self, rho: jax.Array, omega: float, epsilon: float = None) -&gt; float:
        """
        Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency.

        Parameters:
           rho (jax.Array): The density matrix to consider for EPI calculation.
           omega (float): The frequency to evaluate the EPI at.
           epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided.

        Returns:
           float: The EPI.
        """

        epsilon = self.params.eps if epsilon is None else epsilon
        rho_without_diagonal = jnp.abs(rho - jnp.diag(jnp.diag(rho)))
        rho_normalized = rho_without_diagonal / jnp.linalg.norm(rho_without_diagonal)
        te = self.transition_energies
        excitonic_transitions = (
            rho_normalized / (te * (te &gt; self.eps) - omega + 1j * epsilon) ** 2
        )
        return 1 - jnp.sum(jnp.abs(excitonic_transitions * rho_normalized)) / (
            jnp.linalg.norm(rho_normalized) * jnp.linalg.norm(excitonic_transitions)
        )

    @recomputes
    def get_induced_field(self, positions: jax.Array, density_matrix):
        """
        Calculates the induced electric field at specified positions based on a given density matrix.

        Parameters:
           positions (jax.Array): The positions at which to evaluate the induced field.
           density_matrix (jax.Array): The density matrix used to calculate the induced field.

        Returns:
           jax.Array: The resulting electric field vector at each position.
        """


        # distance vector array from field sources to positions to evaluate field on
        vec_r = self._positions[:, None] - positions

        # scalar distances
        denominator = jnp.linalg.norm(vec_r, axis=2) ** 3

        # normalize distance vector array
        point_charge = jnp.nan_to_num(
            vec_r / denominator[:, :, None], posinf=0.0, neginf=0.0
        )

        # compute charge via occupations in site basis
        charge = self.electrons * self.transform_to_site_basis(density_matrix).real

        # induced field is a sum of point charges, i.e. \vec{r} / r^3
        e_field = 14.39 * jnp.sum(point_charge * charge[:, None, None], axis=0)
        return e_field

    @staticmethod
    def get_expectation_value(operator, density_matrix):
        """
        Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays.

        Parameters:
           operator (jax.Array): The operator for which the expectation value is calculated.
           density_matrix (jax.Array): The density matrix representing the state of the system.

        Returns:
           jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix.
        """

        dims_einsum_strings = {
            (3, 2): "ijk,kj-&gt;i",
            (3, 3): "ijk,lkj-&gt;il",
            (2, 3): "ij,kji-&gt;k",
            (2, 2): "ij,ji-&gt;",
        }
        return jnp.einsum(
            dims_einsum_strings[(operator.ndim, density_matrix.ndim)],
            operator,
            density_matrix,
        )

    # TODO: uff, all of the methods below should be rewritten
    def get_expectation_value_time_domain(self, *args, **kwargs):
        """
        Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix.

        Parameters:
        The same as for get_density_matrix_time_domain, except operator

        Returns:
           Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time.
        """

        operator = kwargs.pop("operator", None)
        correction = self.transform_to_site_basis(self.stationary_density_matrix)
        time_axis, density_matrices = self.get_density_matrix_time_domain(
            *args, **kwargs
        )
        try:
            return time_axis, self.electrons * self.get_expectation_value(
                correction - density_matrices.ys, operator
            )
        except AttributeError:
            return time_axis, self.electrons * self.get_expectation_value(
                correction - density_matrices, operator
            )

    def get_expectation_value_frequency_domain(self, *args, **kwargs):
        """
        Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations.

        Parameters:
        The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator.

        Returns:
           Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data.
        """

        omega_min = kwargs.pop("omega_min", 0)
        omega_max = kwargs.pop("omega_max", 100)
        time_axis, exp_val_td = self.get_expectation_value_time_domain(*args, **kwargs)
        omega, exp_val_omega = _numerics.get_fourier_transform(time_axis, exp_val_td)
        mask = (omega &gt;= omega_min) &amp; (omega &lt;= omega_max)
        try:
            electric_field = jax.vmap(kwargs["illumination"])(time_axis)
            field_omega = _numerics.get_fourier_transform(
                time_axis, electric_field, return_omega_axis=False
            )
            return omega[mask], exp_val_omega[mask], field_omega[mask]
        except KeyError:
            return omega[mask], exp_val_omega[mask]

    @recomputes
    def get_density_matrix_time_domain(
        self,
        end_time: float,
        illumination: Callable[[float], jax.Array],
        start_time: Optional[float] = None,
        steps_time: Optional[int] = None,
        skip: Optional[int] = None,
        relaxation_rate: Union[float, jax.Array] = None,
        saturation_functional: Callable[[float], float] = lambda x: 1
        / (1 + jnp.exp(-1e6 * (2.0 - x))),
        use_old_method: bool = False,
        include_induced_contribution: bool = False,
        use_rwa=False,
        compute_only_at=None,
        coulomb_strength=1.0,
        solver=diffrax.Dopri5(),
        stepsize_controller=diffrax.PIDController(rtol=1e-10, atol=1e-10),
    ):
        """
        Simulates the time evolution of the density matrix for a given system under specified conditions and external fields.

        Parameters:
           end_time (float): The end time for the simulation.
           illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time.
           start_time (Optional[float]): The start time for the simulation, defaults to zero.
           steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000)
           skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix.
           relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied.
           saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function.
           use_old_method (bool): Flag to use the old RK method.
           include_induced_contribution (bool): Whether to include induced contributions in the simulation.
           use_rwa (bool): Whether to apply the rotating wave approximation.
           compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed.
           coulomb_strength (float): Strength of Coulomb interactions.
           solver (diffrax.Solver): The differential equation solver to use.
           stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size.

        Returns:
           Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals.
        """

        # Time axis creation
        start_time = float(start_time) if start_time is not None else 0.0
        steps_time = int(steps_time) if steps_time is not None else int(end_time * 1000)
        time_axis = jnp.linspace(start_time, end_time, steps_time)
        skip = skip if skip is not None else 1

        # Determine relaxation function based on the input type
        if relaxation_rate is None:
            relaxation_function = lambda r: 0.0
        elif isinstance(relaxation_rate, jax.Array):
            relaxation_function = _numerics.lindblad_saturation_functional(
                self._eigenvectors,
                relaxation_rate,
                saturation_functional,
                self.electrons,
                self._stationary_density_matrix,
            )
        else:
            relaxation_function = _numerics.relaxation_time_approximation(
                relaxation_rate,
                self.transform_to_site_basis(self._stationary_density_matrix),
            )

        # Verify that illumination is a callable
        if not callable(illumination):
            raise TypeError("Provide a function for e-field")

        # Initialize common variables
        initial_density_matrix = self.transform_to_site_basis(
            self._initial_density_matrix
        )
        stationary_density_matrix = self.transform_to_site_basis(
            self._stationary_density_matrix
        )
        coulomb_field_to_from = _numerics.get_coulomb_field_to_from(
            self.positions, self.positions, compute_only_at
        )

        # TODO: not very elegant: we just dump every argument in there by default
        return time_axis[::skip], _numerics.integrate_master_equation(
            self._hamiltonian,
            coulomb_strength * self._coulomb,
            self.dipole_operator,
            self.electrons,
            self.velocity_operator,
            initial_density_matrix,
            stationary_density_matrix,
            time_axis,
            illumination,
            relaxation_function,
            coulomb_field_to_from,
            include_induced_contribution,
            use_rwa,
            solver,
            stepsize_controller,
            use_old_method,
            skip,
        )

    # TODO: uff, again verbose
    def get_polarizability_rpa(
        self,
        omegas,            
        relaxation_rate,
        polarization,
        coulomb_strength=1.0,
        hungry=0,
        phi_ext=None,
    ):
        """
        Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions.

        Parameters:
           omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas.
           relaxation_rate (float): The relaxation time parameter.
           polarization (jax.Array): Polarization directions or modes.
           coulomb_strength (float): The strength of Coulomb interaction in the calculations.
           hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage.
           phi_ext (Optional[jax.Array]): External potential influences, if any.

        Returns:
           jax.Array: The calculated polarizabilities at the specified frequencies.
        """

        alpha = _numerics.rpa_polarizability_function(
            self, relaxation_rate, polarization, coulomb_strength, phi_ext, hungry
        )
        if omegas.ndim == 1:        
            return jax.lax.map(alpha, omegas)
        else:
            return jnp.concatenate( [ jax.vmap(alpha)(omega) for omega in omegas ] )

    def get_susceptibility_rpa(
            self, omegas, relaxation_rate, coulomb_strength=1.0, hungry=0
    ):
        """
        Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies.

        Parameters:
           omegas (jax.Array): The frequencies at which to compute susceptibility.
           relaxation_rate (float): The relaxation time affecting susceptibility calculations.
           coulomb_strength (float): The strength of Coulomb interactions considered in the calculations.
           hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage.

        Returns:
           jax.Array: The susceptibility values at the given frequencies.
        """

        sus = _numerics.rpa_polarizability_function(
            self, relaxation_rate, coulomb_strength, hungry
        )
        return jax.lax.map(sus, omegas)</code></pre>
            </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="granad.orbitals.OrbitalList.dipole_operator" class="doc doc-heading">
          <code class="highlight language-python">dipole_operator</code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="granad.orbitals.OrbitalList.quadrupole_operator" class="doc doc-heading">
          <code class="highlight language-python">quadrupole_operator</code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: A tensor representing the quadrupole operator.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="granad.orbitals.OrbitalList.transition_energies" class="doc doc-heading">
          <code class="highlight language-python">transition_energies</code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: The element <code>arr[i,j]</code> contains the transition energy from <code>i</code> to <code>j</code>.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="granad.orbitals.OrbitalList.velocity_operator" class="doc doc-heading">
          <code class="highlight language-python">velocity_operator</code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="granad.orbitals.OrbitalList.wigner_weisskopf_transition_rates" class="doc doc-heading">
          <code class="highlight language-python">wigner_weisskopf_transition_rates</code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: The element <code>arr[i,j]</code> contains the transition rate from <code>i</code> to <code>j</code>.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>  </div>

</div>




<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.append" class="doc doc-heading">
          <code class="highlight language-python">append(other)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Appends an orbital to the list, ensuring it is not already present.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>other</code></b>
                  (<code><a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>The orbital to append.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>TypeError</code>
              â€“
              <div class="doc-md-description">
                <p>If <code>other</code> is not an instance of Orbital.</p>
              </div>
            </li>
            <li>
                  <code>ValueError</code>
              â€“
              <div class="doc-md-description">
                <p>If <code>other</code> is already in the list.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@mutates
def append(self, other):
    """
    Appends an orbital to the list, ensuring it is not already present.

    Parameters:
        other (Orbital): The orbital to append.

    Raises:
        TypeError: If `other` is not an instance of Orbital.
        ValueError: If `other` is already in the list.
    """
    if not isinstance(other, Orbital):
        raise TypeError
    if other in self:
        raise ValueError
    self._list.append(other)</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_charge" class="doc doc-heading">
          <code class="highlight language-python">get_charge(density_matrix)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>density_matrix</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The density matrix to use for calculating charge.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: A diagonal array representing charges at each site.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@recomputes
def get_charge(density_matrix: None):
    """
    Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified.

    Parameters:
       density_matrix (jax.Array, optional): The density matrix to use for calculating charge.

    Returns:
       jax.Array: A diagonal array representing charges at each site.
    """
    if density_matrix is None:
        return jnp.diag(
            self.transform_to_site_basis(self.initial_density_matrix)
            * self.electrons
        )
    else:
        return jnp.diag(density_matrix * self.electrons)</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_density_matrix_time_domain" class="doc doc-heading">
          <code class="highlight language-python">get_density_matrix_time_domain(end_time, illumination, start_time=None, steps_time=None, skip=None, relaxation_rate=None, saturation_functional=lambda x: 1 / 1 + jnp.exp(-1000000.0 * 2.0 - x), use_old_method=False, include_induced_contribution=False, use_rwa=False, compute_only_at=None, coulomb_strength=1.0, solver=diffrax.Dopri5(), stepsize_controller=diffrax.PIDController(rtol=1e-10, atol=1e-10))</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Simulates the time evolution of the density matrix for a given system under specified conditions and external fields.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>end_time</code></b>
                  (<code>float</code>)
              â€“
              <div class="doc-md-description">
                <p>The end time for the simulation.</p>
              </div>
            </li>
            <li>
              <b><code>illumination</code></b>
                  (<code><span title="typing.Callable">Callable</span>[[float], <span title="jax.Array">Array</span>]</code>)
              â€“
              <div class="doc-md-description">
                <p>A function that returns the electric field at a given time.</p>
              </div>
            </li>
            <li>
              <b><code>start_time</code></b>
                  (<code><span title="typing.Optional">Optional</span>[float]</code>, default:
                      <code>None</code>
)
              â€“
              <div class="doc-md-description">
                <p>The start time for the simulation, defaults to zero.</p>
              </div>
            </li>
            <li>
              <b><code>steps_time</code></b>
                  (<code><span title="typing.Optional">Optional</span>[int]</code>, default:
                      <code>None</code>
)
              â€“
              <div class="doc-md-description">
                <p>The number of time steps to simulate, defaults to int(end_time * 1000)</p>
              </div>
            </li>
            <li>
              <b><code>skip</code></b>
                  (<code><span title="typing.Optional">Optional</span>[int]</code>, default:
                      <code>None</code>
)
              â€“
              <div class="doc-md-description">
                <p>The interval at which to record results, defaults to 1, i.e. record every density matrix.</p>
              </div>
            </li>
            <li>
              <b><code>relaxation_rate</code></b>
                  (<code><span title="typing.Union">Union</span>[float, <span title="jax.Array">Array</span>]</code>, default:
                      <code>None</code>
)
              â€“
              <div class="doc-md-description">
                <p>The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied.</p>
              </div>
            </li>
            <li>
              <b><code>saturation_functional</code></b>
                  (<code><span title="typing.Callable">Callable</span>[[float], float]</code>, default:
                      <code>lambda x: 1 / 1 + <span title="jax.numpy.exp">exp</span>(-1000000.0 * 2.0 - x)</code>
)
              â€“
              <div class="doc-md-description">
                <p>A function defining the saturation behavior, defaults to smoothed-out step function.</p>
              </div>
            </li>
            <li>
              <b><code>use_old_method</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              â€“
              <div class="doc-md-description">
                <p>Flag to use the old RK method.</p>
              </div>
            </li>
            <li>
              <b><code>include_induced_contribution</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              â€“
              <div class="doc-md-description">
                <p>Whether to include induced contributions in the simulation.</p>
              </div>
            </li>
            <li>
              <b><code>use_rwa</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              â€“
              <div class="doc-md-description">
                <p>Whether to apply the rotating wave approximation.</p>
              </div>
            </li>
            <li>
              <b><code>compute_only_at</code></b>
                  (<code><span title="typing.Optional">Optional</span>[any]</code>, default:
                      <code>None</code>
)
              â€“
              <div class="doc-md-description">
                <p>Specific orbital indices at which the induced field computation is performed.</p>
              </div>
            </li>
            <li>
              <b><code>coulomb_strength</code></b>
                  (<code>float</code>, default:
                      <code>1.0</code>
)
              â€“
              <div class="doc-md-description">
                <p>Strength of Coulomb interactions.</p>
              </div>
            </li>
            <li>
              <b><code>solver</code></b>
                  (<code><span title="diffrax.Solver">Solver</span></code>, default:
                      <code><span title="diffrax.Dopri5">Dopri5</span>()</code>
)
              â€“
              <div class="doc-md-description">
                <p>The differential equation solver to use.</p>
              </div>
            </li>
            <li>
              <b><code>stepsize_controller</code></b>
                  (<code><span title="diffrax.StepSizeController">StepSizeController</span></code>, default:
                      <code><span title="diffrax.PIDController">PIDController</span>(rtol=1e-10, atol=1e-10)</code>
)
              â€“
              <div class="doc-md-description">
                <p>The controller for the solver's step size.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@recomputes
def get_density_matrix_time_domain(
    self,
    end_time: float,
    illumination: Callable[[float], jax.Array],
    start_time: Optional[float] = None,
    steps_time: Optional[int] = None,
    skip: Optional[int] = None,
    relaxation_rate: Union[float, jax.Array] = None,
    saturation_functional: Callable[[float], float] = lambda x: 1
    / (1 + jnp.exp(-1e6 * (2.0 - x))),
    use_old_method: bool = False,
    include_induced_contribution: bool = False,
    use_rwa=False,
    compute_only_at=None,
    coulomb_strength=1.0,
    solver=diffrax.Dopri5(),
    stepsize_controller=diffrax.PIDController(rtol=1e-10, atol=1e-10),
):
    """
    Simulates the time evolution of the density matrix for a given system under specified conditions and external fields.

    Parameters:
       end_time (float): The end time for the simulation.
       illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time.
       start_time (Optional[float]): The start time for the simulation, defaults to zero.
       steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000)
       skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix.
       relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied.
       saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function.
       use_old_method (bool): Flag to use the old RK method.
       include_induced_contribution (bool): Whether to include induced contributions in the simulation.
       use_rwa (bool): Whether to apply the rotating wave approximation.
       compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed.
       coulomb_strength (float): Strength of Coulomb interactions.
       solver (diffrax.Solver): The differential equation solver to use.
       stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size.

    Returns:
       Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals.
    """

    # Time axis creation
    start_time = float(start_time) if start_time is not None else 0.0
    steps_time = int(steps_time) if steps_time is not None else int(end_time * 1000)
    time_axis = jnp.linspace(start_time, end_time, steps_time)
    skip = skip if skip is not None else 1

    # Determine relaxation function based on the input type
    if relaxation_rate is None:
        relaxation_function = lambda r: 0.0
    elif isinstance(relaxation_rate, jax.Array):
        relaxation_function = _numerics.lindblad_saturation_functional(
            self._eigenvectors,
            relaxation_rate,
            saturation_functional,
            self.electrons,
            self._stationary_density_matrix,
        )
    else:
        relaxation_function = _numerics.relaxation_time_approximation(
            relaxation_rate,
            self.transform_to_site_basis(self._stationary_density_matrix),
        )

    # Verify that illumination is a callable
    if not callable(illumination):
        raise TypeError("Provide a function for e-field")

    # Initialize common variables
    initial_density_matrix = self.transform_to_site_basis(
        self._initial_density_matrix
    )
    stationary_density_matrix = self.transform_to_site_basis(
        self._stationary_density_matrix
    )
    coulomb_field_to_from = _numerics.get_coulomb_field_to_from(
        self.positions, self.positions, compute_only_at
    )

    # TODO: not very elegant: we just dump every argument in there by default
    return time_axis[::skip], _numerics.integrate_master_equation(
        self._hamiltonian,
        coulomb_strength * self._coulomb,
        self.dipole_operator,
        self.electrons,
        self.velocity_operator,
        initial_density_matrix,
        stationary_density_matrix,
        time_axis,
        illumination,
        relaxation_function,
        coulomb_field_to_from,
        include_induced_contribution,
        use_rwa,
        solver,
        stepsize_controller,
        use_old_method,
        skip,
    )</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_dos" class="doc doc-heading">
          <code class="highlight language-python">get_dos(omega, broadening=0.1)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>omega</code></b>
                  (<code>float</code>)
              â€“
              <div class="doc-md-description">
                <p>The frequency at which to evaluate the DOS.</p>
              </div>
            </li>
            <li>
              <b><code>broadening</code></b>
                  (<code>float</code>, default:
                      <code>0.1</code>
)
              â€“
              <div class="doc-md-description">
                <p>The numerical broadening parameter to replace Dirac Deltas.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
<b><code>float</code></b>            â€“
            <div class="doc-md-description">
              <p>The integrated density of states at the specified frequency.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@recomputes
def get_dos(self, omega: float, broadening: float = 0.1):
    """
    Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening.

    Parameters:
       omega (float): The frequency at which to evaluate the DOS.
       broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas.

    Returns:
       float: The integrated density of states at the specified frequency.
    """

    broadening = 1 / broadening
    prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening)
    gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2)
    return prefactor * jnp.sum(gaussians)</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_epi" class="doc doc-heading">
          <code class="highlight language-python">get_epi(rho, omega, epsilon=None)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>rho</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The density matrix to consider for EPI calculation.</p>
              </div>
            </li>
            <li>
              <b><code>omega</code></b>
                  (<code>float</code>)
              â€“
              <div class="doc-md-description">
                <p>The frequency to evaluate the EPI at.</p>
              </div>
            </li>
            <li>
              <b><code>epsilon</code></b>
                  (<code>float</code>, default:
                      <code>None</code>
)
              â€“
              <div class="doc-md-description">
                <p>The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
<b><code>float</code></b>(                <code>float</code>
)            â€“
            <div class="doc-md-description">
              <p>The EPI.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@recomputes
def get_epi(self, rho: jax.Array, omega: float, epsilon: float = None) -&gt; float:
    """
    Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency.

    Parameters:
       rho (jax.Array): The density matrix to consider for EPI calculation.
       omega (float): The frequency to evaluate the EPI at.
       epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided.

    Returns:
       float: The EPI.
    """

    epsilon = self.params.eps if epsilon is None else epsilon
    rho_without_diagonal = jnp.abs(rho - jnp.diag(jnp.diag(rho)))
    rho_normalized = rho_without_diagonal / jnp.linalg.norm(rho_without_diagonal)
    te = self.transition_energies
    excitonic_transitions = (
        rho_normalized / (te * (te &gt; self.eps) - omega + 1j * epsilon) ** 2
    )
    return 1 - jnp.sum(jnp.abs(excitonic_transitions * rho_normalized)) / (
        jnp.linalg.norm(rho_normalized) * jnp.linalg.norm(excitonic_transitions)
    )</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_expectation_value" class="doc doc-heading">
          <code class="highlight language-python">get_expectation_value(operator, density_matrix)</code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>operator</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The operator for which the expectation value is calculated.</p>
              </div>
            </li>
            <li>
              <b><code>density_matrix</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The density matrix representing the state of the system.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@staticmethod
def get_expectation_value(operator, density_matrix):
    """
    Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays.

    Parameters:
       operator (jax.Array): The operator for which the expectation value is calculated.
       density_matrix (jax.Array): The density matrix representing the state of the system.

    Returns:
       jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix.
    """

    dims_einsum_strings = {
        (3, 2): "ijk,kj-&gt;i",
        (3, 3): "ijk,lkj-&gt;il",
        (2, 3): "ij,kji-&gt;k",
        (2, 2): "ij,ji-&gt;",
    }
    return jnp.einsum(
        dims_einsum_strings[(operator.ndim, density_matrix.ndim)],
        operator,
        density_matrix,
    )</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_expectation_value_frequency_domain" class="doc doc-heading">
          <code class="highlight language-python">get_expectation_value_frequency_domain(*args, **kwargs)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations.</p>
<p>Parameters:
The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def get_expectation_value_frequency_domain(self, *args, **kwargs):
    """
    Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations.

    Parameters:
    The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator.

    Returns:
       Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data.
    """

    omega_min = kwargs.pop("omega_min", 0)
    omega_max = kwargs.pop("omega_max", 100)
    time_axis, exp_val_td = self.get_expectation_value_time_domain(*args, **kwargs)
    omega, exp_val_omega = _numerics.get_fourier_transform(time_axis, exp_val_td)
    mask = (omega &gt;= omega_min) &amp; (omega &lt;= omega_max)
    try:
        electric_field = jax.vmap(kwargs["illumination"])(time_axis)
        field_omega = _numerics.get_fourier_transform(
            time_axis, electric_field, return_omega_axis=False
        )
        return omega[mask], exp_val_omega[mask], field_omega[mask]
    except KeyError:
        return omega[mask], exp_val_omega[mask]</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_expectation_value_time_domain" class="doc doc-heading">
          <code class="highlight language-python">get_expectation_value_time_domain(*args, **kwargs)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix.</p>
<p>Parameters:
The same as for get_density_matrix_time_domain, except operator</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def get_expectation_value_time_domain(self, *args, **kwargs):
    """
    Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix.

    Parameters:
    The same as for get_density_matrix_time_domain, except operator

    Returns:
       Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time.
    """

    operator = kwargs.pop("operator", None)
    correction = self.transform_to_site_basis(self.stationary_density_matrix)
    time_axis, density_matrices = self.get_density_matrix_time_domain(
        *args, **kwargs
    )
    try:
        return time_axis, self.electrons * self.get_expectation_value(
            correction - density_matrices.ys, operator
        )
    except AttributeError:
        return time_axis, self.electrons * self.get_expectation_value(
            correction - density_matrices, operator
        )</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_group_ids" class="doc doc-heading">
          <code class="highlight language-python">get_group_ids()</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Retrieves a list of group IDs for all orbitals managed by this object.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>List[int]: A list of group IDs for each orbital.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def get_group_ids(self):
    """
    Retrieves a list of group IDs for all orbitals managed by this object.

    Returns:
        List[int]: A list of group IDs for each orbital.
    """
    return [orb.group_id for orb in self._list]</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_induced_field" class="doc doc-heading">
          <code class="highlight language-python">get_induced_field(positions, density_matrix)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates the induced electric field at specified positions based on a given density matrix.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>positions</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The positions at which to evaluate the induced field.</p>
              </div>
            </li>
            <li>
              <b><code>density_matrix</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The density matrix used to calculate the induced field.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: The resulting electric field vector at each position.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@recomputes
def get_induced_field(self, positions: jax.Array, density_matrix):
    """
    Calculates the induced electric field at specified positions based on a given density matrix.

    Parameters:
       positions (jax.Array): The positions at which to evaluate the induced field.
       density_matrix (jax.Array): The density matrix used to calculate the induced field.

    Returns:
       jax.Array: The resulting electric field vector at each position.
    """


    # distance vector array from field sources to positions to evaluate field on
    vec_r = self._positions[:, None] - positions

    # scalar distances
    denominator = jnp.linalg.norm(vec_r, axis=2) ** 3

    # normalize distance vector array
    point_charge = jnp.nan_to_num(
        vec_r / denominator[:, :, None], posinf=0.0, neginf=0.0
    )

    # compute charge via occupations in site basis
    charge = self.electrons * self.transform_to_site_basis(density_matrix).real

    # induced field is a sum of point charges, i.e. \vec{r} / r^3
    e_field = 14.39 * jnp.sum(point_charge * charge[:, None, None], axis=0)
    return e_field</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_ldos" class="doc doc-heading">
          <code class="highlight language-python">get_ldos(omega, site_index, broadening=0.1)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>omega</code></b>
                  (<code>float</code>)
              â€“
              <div class="doc-md-description">
                <p>The frequency at which to evaluate the LDOS.</p>
              </div>
            </li>
            <li>
              <b><code>site_index</code></b>
                  (<code>int</code>)
              â€“
              <div class="doc-md-description">
                <p>The site index to evaluate the LDOS at.</p>
              </div>
            </li>
            <li>
              <b><code>broadening</code></b>
                  (<code>float</code>, default:
                      <code>0.1</code>
)
              â€“
              <div class="doc-md-description">
                <p>The numerical broadening parameter to replace Dirac Deltas.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
<b><code>float</code></b>            â€“
            <div class="doc-md-description">
              <p>The local density of states at the specified site and frequency.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@recomputes
def get_ldos(self, omega: float, site_index: int, broadening: float = 0.1):
    """
    Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack.

    Parameters:
       omega (float): The frequency at which to evaluate the LDOS.
       site_index (int): The site index to evaluate the LDOS at.
       broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas.

    Returns:
       float: The local density of states at the specified site and frequency.
    """

    broadening = 1 / broadening
    weight = jnp.abs(self._eigenvectors[site_index, :]) ** 2
    prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening)
    gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2)
    return prefactor * jnp.sum(weight * gaussians)</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_polarizability_rpa" class="doc doc-heading">
          <code class="highlight language-python">get_polarizability_rpa(omegas, relaxation_rate, polarization, coulomb_strength=1.0, hungry=0, phi_ext=None)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>omegas</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas.</p>
              </div>
            </li>
            <li>
              <b><code>relaxation_rate</code></b>
                  (<code>float</code>)
              â€“
              <div class="doc-md-description">
                <p>The relaxation time parameter.</p>
              </div>
            </li>
            <li>
              <b><code>polarization</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>Polarization directions or modes.</p>
              </div>
            </li>
            <li>
              <b><code>coulomb_strength</code></b>
                  (<code>float</code>, default:
                      <code>1.0</code>
)
              â€“
              <div class="doc-md-description">
                <p>The strength of Coulomb interaction in the calculations.</p>
              </div>
            </li>
            <li>
              <b><code>hungry</code></b>
                  (<code>int</code>, default:
                      <code>0</code>
)
              â€“
              <div class="doc-md-description">
                <p>speed up the simulation up, higher numbers (max 2) increase RAM usage.</p>
              </div>
            </li>
            <li>
              <b><code>phi_ext</code></b>
                  (<code><span title="typing.Optional">Optional</span>[<span title="jax.Array">Array</span>]</code>, default:
                      <code>None</code>
)
              â€“
              <div class="doc-md-description">
                <p>External potential influences, if any.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: The calculated polarizabilities at the specified frequencies.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def get_polarizability_rpa(
    self,
    omegas,            
    relaxation_rate,
    polarization,
    coulomb_strength=1.0,
    hungry=0,
    phi_ext=None,
):
    """
    Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions.

    Parameters:
       omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas.
       relaxation_rate (float): The relaxation time parameter.
       polarization (jax.Array): Polarization directions or modes.
       coulomb_strength (float): The strength of Coulomb interaction in the calculations.
       hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage.
       phi_ext (Optional[jax.Array]): External potential influences, if any.

    Returns:
       jax.Array: The calculated polarizabilities at the specified frequencies.
    """

    alpha = _numerics.rpa_polarizability_function(
        self, relaxation_rate, polarization, coulomb_strength, phi_ext, hungry
    )
    if omegas.ndim == 1:        
        return jax.lax.map(alpha, omegas)
    else:
        return jnp.concatenate( [ jax.vmap(alpha)(omega) for omega in omegas ] )</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_susceptibility_rpa" class="doc doc-heading">
          <code class="highlight language-python">get_susceptibility_rpa(omegas, relaxation_rate, coulomb_strength=1.0, hungry=0)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>omegas</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The frequencies at which to compute susceptibility.</p>
              </div>
            </li>
            <li>
              <b><code>relaxation_rate</code></b>
                  (<code>float</code>)
              â€“
              <div class="doc-md-description">
                <p>The relaxation time affecting susceptibility calculations.</p>
              </div>
            </li>
            <li>
              <b><code>coulomb_strength</code></b>
                  (<code>float</code>, default:
                      <code>1.0</code>
)
              â€“
              <div class="doc-md-description">
                <p>The strength of Coulomb interactions considered in the calculations.</p>
              </div>
            </li>
            <li>
              <b><code>hungry</code></b>
                  (<code>int</code>, default:
                      <code>0</code>
)
              â€“
              <div class="doc-md-description">
                <p>speed up the simulation up, higher numbers (max 2) increase RAM usage.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: The susceptibility values at the given frequencies.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def get_susceptibility_rpa(
        self, omegas, relaxation_rate, coulomb_strength=1.0, hungry=0
):
    """
    Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies.

    Parameters:
       omegas (jax.Array): The frequencies at which to compute susceptibility.
       relaxation_rate (float): The relaxation time affecting susceptibility calculations.
       coulomb_strength (float): The strength of Coulomb interactions considered in the calculations.
       hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage.

    Returns:
       jax.Array: The susceptibility values at the given frequencies.
    """

    sus = _numerics.rpa_polarizability_function(
        self, relaxation_rate, coulomb_strength, hungry
    )
    return jax.lax.map(sus, omegas)</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.get_unique_group_ids" class="doc doc-heading">
          <code class="highlight language-python">get_unique_group_ids()</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Retrieves a unique set of group IDs from all orbitals.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>List[int]: A list of unique group IDs.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def get_unique_group_ids(self):
    """
    Retrieves a unique set of group IDs from all orbitals.

    Returns:
        List[int]: A list of unique group IDs.
    """
    return list(set(self.get_group_ids()))</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.make_self_consistent" class="doc doc-heading">
          <code class="highlight language-python">make_self_consistent(sc_params)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Configures the list for self-consistent field calculations.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>sc_params</code></b>
                  (<code>dict</code>)
              â€“
              <div class="doc-md-description">
                <p>Parameters for self-consistency.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@mutates
def make_self_consistent(self, sc_params):
    """
    Configures the list for self-consistent field calculations.

    Parameters:
        sc_params (dict): Parameters for self-consistency.
    """
    self.self_consistency_params = sc_params</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.set_coulomb_element" class="doc doc-heading">
          <code class="highlight language-python">set_coulomb_element(orb_or_index1, orb_or_index2, val)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Sets a Coulomb interaction element between two orbitals or indices.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>orb_or_index1</code></b>
                  (<code>int or <a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>Identifier or orbital for the first element.</p>
              </div>
            </li>
            <li>
              <b><code>orb_or_index2</code></b>
                  (<code>int or <a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>Identifier or orbital for the second element.</p>
              </div>
            </li>
            <li>
              <b><code>val</code></b>
                  (<code>complex</code>)
              â€“
              <div class="doc-md-description">
                <p>The complex value to set for the Coulomb interaction element.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def set_coulomb_element(self, orb_or_index1, orb_or_index2, val):
    """
    Sets a Coulomb interaction element between two orbitals or indices.

    Parameters:
        orb_or_index1 (int or Orbital): Identifier or orbital for the first element.
        orb_or_index2 (int or Orbital): Identifier or orbital for the second element.
        val (complex): The complex value to set for the Coulomb interaction element.
    """
    orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2))
    self._set_coupling(orb1, orb2, self._ensure_complex(val), self._coulomb_dict)</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.set_dipole_transition" class="doc doc-heading">
          <code class="highlight language-python">set_dipole_transition(orb_or_index1, orb_or_index2, arr)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Sets a dipole transition for specified orbital or index pairs.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>orb_or_index1</code></b>
                  (<code>int or <a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>Identifier or orbital for the first part of the transition.</p>
              </div>
            </li>
            <li>
              <b><code>orb_or_index2</code></b>
                  (<code>int or <a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>Identifier or orbital for the second part of the transition.</p>
              </div>
            </li>
            <li>
              <b><code>arr</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The 3-element array containing dipole transition elements.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@mutates
def set_dipole_transition(self, orb_or_index1, orb_or_index2, arr):
    """
    Sets a dipole transition for specified orbital or index pairs.

    Parameters:
        orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition.
        orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition.
        arr (jax.Array): The 3-element array containing dipole transition elements.
    """
    orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2))
    self._transitions[(orb_or_index1, orb_or_index2)] = jnp.array(arr).astype(
        complex
    )</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.set_excitation" class="doc doc-heading">
          <code class="highlight language-python">set_excitation(from_state, to_state, excited_electrons)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Sets up an excitation process from one state to another with specified electrons.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>from_state</code></b>
                  (<code>int, list, or jax.Array</code>)
              â€“
              <div class="doc-md-description">
                <p>The initial state index or indices.</p>
              </div>
            </li>
            <li>
              <b><code>to_state</code></b>
                  (<code>int, list, or jax.Array</code>)
              â€“
              <div class="doc-md-description">
                <p>The final state index or indices.</p>
              </div>
            </li>
            <li>
              <b><code>excited_electrons</code></b>
                  (<code>int, list, or jax.Array</code>)
              â€“
              <div class="doc-md-description">
                <p>The indices of electrons to be excited.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<details class="notes" open>
  <summary>Notes</summary>
  <p>The states and electron indices may be specified as scalars, lists, or arrays.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@mutates
def set_excitation(self, from_state, to_state, excited_electrons):
    """
    Sets up an excitation process from one state to another with specified electrons.

    Parameters:
        from_state (int, list, or jax.Array): The initial state index or indices.
        to_state (int, list, or jax.Array): The final state index or indices.
        excited_electrons (int, list, or jax.Array): The indices of electrons to be excited.

    Notes:
        The states and electron indices may be specified as scalars, lists, or arrays.
    """
    def maybe_int_to_arr(maybe_int):
        if isinstance(maybe_int, int):
            return jnp.array([maybe_int])
        if isinstance(maybe_int, list):
            maybe_int = jnp.array(maybe_int)
        if isinstance(maybe_int, jax.Array):
            return (
                jnp.array(maybe_int)
                if maybe_int.ndim &gt; 1
                else jnp.array([maybe_int])
            )
        raise TypeError

    self.from_state = maybe_int_to_arr(from_state)
    self.to_state = maybe_int_to_arr(to_state)
    self.excited_electrons = maybe_int_to_arr(excited_electrons)</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.set_groups_coulomb" class="doc doc-heading">
          <code class="highlight language-python">set_groups_coulomb(orb_or_group_id1, orb_or_group_id2, func)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Sets the Coulomb coupling between two groups of orbitals.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>orb_or_group_id1</code></b>
                  (<code>int or <a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>Identifier or orbital for the first group.</p>
              </div>
            </li>
            <li>
              <b><code>orb_or_group_id2</code></b>
                  (<code>int or <a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>Identifier or orbital for the second group.</p>
              </div>
            </li>
            <li>
              <b><code>func</code></b>
                  (<code>callable</code>)
              â€“
              <div class="doc-md-description">
                <p>Function that defines the Coulomb interaction.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<details class="notes" open>
  <summary>Notes</summary>
  <p>The function <code>func</code> should be complex-valued.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def set_groups_coulomb(self, orb_or_group_id1, orb_or_group_id2, func):
    """
    Sets the Coulomb coupling between two groups of orbitals.

    Parameters:
        orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group.
        orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group.
        func (callable): Function that defines the Coulomb interaction.

    Notes:
        The function `func` should be complex-valued.
    """
    group_id1, group_id2 = self._maybe_orbs_to_group_ids(
        (orb_or_group_id1, orb_or_group_id2)
    )
    self._set_coupling(
        group_id1, group_id2, self._ensure_complex(func), self._coulomb_dict
    )</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.set_groups_hopping" class="doc doc-heading">
          <code class="highlight language-python">set_groups_hopping(orb_or_group_id1, orb_or_group_id2, func)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Sets the hopping coupling between two groups of orbitals.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>orb_or_group_id1</code></b>
                  (<code>int or <a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>Identifier or orbital for the first group.</p>
              </div>
            </li>
            <li>
              <b><code>orb_or_group_id2</code></b>
                  (<code>int or <a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>Identifier or orbital for the second group.</p>
              </div>
            </li>
            <li>
              <b><code>func</code></b>
                  (<code>callable</code>)
              â€“
              <div class="doc-md-description">
                <p>Function that defines the hopping interaction.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<details class="notes" open>
  <summary>Notes</summary>
  <p>The function <code>func</code> should be complex-valued.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def set_groups_hopping(self, orb_or_group_id1, orb_or_group_id2, func):
    """
    Sets the hopping coupling between two groups of orbitals.

    Parameters:
        orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group.
        orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group.
        func (callable): Function that defines the hopping interaction.

    Notes:
        The function `func` should be complex-valued.
    """
    group_id1, group_id2 = self._maybe_orbs_to_group_ids(
        (orb_or_group_id1, orb_or_group_id2)
    )
    self._set_coupling(
        group_id1, group_id2, self._ensure_complex(func), self._hopping_dict
    )</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.set_hamiltonian_element" class="doc doc-heading">
          <code class="highlight language-python">set_hamiltonian_element(orb_or_index1, orb_or_index2, val)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Sets an element of the Hamiltonian matrix between two orbitals or indices.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>orb_or_index1</code></b>
                  (<code>int or <a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>Identifier or orbital for the first element.</p>
              </div>
            </li>
            <li>
              <b><code>orb_or_index2</code></b>
                  (<code>int or <a class="autorefs autorefs-internal" title="granad.orbitals.Orbital" href="#granad.orbitals.Orbital">Orbital</a></code>)
              â€“
              <div class="doc-md-description">
                <p>Identifier or orbital for the second element.</p>
              </div>
            </li>
            <li>
              <b><code>val</code></b>
                  (<code>complex</code>)
              â€“
              <div class="doc-md-description">
                <p>The complex value to set for the Hamiltonian element.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def set_hamiltonian_element(self, orb_or_index1, orb_or_index2, val):
    """
    Sets an element of the Hamiltonian matrix between two orbitals or indices.

    Parameters:
        orb_or_index1 (int or Orbital): Identifier or orbital for the first element.
        orb_or_index2 (int or Orbital): Identifier or orbital for the second element.
        val (complex): The complex value to set for the Hamiltonian element.
    """
    orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2))
    self._set_coupling(orb1, orb2, self._ensure_complex(val), self._hopping_dict)</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.shift_by_vector" class="doc doc-heading">
          <code class="highlight language-python">shift_by_vector(tag, translation_vector)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Shifts all orbitals with a specific tag by a given vector.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>tag</code></b>
                  (<code>str</code>)
              â€“
              <div class="doc-md-description">
                <p>The tag to match orbitals.</p>
              </div>
            </li>
            <li>
              <b><code>translation_vector</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The vector by which to translate the orbital positions.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<details class="notes" open>
  <summary>Notes</summary>
  <p>This operation mutates the positions of the matched orbitals.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">@mutates
def shift_by_vector(self, tag, translation_vector):
    """
    Shifts all orbitals with a specific tag by a given vector.

    Parameters:
        tag (str): The tag to match orbitals.
        translation_vector (jax.Array): The vector by which to translate the orbital positions.

    Notes:
        This operation mutates the positions of the matched orbitals.
    """
    orbs = [orb for orb in self._list if orb.tag == tag]
    for orb in orbs:
        orb.position += translation_vector</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.transform_to_energy_basis" class="doc doc-heading">
          <code class="highlight language-python">transform_to_energy_basis(observable)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>observable</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The observable to transform.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: The transformed observable in the energy basis.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def transform_to_energy_basis(self, observable):#
    """
    Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors.

    Parameters:
       observable (jax.Array): The observable to transform.

    Returns:
       jax.Array: The transformed observable in the energy basis.
    """

    return self._transform_basis(observable, self._eigenvectors.conj().T)</code></pre>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="granad.orbitals.OrbitalList.transform_to_site_basis" class="doc doc-heading">
          <code class="highlight language-python">transform_to_site_basis(observable)</code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Transforms an observable to the site basis using eigenvectors of the system.</p>



<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>observable</code></b>
                  (<code><span title="jax.Array">Array</span></code>)
              â€“
              <div class="doc-md-description">
                <p>The observable to transform.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
      <ul class="first simple">
          <li>
            â€“
            <div class="doc-md-description">
              <p>jax.Array: The transformed observable in the site basis.</p>
            </div>
          </li>
      </ul>
    </td>
    </tr>
  </tbody>
</table>
          <details class="quote">
            <summary>Source code in <code>src/granad/orbitals.py</code></summary>
            <pre class="highlight"><code class="language-python">def transform_to_site_basis(self, observable):
    """
    Transforms an observable to the site basis using eigenvectors of the system.

    Parameters:
       observable (jax.Array): The observable to transform.

    Returns:
       jax.Array: The transformed observable in the site basis.
    """
    return self._transform_basis(observable, self._eigenvectors)</code></pre>
          </details>
  </div>

</div>



  </div>

  </div>


</div>




  </div>

  </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../about/" class="btn btn-neutral float-left" title="About"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../units/" class="btn btn-neutral float-right" title="Units">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../about/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../units/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../javascripts/mathjax.js"></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
