{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to GRANAD GRANAD (GRAphene Nanoflakes with ADatoms) is a tight-binding simulation utility geared towards the exploration of systems at the intersection of solid state physics and quantum optics. Features Computes optical and electronic properties Full access to time-dependent density matrices via master equation Relies on JAX for performance and differentiability Installation If you want to just install the package, run pip install git+https://github.com/GRANADlauncher/granad.git The documentations is built automatically by executing git clone https://github.com/GRANADlauncher/granad.git cd granad bash install.sh Quickstart Set up the simulation import jax.numpy as jnp from granad import Materials , Triangle # get material graphene = Materials . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ) ) # frequencies omegas = jnp . linspace ( 0 , 5 , 50 ) # compute optical properties in the RPA with GPU-acceleration polarizability = flake . get_polarizability_rpa ( omegas , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 # higher numbers are faster and consume more RAM ) absorption = polarizability . imag * 4 * jnp . pi * omegas Plot the results import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas , absorption / jnp . max ( absorption ), linewidth = 2 ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . grid ( True )","title":"Home"},{"location":"#welcome-to-granad","text":"GRANAD (GRAphene Nanoflakes with ADatoms) is a tight-binding simulation utility geared towards the exploration of systems at the intersection of solid state physics and quantum optics.","title":"Welcome to GRANAD"},{"location":"#features","text":"Computes optical and electronic properties Full access to time-dependent density matrices via master equation Relies on JAX for performance and differentiability","title":"Features"},{"location":"#installation","text":"If you want to just install the package, run pip install git+https://github.com/GRANADlauncher/granad.git The documentations is built automatically by executing git clone https://github.com/GRANADlauncher/granad.git cd granad bash install.sh","title":"Installation"},{"location":"#quickstart","text":"Set up the simulation import jax.numpy as jnp from granad import Materials , Triangle # get material graphene = Materials . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ) ) # frequencies omegas = jnp . linspace ( 0 , 5 , 50 ) # compute optical properties in the RPA with GPU-acceleration polarizability = flake . get_polarizability_rpa ( omegas , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 # higher numbers are faster and consume more RAM ) absorption = polarizability . imag * 4 * jnp . pi * omegas Plot the results import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas , absorption / jnp . max ( absorption ), linewidth = 2 ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . grid ( True )","title":"Quickstart"},{"location":"about/","text":"About GRANAD is developed jointly at the Karlsruhe Institute of Technology by the Institute of Theoretical Solid State Physics and at the Nicolaus Copernicus University in Toru\u0144 by the Department of Quantum Physics .","title":"About"},{"location":"about/#about","text":"GRANAD is developed jointly at the Karlsruhe Institute of Technology by the Institute of Theoretical Solid State Physics and at the Nicolaus Copernicus University in Toru\u0144 by the Department of Quantum Physics .","title":"About"},{"location":"api/","text":"API Orbital dataclass Represents the quantum state of an electron in an atom with specific properties. Attributes: position ( Array ) \u2013 The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index ( Optional [ int ] ) \u2013 An optional index representing the layer of the orbital within its atom, may be None if not specified. tag ( Optional [ str ] ) \u2013 An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level ( Optional [ int ] ) \u2013 The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum ( Optional [ int ] ) \u2013 The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z ( Optional [ int ] ) \u2013 The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin ( Optional [ int ] ) \u2013 The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name ( Optional [ str ] ) \u2013 The name of the atom this orbital belongs to, can be None if not applicable. group_id ( int ) \u2013 A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. Source code in src/granad/orbitals.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @dataclass class Orbital : \"\"\" Represents the quantum state of an electron in an atom with specific properties. Attributes: position (jax.Array): The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom, may be None if not specified. tag (Optional[str]): An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable. group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. \"\"\" position : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 , 0 , 0 ]), hash = False , compare = False ) layer_index : Optional [ int ] = None tag : Optional [ str ] = None energy_level : Optional [ int ] = None angular_momentum : Optional [ int ] = None angular_momentum_z : Optional [ int ] = None spin : Optional [ int ] = None atom_name : Optional [ str ] = None group_id : int = field ( default_factory = _watchdog . _Watchdog . next_value ) def __post_init__ ( self ): object . __setattr__ ( self , \"position\" , jnp . array ( self . position ) . astype ( float )) def __hash__ ( self ): # Include only immutable fields in hash calculation return hash ( ( self . layer_index , self . tag , self . energy_level , self . angular_momentum , self . angular_momentum_z , self . angular_momentum , self . spin , self . atom_name , self . group_id , ) ) def __str__ ( self ): return pformat ( vars ( self ), sort_dicts = False ) # TODO: bla bla bla ... this should be shorter but im too tired def __eq__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id == other . group_id and self . layer_index == other . layer_index def __lt__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id < self . group_id def __le__ ( self , other ): return self < other or self == other def __gt__ ( self , other ): return not self <= other def __ge__ ( self , other ): return not self < other def __ne__ ( self , other ): return not self == other OrbitalList A list of orbitals. Source code in src/granad/orbitals.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 @plotting_methods class OrbitalList : \"\"\"A list of orbitals.\"\"\" def __init__ ( self , orbs , _hopping_dict = None , _coulomb_dict = None ): # couplings are dicts mapping orbital pairs to couplings self . _hopping_dict = ( _hopping_dict if _hopping_dict is not None else _SortedTupleDict () ) self . _coulomb_dict = ( _coulomb_dict if _coulomb_dict is not None else _SortedTupleDict () ) self . _transitions = _SortedTupleDict () # contains all high-level simulation information self . _list = list ( orbs ) if orbs is not None else [] # flag for recomputing state self . _recompute = True self . simulation_params = SimulationParams () def __getattr__ ( self , property_name ): if property_name . endswith ( \"_x\" ): return getattr ( self , property_name [: - 2 ]) elif property_name . endswith ( \"_e\" ): return self . transform_to_energy_basis ( getattr ( self , property_name [: - 2 ]) ) def __len__ ( self ): return len ( self . _list ) # can't mutate, because orbitals are immutable def __getitem__ ( self , position ): return self . _list [ position ] def __repr__ ( self ): return repr ( self . _list ) # TODO: hmmm def __str__ ( self ): info = f \"List with { len ( self ) } orbitals, { self . electrons } electrons.\" excited = f \" { self . excited_electrons } electrons excited from { self . from_state } to { self . to_state } .\" groups = \" \\n \" . join ( [ f \"group id { key } : { val } orbitals\" for key , val in Counter ( self . get_group_ids ()) . items () ] ) return \" \\n \" . join (( info , excited , groups )) def __iter__ ( self ): return iter ( self . _list ) # TODO: uff, addition, or, in general, mutation should wipe all attributes except for coupling def __add__ ( self , other ): if not self . _are_orbs ( other ): raise TypeError if any ( orb in other for orb in self . _list ): raise ValueError if isinstance ( other , OrbitalList ): new_hopping_dict = self . _hopping_dict . copy () new_hopping_dict . update ( other . _hopping_dict ) new_coulomb_dict = self . _coulomb_dict . copy () new_coulomb_dict . update ( other . _coulomb_dict ) return OrbitalList ( ( self . _list + list ( other )) . copy (), _SortedTupleDict ( new_hopping_dict ), _SortedTupleDict ( new_coulomb_dict ), ) @mutates def __setitem__ ( self , position , value ): if isinstance ( value , Orbital ): self . _list [ position ] = value raise TypeError def _delete_coupling ( self , orb , coupling ): keys_to_remove = [ key for key in coupling if orb in key ] for key in keys_to_remove : del coupling [ key ] @mutates def __delitem__ ( self , position ): orb = self . _list [ position ] self . _delete_coupling ( orb , self . _hopping_dict ) self . _delete_coupling ( orb , self . _coulomb_dict ) del self . _list [ position ] @staticmethod def _are_orbs ( candidate ): return all ( isinstance ( orb , Orbital ) for orb in candidate ) @mutates def _set_coupling ( self , orb_or_group_id1 , orb_or_group_id2 , val_or_func , coupling ): coupling [( orb_or_group_id1 , orb_or_group_id2 )] = val_or_func # TODO: we may want to differentiate through this, also this is private so better not wrap return val into container def _hamiltonian_coulomb ( self ): def fill_matrix ( matrix , coupling_dict ): # TODO: there should be an internal dummy = jnp . arange ( len ( self )) triangle_mask = dummy [:, None ] >= dummy # TODO: in principle we can build a big tensor NxNxgroups, vmap over the last axis and sum the groups # first, we loop over all group_id couplings => interactions between groups for key , function in coupling_dict . group_id_items (): # TODO: big uff: we rely on the correct ordering of the group_ids for cols and rows, first key is always smaller than last keys => we get upper triangular valid indices # if it were the other way around, these would be zeroed by the triangle mask cols = group_ids == key [ 0 ] rows = ( group_ids == key [ 1 ])[:, None ] combination_indices = jnp . logical_and ( rows , cols ) valid_indices = jnp . logical_and ( triangle_mask , combination_indices ) function = jax . vmap ( function ) matrix = matrix . at [ valid_indices ] . set ( function ( distances [ valid_indices ]) ) # we now set single elements rows , cols , vals = [], [], [] for key , val in coupling_dict . orbital_items (): rows . append ( self . _list . index ( key [ 0 ])) cols . append ( self . _list . index ( key [ 1 ])) vals . append ( val ) matrix = matrix . at [ rows , cols ] . set ( vals ) return matrix + matrix . conj () . T - jnp . diag ( jnp . diag ( matrix )) # TODO: oh noes rounding again, but don't know what to do else positions = self . _get_positions () distances = jnp . round ( jnp . linalg . norm ( positions - positions [:, None ], axis =- 1 ), 6 ) group_ids = jnp . array ( self . get_group_ids ()) hamiltonian = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . _hopping_dict ) coulomb = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . _coulomb_dict ) return hamiltonian , coulomb def _get_positions ( self ): return jnp . array ([ orb . position for orb in self . _list ]) def _ensure_complex ( self , func_or_val ): if callable ( func_or_val ): return lambda x : func_or_val ( x ) + 0.0 j if isinstance ( func_or_val , ( int , float , complex )): return func_or_val + 0.0 j raise TypeError # TODO: bla bla bla ... incredibly verbose, but couldn't think of anything better yet def _maybe_orbs_to_group_ids ( self , maybe_orbs ): def convert ( maybe_orb ): # TODO: check if this is really a group_id if isinstance ( maybe_orb , int ): return maybe_orb if isinstance ( maybe_orb , Orbital ): return maybe_orb . group_id return \"You have passed something that is neither an orbital nor a group_id\" return [ convert ( x ) for x in maybe_orbs ] def _maybe_indices_to_orbs ( self , maybe_indices ): def convert ( maybe_index ): if isinstance ( maybe_index , int ): return self . _list [ maybe_index ] if isinstance ( maybe_index , Orbital ): return maybe_index return \"You have passed something that is neither an orbital nor an index\" return [ convert ( x ) for x in maybe_indices ] def _build ( self ): # TODO: uff assert len ( self ) > 0 self . _positions = self . _get_positions () self . _hamiltonian , self . _coulomb = self . _hamiltonian_coulomb () self . _eigenvectors , self . _energies = jax . lax . linalg . eigh ( self . _hamiltonian ) self . _initial_density_matrix = _numerics . _density_matrix ( self . _energies , self . electrons , self . spin_degeneracy , self . eps , self . from_state , self . to_state , self . excited_electrons , self . beta , ) self . _stationary_density_matrix = _numerics . _density_matrix ( self . _energies , self . electrons , self . spin_degeneracy , self . eps , jnp . array ([ 0 ]), jnp . array ([ 0 ]), jnp . array ([ 0 ]), self . beta , ) # TODO: uff if self . self_consistency_params : ( self . _hamiltonian , self . _initial_density_matrix , self . _stationary_density_matrix , self . _energies , self . _eigenvectors , ) = _get_self_consistent ( self . _hamiltonian , self . _coulomb , self . _positions , self . spin_degeneracy , self . electrons , self . eps , self . _eigenvectors , self . _static_density_matrix , ** self . self_consistent_params , ) self . _initial_density_matrix = self . transform_to_site_basis ( self . _initial_density_matrix ) self . _stationary_density_matrix = self . transform_to_site_basis ( self . _stationary_density_matrix ) def get_group_ids ( self ): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [ orb . group_id for orb in self . _list ] def get_unique_group_ids ( self ): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list ( set ( self . get_group_ids ())) def set_groups_hopping ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _hopping_dict ) def set_groups_coulomb ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _coulomb_dict ) def set_hamiltonian_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _hopping_dict ) def set_coulomb_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _coulomb_dict ) def index ( self , orb ): return self . _list . index ( orb ) @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other ) # TODO: remove this once better position handling is done @mutates def shift_by_vector ( self , tag , translation_vector ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag (str): The tag to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [ orb for orb in self . _list if orb . tag == tag ] for orb in orbs : orb . position += translation_vector # TODO: validate @mutates def make_self_consistent ( self , sc_params ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self . self_consistency_params = sc_params # TODO: uff @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): maybe_int = jnp . array ( maybe_int ) if isinstance ( maybe_int , jax . Array ): return ( jnp . array ( maybe_int ) if maybe_int . ndim > 1 else jnp . array ([ maybe_int ]) ) raise TypeError self . simulation_params . from_state = maybe_int_to_arr ( from_state ) self . simulation_params . to_state = maybe_int_to_arr ( to_state ) self . simulation_params . excited_electrons = maybe_int_to_arr ( excited_electrons ) @mutates def set_dipole_transition ( self , orb_or_index1 , orb_or_index2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _transitions [( orb_or_index1 , orb_or_index2 )] = jnp . array ( arr ) . astype ( complex ) # TODO: bla bla bla @property @recomputes def homo ( self ): # TODO: hmmm return ( self . electrons * self . stationary_density_matrix_e ) . real . diagonal () . round ( 2 ) . nonzero ()[ 0 ] . item () @property def electrons ( self ): if self . simulation_params . electrons is None : return len ( self . _list ) return self . simulation_params . electrons @property def spin_degeneracy ( self ): return self . simulation_params . spin_degeneracy @property def from_state ( self ): return self . simulation_params . from_state @property def to_state ( self ): return self . simulation_params . to_state @property def excited_electrons ( self ): return self . simulation_params . excited_electrons @property def beta ( self ): return self . simulation_params . beta @property def eps ( self ): return self . simulation_params . eps @property @recomputes def positions ( self ): return self . _positions @property @recomputes def eigenvectors ( self ): return self . _eigenvectors @property @recomputes def energies ( self ): return self . _energies # TODO: uff decorator inception, also should return copies to avoid weirdness @property @recomputes def hamiltonian ( self ): return self . _hamiltonian @property @recomputes def coulomb ( self ): return self . _coulomb @property @recomputes def initial_density_matrix ( self ): return self . _initial_density_matrix @property @recomputes def stationary_density_matrix ( self ): return self . _stationary_density_matrix @property @recomputes def quadrupole_operator ( self ): \"\"\" Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: jax.Array: A tensor representing the quadrupole operator. \"\"\" dip = self . dipole_operator term = jnp . einsum ( \"ijk,jlm->ilkm\" , dip , dip ) diag = jnp . einsum ( \"ijk,jlk->il\" , dip , dip ) diag = jnp . einsum ( \"ij,kl->ijkl\" , diag , jnp . eye ( term . shape [ - 1 ])) return 3 * term - diag @property @recomputes def dipole_operator ( self ): \"\"\" Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. \"\"\" N = self . positions . shape [ 0 ] dipole_operator = jnp . zeros (( 3 , N , N )) . astype ( complex ) for i in range ( 3 ): dipole_operator = dipole_operator . at [ i , :, :] . set ( jnp . diag ( self . _positions [:, i ] / 2 ) ) for orbital_combination , value in self . _transitions . items (): i , j = self . _list . index ( orbital_combination [ 0 ]), self . _list . index ( orbital_combination [ 1 ] ) k = value . nonzero ()[ 0 ] dipole_operator = dipole_operator . at [ k , i , j ] . set ( value [ k ]) return dipole_operator + jnp . transpose ( dipole_operator , ( 0 , 2 , 1 )) . conj () @property @recomputes def velocity_operator ( self ): \"\"\" Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. \"\"\" if self . _transitions is None : x_times_h = jnp . einsum ( \"ij,iL->ijL\" , self . _hamiltonian , self . _positions ) h_times = jnp . einsum ( \"ij,jL->ijL\" , self . _hamiltonian , self . _positions ) else : positions = self . dipole_operator x_times_h = jnp . einsum ( \"kj,Lik->Lij\" , self . _hamiltonian , positions ) h_times = jnp . einsum ( \"ik,Lkj->Lij\" , self . _hamiltonian , positions ) return - 1 j * ( x_times_h - h_times ) @property @recomputes def transition_energies ( self ): \"\"\" Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: jax.Array: The element `arr[i,j]` contains the transition energy from `i` to `j`. \"\"\" return self . _energies [:, None ] - self . _energies @property @recomputes def wigner_weisskopf_transition_rates ( self ): \"\"\" Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: jax.Array: The element `arr[i,j]` contains the transition rate from `i` to `j`. \"\"\" charge = 1.602e-19 eps_0 = 8.85 * 1e-12 hbar = 1.0545718 * 1e-34 c = 3e8 # 137 (a.u.) factor = 1.6e-29 * charge / ( 3 * jnp . pi * eps_0 * hbar ** 2 * c ** 3 ) te = self . transition_energies transition_dipole_moments = self . dipole_operator_e return ( ( te * ( te > self . eps )) ** 3 * jnp . squeeze ( transition_dipole_moments ** 2 ) * factor ) @staticmethod def _transform_basis ( observable , vectors ): dims_einsum_strings = { 2 : \"ij,jk,lk->il\" , 3 : \"ij,mjk,lk->mil\" } einsum_string = dims_einsum_strings [( observable . ndim )] return jnp . einsum ( einsum_string , vectors , observable , vectors . conj ()) def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors ) def transform_to_energy_basis ( self , observable ): # \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T ) @recomputes def get_charge ( density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None : return jnp . diag ( self . initial_density_matrix * self . electrons ) else : return jnp . diag ( density_matrix * self . electrons ) @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians ) # TODO: make compatbile with orbital @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians ) @recomputes def get_epi ( self , rho : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = self . params . eps if epsilon is None else epsilon rho_without_diagonal = jnp . abs ( rho - jnp . diag ( jnp . diag ( rho ))) rho_normalized = rho_without_diagonal / jnp . linalg . norm ( rho_without_diagonal ) te = self . transition_energies excitonic_transitions = ( rho_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * rho_normalized )) / ( jnp . linalg . norm ( rho_normalized ) * jnp . linalg . norm ( excitonic_transitions ) ) @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . _positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field @staticmethod def get_expectation_value ( operator , density_matrix ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->il\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } return jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , density_matrix , ) # TODO: uff, all of the methods below should be rewritten def get_expectation_value_time_domain ( self , * args , ** kwargs ): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs . pop ( \"operator\" , None ) correction = self . stationary_density_matrix time_axis , density_matrices = self . get_density_matrix_time_domain ( * args , ** kwargs ) try : return time_axis , self . electrons * self . get_expectation_value ( correction - density_matrices . ys , operator ) except AttributeError : return time_axis , self . electrons * self . get_expectation_value ( correction - density_matrices , operator ) def get_expectation_value_frequency_domain ( self , * args , ** kwargs ): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" omega_min = kwargs . pop ( \"omega_min\" , 0 ) omega_max = kwargs . pop ( \"omega_max\" , 100 ) time_axis , exp_val_td = self . get_expectation_value_time_domain ( * args , ** kwargs ) omega , exp_val_omega = _numerics . get_fourier_transform ( time_axis , exp_val_td ) mask = ( omega >= omega_min ) & ( omega <= omega_max ) try : electric_field = jax . vmap ( kwargs [ \"illumination\" ])( time_axis ) field_omega = _numerics . get_fourier_transform ( time_axis , electric_field , return_omega_axis = False ) return omega [ mask ], exp_val_omega [ mask ], field_omega [ mask ] except KeyError : return omega [ mask ], exp_val_omega [ mask ] @recomputes def get_density_matrix_time_domain ( self , end_time : float , illumination : Callable [[ float ], jax . Array ], start_time : Optional [ float ] = None , steps_time : Optional [ int ] = None , skip : Optional [ int ] = None , relaxation_rate : Union [ float , jax . Array ] = None , saturation_functional : Callable [[ float ], float ] = lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))), use_old_method : bool = False , include_induced_contribution : bool = False , use_rwa = False , compute_only_at = None , coulomb_strength = 1.0 , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float ( start_time ) if start_time is not None else 0.0 steps_time = int ( steps_time ) if steps_time is not None else int ( end_time * 1000 ) time_axis = jnp . linspace ( start_time , end_time , steps_time ) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None : relaxation_function = lambda r : 0.0 elif isinstance ( relaxation_rate , jax . Array ): relaxation_function = _numerics . lindblad_saturation_functional ( self . _eigenvectors , relaxation_rate , saturation_functional , self . electrons , self . _stationary_density_matrix , ) else : relaxation_function = _numerics . relaxation_time_approximation ( relaxation_rate , self . stationary_density_matrix , ) # Verify that illumination is a callable if not callable ( illumination ): raise TypeError ( \"Provide a function for e-field\" ) # Initialize common variables coulomb_field_to_from = _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_only_at ) # TODO: not very elegant: we just dump every argument in there by default return time_axis [:: skip ], _numerics . integrate_master_equation ( self . _hamiltonian , coulomb_strength * self . _coulomb , self . dipole_operator , self . electrons , self . velocity_operator , self . initial_density_matrix , self . stationary_density_matrix , time_axis , illumination , relaxation_function , coulomb_field_to_from , include_induced_contribution , use_rwa , solver , stepsize_controller , use_old_method , skip , ) # TODO: uff, again verbose def get_polarizability_rpa ( self , omegas , relaxation_rate , polarization , coulomb_strength = 1.0 , hungry = 0 , phi_ext = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics . rpa_polarizability_function ( self , relaxation_rate , polarization , coulomb_strength , phi_ext , hungry ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] ) def get_susceptibility_rpa ( self , omegas , relaxation_rate , coulomb_strength = 1.0 , hungry = 0 ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics . rpa_polarizability_function ( self , relaxation_rate , coulomb_strength , hungry ) return jax . lax . map ( sus , omegas ) dipole_operator property Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: \u2013 jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. quadrupole_operator property Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: \u2013 jax.Array: A tensor representing the quadrupole operator. transition_energies property Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition energy from i to j . velocity_operator property Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: \u2013 jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. wigner_weisskopf_transition_rates property Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition rate from i to j . append ( other ) Appends an orbital to the list, ensuring it is not already present. Parameters: other ( Orbital ) \u2013 The orbital to append. Raises: TypeError \u2013 If other is not an instance of Orbital. ValueError \u2013 If other is already in the list. Source code in src/granad/orbitals.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other ) get_charge ( density_matrix = None ) Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix ( Array , default: None ) \u2013 The density matrix to use for calculating charge. Returns: \u2013 jax.Array: A diagonal array representing charges at each site. Source code in src/granad/orbitals.py 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 @recomputes def get_charge ( density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None : return jnp . diag ( self . initial_density_matrix * self . electrons ) else : return jnp . diag ( density_matrix * self . electrons ) get_density_matrix_time_domain ( end_time , illumination , start_time = None , steps_time = None , skip = None , relaxation_rate = None , saturation_functional = lambda x : 1 / 1 + jnp . exp ( - 1000000.0 * 2.0 - x ), use_old_method = False , include_induced_contribution = False , use_rwa = False , compute_only_at = None , coulomb_strength = 1.0 , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 )) Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time ( float ) \u2013 The end time for the simulation. illumination ( Callable [[ float ], Array ] ) \u2013 A function that returns the electric field at a given time. start_time ( Optional [ float ] , default: None ) \u2013 The start time for the simulation, defaults to zero. steps_time ( Optional [ int ] , default: None ) \u2013 The number of time steps to simulate, defaults to int(end_time * 1000) skip ( Optional [ int ] , default: None ) \u2013 The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate ( Union [ float , Array ] , default: None ) \u2013 The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional ( Callable [[ float ], float ] , default: lambda x: 1 / 1 + exp (-1000000.0 * 2.0 - x ) ) \u2013 A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method ( bool , default: False ) \u2013 Flag to use the old RK method. include_induced_contribution ( bool , default: False ) \u2013 Whether to include induced contributions in the simulation. use_rwa ( bool , default: False ) \u2013 Whether to apply the rotating wave approximation. compute_only_at ( Optional [ any ] , default: None ) \u2013 Specific orbital indices at which the induced field computation is performed. coulomb_strength ( float , default: 1.0 ) \u2013 Strength of Coulomb interactions. solver ( Solver , default: Dopri5 () ) \u2013 The differential equation solver to use. stepsize_controller ( StepSizeController , default: PIDController (rtol=1e-10, atol=1e-10) ) \u2013 The controller for the solver's step size. Returns: \u2013 Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. Source code in src/granad/orbitals.py 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 @recomputes def get_density_matrix_time_domain ( self , end_time : float , illumination : Callable [[ float ], jax . Array ], start_time : Optional [ float ] = None , steps_time : Optional [ int ] = None , skip : Optional [ int ] = None , relaxation_rate : Union [ float , jax . Array ] = None , saturation_functional : Callable [[ float ], float ] = lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))), use_old_method : bool = False , include_induced_contribution : bool = False , use_rwa = False , compute_only_at = None , coulomb_strength = 1.0 , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float ( start_time ) if start_time is not None else 0.0 steps_time = int ( steps_time ) if steps_time is not None else int ( end_time * 1000 ) time_axis = jnp . linspace ( start_time , end_time , steps_time ) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None : relaxation_function = lambda r : 0.0 elif isinstance ( relaxation_rate , jax . Array ): relaxation_function = _numerics . lindblad_saturation_functional ( self . _eigenvectors , relaxation_rate , saturation_functional , self . electrons , self . _stationary_density_matrix , ) else : relaxation_function = _numerics . relaxation_time_approximation ( relaxation_rate , self . stationary_density_matrix , ) # Verify that illumination is a callable if not callable ( illumination ): raise TypeError ( \"Provide a function for e-field\" ) # Initialize common variables coulomb_field_to_from = _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_only_at ) # TODO: not very elegant: we just dump every argument in there by default return time_axis [:: skip ], _numerics . integrate_master_equation ( self . _hamiltonian , coulomb_strength * self . _coulomb , self . dipole_operator , self . electrons , self . velocity_operator , self . initial_density_matrix , self . stationary_density_matrix , time_axis , illumination , relaxation_function , coulomb_field_to_from , include_induced_contribution , use_rwa , solver , stepsize_controller , use_old_method , skip , ) get_dos ( omega , broadening = 0.1 ) Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the DOS. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The integrated density of states at the specified frequency. Source code in src/granad/orbitals.py 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians ) get_epi ( rho , omega , epsilon = None ) Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho ( Array ) \u2013 The density matrix to consider for EPI calculation. omega ( float ) \u2013 The frequency to evaluate the EPI at. epsilon ( float , default: None ) \u2013 The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float ( float ) \u2013 The EPI. Source code in src/granad/orbitals.py 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 @recomputes def get_epi ( self , rho : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = self . params . eps if epsilon is None else epsilon rho_without_diagonal = jnp . abs ( rho - jnp . diag ( jnp . diag ( rho ))) rho_normalized = rho_without_diagonal / jnp . linalg . norm ( rho_without_diagonal ) te = self . transition_energies excitonic_transitions = ( rho_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * rho_normalized )) / ( jnp . linalg . norm ( rho_normalized ) * jnp . linalg . norm ( excitonic_transitions ) ) get_expectation_value ( operator , density_matrix ) staticmethod Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator ( Array ) \u2013 The operator for which the expectation value is calculated. density_matrix ( Array ) \u2013 The density matrix representing the state of the system. Returns: \u2013 jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. Source code in src/granad/orbitals.py 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 @staticmethod def get_expectation_value ( operator , density_matrix ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->il\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } return jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , density_matrix , ) get_expectation_value_frequency_domain ( * args , ** kwargs ) Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: \u2013 Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. Source code in src/granad/orbitals.py 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 def get_expectation_value_frequency_domain ( self , * args , ** kwargs ): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" omega_min = kwargs . pop ( \"omega_min\" , 0 ) omega_max = kwargs . pop ( \"omega_max\" , 100 ) time_axis , exp_val_td = self . get_expectation_value_time_domain ( * args , ** kwargs ) omega , exp_val_omega = _numerics . get_fourier_transform ( time_axis , exp_val_td ) mask = ( omega >= omega_min ) & ( omega <= omega_max ) try : electric_field = jax . vmap ( kwargs [ \"illumination\" ])( time_axis ) field_omega = _numerics . get_fourier_transform ( time_axis , electric_field , return_omega_axis = False ) return omega [ mask ], exp_val_omega [ mask ], field_omega [ mask ] except KeyError : return omega [ mask ], exp_val_omega [ mask ] get_expectation_value_time_domain ( * args , ** kwargs ) Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: \u2013 Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. Source code in src/granad/orbitals.py 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 def get_expectation_value_time_domain ( self , * args , ** kwargs ): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs . pop ( \"operator\" , None ) correction = self . stationary_density_matrix time_axis , density_matrices = self . get_density_matrix_time_domain ( * args , ** kwargs ) try : return time_axis , self . electrons * self . get_expectation_value ( correction - density_matrices . ys , operator ) except AttributeError : return time_axis , self . electrons * self . get_expectation_value ( correction - density_matrices , operator ) get_group_ids () Retrieves a list of group IDs for all orbitals managed by this object. Returns: \u2013 List[int]: A list of group IDs for each orbital. Source code in src/granad/orbitals.py 399 400 401 402 403 404 405 406 def get_group_ids ( self ): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [ orb . group_id for orb in self . _list ] get_induced_field ( positions , density_matrix ) Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions ( Array ) \u2013 The positions at which to evaluate the induced field. density_matrix ( Array ) \u2013 The density matrix used to calculate the induced field. Returns: \u2013 jax.Array: The resulting electric field vector at each position. Source code in src/granad/orbitals.py 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . _positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field get_ldos ( omega , site_index , broadening = 0.1 ) Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the LDOS. site_index ( int ) \u2013 The site index to evaluate the LDOS at. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The local density of states at the specified site and frequency. Source code in src/granad/orbitals.py 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians ) get_polarizability_rpa ( omegas , relaxation_rate , polarization , coulomb_strength = 1.0 , hungry = 0 , phi_ext = None ) Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas ( Array ) \u2013 Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate ( float ) \u2013 The relaxation time parameter. polarization ( Array ) \u2013 Polarization directions or modes. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interaction in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext ( Optional [ Array ] , default: None ) \u2013 External potential influences, if any. Returns: \u2013 jax.Array: The calculated polarizabilities at the specified frequencies. Source code in src/granad/orbitals.py 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 def get_polarizability_rpa ( self , omegas , relaxation_rate , polarization , coulomb_strength = 1.0 , hungry = 0 , phi_ext = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics . rpa_polarizability_function ( self , relaxation_rate , polarization , coulomb_strength , phi_ext , hungry ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] ) get_susceptibility_rpa ( omegas , relaxation_rate , coulomb_strength = 1.0 , hungry = 0 ) Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas ( Array ) \u2013 The frequencies at which to compute susceptibility. relaxation_rate ( float ) \u2013 The relaxation time affecting susceptibility calculations. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interactions considered in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: \u2013 jax.Array: The susceptibility values at the given frequencies. Source code in src/granad/orbitals.py 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 def get_susceptibility_rpa ( self , omegas , relaxation_rate , coulomb_strength = 1.0 , hungry = 0 ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics . rpa_polarizability_function ( self , relaxation_rate , coulomb_strength , hungry ) return jax . lax . map ( sus , omegas ) get_unique_group_ids () Retrieves a unique set of group IDs from all orbitals. Returns: \u2013 List[int]: A list of unique group IDs. Source code in src/granad/orbitals.py 408 409 410 411 412 413 414 415 def get_unique_group_ids ( self ): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list ( set ( self . get_group_ids ())) make_self_consistent ( sc_params ) Configures the list for self-consistent field calculations. Parameters: sc_params ( dict ) \u2013 Parameters for self-consistency. Source code in src/granad/orbitals.py 518 519 520 521 522 523 524 525 526 @mutates def make_self_consistent ( self , sc_params ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self . self_consistency_params = sc_params set_coulomb_element ( orb_or_index1 , orb_or_index2 , val ) Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Coulomb interaction element. Source code in src/granad/orbitals.py 467 468 469 470 471 472 473 474 475 476 477 def set_coulomb_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _coulomb_dict ) set_dipole_transition ( orb_or_index1 , orb_or_index2 , arr ) Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first part of the transition. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second part of the transition. arr ( Array ) \u2013 The 3-element array containing dipole transition elements. Source code in src/granad/orbitals.py 559 560 561 562 563 564 565 566 567 568 569 570 571 572 @mutates def set_dipole_transition ( self , orb_or_index1 , orb_or_index2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _transitions [( orb_or_index1 , orb_or_index2 )] = jnp . array ( arr ) . astype ( complex ) set_excitation ( from_state , to_state , excited_electrons ) Sets up an excitation process from one state to another with specified electrons. Parameters: from_state ( int, list, or jax.Array ) \u2013 The initial state index or indices. to_state ( int, list, or jax.Array ) \u2013 The final state index or indices. excited_electrons ( int, list, or jax.Array ) \u2013 The indices of electrons to be excited. Notes The states and electron indices may be specified as scalars, lists, or arrays. Source code in src/granad/orbitals.py 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): maybe_int = jnp . array ( maybe_int ) if isinstance ( maybe_int , jax . Array ): return ( jnp . array ( maybe_int ) if maybe_int . ndim > 1 else jnp . array ([ maybe_int ]) ) raise TypeError self . simulation_params . from_state = maybe_int_to_arr ( from_state ) self . simulation_params . to_state = maybe_int_to_arr ( to_state ) self . simulation_params . excited_electrons = maybe_int_to_arr ( excited_electrons ) set_groups_coulomb ( orb_or_group_id1 , orb_or_group_id2 , func ) Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the Coulomb interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 def set_groups_coulomb ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _coulomb_dict ) set_groups_hopping ( orb_or_group_id1 , orb_or_group_id2 , func ) Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the hopping interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def set_groups_hopping ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _hopping_dict ) set_hamiltonian_element ( orb_or_index1 , orb_or_index2 , val ) Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Hamiltonian element. Source code in src/granad/orbitals.py 455 456 457 458 459 460 461 462 463 464 465 def set_hamiltonian_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _hopping_dict ) shift_by_vector ( tag , translation_vector ) Shifts all orbitals with a specific tag by a given vector. Parameters: tag ( str ) \u2013 The tag to match orbitals. translation_vector ( Array ) \u2013 The vector by which to translate the orbital positions. Notes This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 @mutates def shift_by_vector ( self , tag , translation_vector ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag (str): The tag to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [ orb for orb in self . _list if orb . tag == tag ] for orb in orbs : orb . position += translation_vector transform_to_energy_basis ( observable ) Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the energy basis. Source code in src/granad/orbitals.py 757 758 759 760 761 762 763 764 765 766 767 768 def transform_to_energy_basis ( self , observable ): # \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T ) transform_to_site_basis ( observable ) Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the site basis. Source code in src/granad/orbitals.py 745 746 747 748 749 750 751 752 753 754 755 def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors )","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#granad.orbitals.Orbital","text":"Represents the quantum state of an electron in an atom with specific properties. Attributes: position ( Array ) \u2013 The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index ( Optional [ int ] ) \u2013 An optional index representing the layer of the orbital within its atom, may be None if not specified. tag ( Optional [ str ] ) \u2013 An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level ( Optional [ int ] ) \u2013 The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum ( Optional [ int ] ) \u2013 The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z ( Optional [ int ] ) \u2013 The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin ( Optional [ int ] ) \u2013 The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name ( Optional [ str ] ) \u2013 The name of the atom this orbital belongs to, can be None if not applicable. group_id ( int ) \u2013 A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. Source code in src/granad/orbitals.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @dataclass class Orbital : \"\"\" Represents the quantum state of an electron in an atom with specific properties. Attributes: position (jax.Array): The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom, may be None if not specified. tag (Optional[str]): An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable. group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. \"\"\" position : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 , 0 , 0 ]), hash = False , compare = False ) layer_index : Optional [ int ] = None tag : Optional [ str ] = None energy_level : Optional [ int ] = None angular_momentum : Optional [ int ] = None angular_momentum_z : Optional [ int ] = None spin : Optional [ int ] = None atom_name : Optional [ str ] = None group_id : int = field ( default_factory = _watchdog . _Watchdog . next_value ) def __post_init__ ( self ): object . __setattr__ ( self , \"position\" , jnp . array ( self . position ) . astype ( float )) def __hash__ ( self ): # Include only immutable fields in hash calculation return hash ( ( self . layer_index , self . tag , self . energy_level , self . angular_momentum , self . angular_momentum_z , self . angular_momentum , self . spin , self . atom_name , self . group_id , ) ) def __str__ ( self ): return pformat ( vars ( self ), sort_dicts = False ) # TODO: bla bla bla ... this should be shorter but im too tired def __eq__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id == other . group_id and self . layer_index == other . layer_index def __lt__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id < self . group_id def __le__ ( self , other ): return self < other or self == other def __gt__ ( self , other ): return not self <= other def __ge__ ( self , other ): return not self < other def __ne__ ( self , other ): return not self == other","title":"Orbital"},{"location":"api/#granad.orbitals.OrbitalList","text":"A list of orbitals. Source code in src/granad/orbitals.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 @plotting_methods class OrbitalList : \"\"\"A list of orbitals.\"\"\" def __init__ ( self , orbs , _hopping_dict = None , _coulomb_dict = None ): # couplings are dicts mapping orbital pairs to couplings self . _hopping_dict = ( _hopping_dict if _hopping_dict is not None else _SortedTupleDict () ) self . _coulomb_dict = ( _coulomb_dict if _coulomb_dict is not None else _SortedTupleDict () ) self . _transitions = _SortedTupleDict () # contains all high-level simulation information self . _list = list ( orbs ) if orbs is not None else [] # flag for recomputing state self . _recompute = True self . simulation_params = SimulationParams () def __getattr__ ( self , property_name ): if property_name . endswith ( \"_x\" ): return getattr ( self , property_name [: - 2 ]) elif property_name . endswith ( \"_e\" ): return self . transform_to_energy_basis ( getattr ( self , property_name [: - 2 ]) ) def __len__ ( self ): return len ( self . _list ) # can't mutate, because orbitals are immutable def __getitem__ ( self , position ): return self . _list [ position ] def __repr__ ( self ): return repr ( self . _list ) # TODO: hmmm def __str__ ( self ): info = f \"List with { len ( self ) } orbitals, { self . electrons } electrons.\" excited = f \" { self . excited_electrons } electrons excited from { self . from_state } to { self . to_state } .\" groups = \" \\n \" . join ( [ f \"group id { key } : { val } orbitals\" for key , val in Counter ( self . get_group_ids ()) . items () ] ) return \" \\n \" . join (( info , excited , groups )) def __iter__ ( self ): return iter ( self . _list ) # TODO: uff, addition, or, in general, mutation should wipe all attributes except for coupling def __add__ ( self , other ): if not self . _are_orbs ( other ): raise TypeError if any ( orb in other for orb in self . _list ): raise ValueError if isinstance ( other , OrbitalList ): new_hopping_dict = self . _hopping_dict . copy () new_hopping_dict . update ( other . _hopping_dict ) new_coulomb_dict = self . _coulomb_dict . copy () new_coulomb_dict . update ( other . _coulomb_dict ) return OrbitalList ( ( self . _list + list ( other )) . copy (), _SortedTupleDict ( new_hopping_dict ), _SortedTupleDict ( new_coulomb_dict ), ) @mutates def __setitem__ ( self , position , value ): if isinstance ( value , Orbital ): self . _list [ position ] = value raise TypeError def _delete_coupling ( self , orb , coupling ): keys_to_remove = [ key for key in coupling if orb in key ] for key in keys_to_remove : del coupling [ key ] @mutates def __delitem__ ( self , position ): orb = self . _list [ position ] self . _delete_coupling ( orb , self . _hopping_dict ) self . _delete_coupling ( orb , self . _coulomb_dict ) del self . _list [ position ] @staticmethod def _are_orbs ( candidate ): return all ( isinstance ( orb , Orbital ) for orb in candidate ) @mutates def _set_coupling ( self , orb_or_group_id1 , orb_or_group_id2 , val_or_func , coupling ): coupling [( orb_or_group_id1 , orb_or_group_id2 )] = val_or_func # TODO: we may want to differentiate through this, also this is private so better not wrap return val into container def _hamiltonian_coulomb ( self ): def fill_matrix ( matrix , coupling_dict ): # TODO: there should be an internal dummy = jnp . arange ( len ( self )) triangle_mask = dummy [:, None ] >= dummy # TODO: in principle we can build a big tensor NxNxgroups, vmap over the last axis and sum the groups # first, we loop over all group_id couplings => interactions between groups for key , function in coupling_dict . group_id_items (): # TODO: big uff: we rely on the correct ordering of the group_ids for cols and rows, first key is always smaller than last keys => we get upper triangular valid indices # if it were the other way around, these would be zeroed by the triangle mask cols = group_ids == key [ 0 ] rows = ( group_ids == key [ 1 ])[:, None ] combination_indices = jnp . logical_and ( rows , cols ) valid_indices = jnp . logical_and ( triangle_mask , combination_indices ) function = jax . vmap ( function ) matrix = matrix . at [ valid_indices ] . set ( function ( distances [ valid_indices ]) ) # we now set single elements rows , cols , vals = [], [], [] for key , val in coupling_dict . orbital_items (): rows . append ( self . _list . index ( key [ 0 ])) cols . append ( self . _list . index ( key [ 1 ])) vals . append ( val ) matrix = matrix . at [ rows , cols ] . set ( vals ) return matrix + matrix . conj () . T - jnp . diag ( jnp . diag ( matrix )) # TODO: oh noes rounding again, but don't know what to do else positions = self . _get_positions () distances = jnp . round ( jnp . linalg . norm ( positions - positions [:, None ], axis =- 1 ), 6 ) group_ids = jnp . array ( self . get_group_ids ()) hamiltonian = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . _hopping_dict ) coulomb = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . _coulomb_dict ) return hamiltonian , coulomb def _get_positions ( self ): return jnp . array ([ orb . position for orb in self . _list ]) def _ensure_complex ( self , func_or_val ): if callable ( func_or_val ): return lambda x : func_or_val ( x ) + 0.0 j if isinstance ( func_or_val , ( int , float , complex )): return func_or_val + 0.0 j raise TypeError # TODO: bla bla bla ... incredibly verbose, but couldn't think of anything better yet def _maybe_orbs_to_group_ids ( self , maybe_orbs ): def convert ( maybe_orb ): # TODO: check if this is really a group_id if isinstance ( maybe_orb , int ): return maybe_orb if isinstance ( maybe_orb , Orbital ): return maybe_orb . group_id return \"You have passed something that is neither an orbital nor a group_id\" return [ convert ( x ) for x in maybe_orbs ] def _maybe_indices_to_orbs ( self , maybe_indices ): def convert ( maybe_index ): if isinstance ( maybe_index , int ): return self . _list [ maybe_index ] if isinstance ( maybe_index , Orbital ): return maybe_index return \"You have passed something that is neither an orbital nor an index\" return [ convert ( x ) for x in maybe_indices ] def _build ( self ): # TODO: uff assert len ( self ) > 0 self . _positions = self . _get_positions () self . _hamiltonian , self . _coulomb = self . _hamiltonian_coulomb () self . _eigenvectors , self . _energies = jax . lax . linalg . eigh ( self . _hamiltonian ) self . _initial_density_matrix = _numerics . _density_matrix ( self . _energies , self . electrons , self . spin_degeneracy , self . eps , self . from_state , self . to_state , self . excited_electrons , self . beta , ) self . _stationary_density_matrix = _numerics . _density_matrix ( self . _energies , self . electrons , self . spin_degeneracy , self . eps , jnp . array ([ 0 ]), jnp . array ([ 0 ]), jnp . array ([ 0 ]), self . beta , ) # TODO: uff if self . self_consistency_params : ( self . _hamiltonian , self . _initial_density_matrix , self . _stationary_density_matrix , self . _energies , self . _eigenvectors , ) = _get_self_consistent ( self . _hamiltonian , self . _coulomb , self . _positions , self . spin_degeneracy , self . electrons , self . eps , self . _eigenvectors , self . _static_density_matrix , ** self . self_consistent_params , ) self . _initial_density_matrix = self . transform_to_site_basis ( self . _initial_density_matrix ) self . _stationary_density_matrix = self . transform_to_site_basis ( self . _stationary_density_matrix ) def get_group_ids ( self ): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [ orb . group_id for orb in self . _list ] def get_unique_group_ids ( self ): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list ( set ( self . get_group_ids ())) def set_groups_hopping ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _hopping_dict ) def set_groups_coulomb ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _coulomb_dict ) def set_hamiltonian_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _hopping_dict ) def set_coulomb_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _coulomb_dict ) def index ( self , orb ): return self . _list . index ( orb ) @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other ) # TODO: remove this once better position handling is done @mutates def shift_by_vector ( self , tag , translation_vector ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag (str): The tag to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [ orb for orb in self . _list if orb . tag == tag ] for orb in orbs : orb . position += translation_vector # TODO: validate @mutates def make_self_consistent ( self , sc_params ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self . self_consistency_params = sc_params # TODO: uff @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): maybe_int = jnp . array ( maybe_int ) if isinstance ( maybe_int , jax . Array ): return ( jnp . array ( maybe_int ) if maybe_int . ndim > 1 else jnp . array ([ maybe_int ]) ) raise TypeError self . simulation_params . from_state = maybe_int_to_arr ( from_state ) self . simulation_params . to_state = maybe_int_to_arr ( to_state ) self . simulation_params . excited_electrons = maybe_int_to_arr ( excited_electrons ) @mutates def set_dipole_transition ( self , orb_or_index1 , orb_or_index2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _transitions [( orb_or_index1 , orb_or_index2 )] = jnp . array ( arr ) . astype ( complex ) # TODO: bla bla bla @property @recomputes def homo ( self ): # TODO: hmmm return ( self . electrons * self . stationary_density_matrix_e ) . real . diagonal () . round ( 2 ) . nonzero ()[ 0 ] . item () @property def electrons ( self ): if self . simulation_params . electrons is None : return len ( self . _list ) return self . simulation_params . electrons @property def spin_degeneracy ( self ): return self . simulation_params . spin_degeneracy @property def from_state ( self ): return self . simulation_params . from_state @property def to_state ( self ): return self . simulation_params . to_state @property def excited_electrons ( self ): return self . simulation_params . excited_electrons @property def beta ( self ): return self . simulation_params . beta @property def eps ( self ): return self . simulation_params . eps @property @recomputes def positions ( self ): return self . _positions @property @recomputes def eigenvectors ( self ): return self . _eigenvectors @property @recomputes def energies ( self ): return self . _energies # TODO: uff decorator inception, also should return copies to avoid weirdness @property @recomputes def hamiltonian ( self ): return self . _hamiltonian @property @recomputes def coulomb ( self ): return self . _coulomb @property @recomputes def initial_density_matrix ( self ): return self . _initial_density_matrix @property @recomputes def stationary_density_matrix ( self ): return self . _stationary_density_matrix @property @recomputes def quadrupole_operator ( self ): \"\"\" Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: jax.Array: A tensor representing the quadrupole operator. \"\"\" dip = self . dipole_operator term = jnp . einsum ( \"ijk,jlm->ilkm\" , dip , dip ) diag = jnp . einsum ( \"ijk,jlk->il\" , dip , dip ) diag = jnp . einsum ( \"ij,kl->ijkl\" , diag , jnp . eye ( term . shape [ - 1 ])) return 3 * term - diag @property @recomputes def dipole_operator ( self ): \"\"\" Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. \"\"\" N = self . positions . shape [ 0 ] dipole_operator = jnp . zeros (( 3 , N , N )) . astype ( complex ) for i in range ( 3 ): dipole_operator = dipole_operator . at [ i , :, :] . set ( jnp . diag ( self . _positions [:, i ] / 2 ) ) for orbital_combination , value in self . _transitions . items (): i , j = self . _list . index ( orbital_combination [ 0 ]), self . _list . index ( orbital_combination [ 1 ] ) k = value . nonzero ()[ 0 ] dipole_operator = dipole_operator . at [ k , i , j ] . set ( value [ k ]) return dipole_operator + jnp . transpose ( dipole_operator , ( 0 , 2 , 1 )) . conj () @property @recomputes def velocity_operator ( self ): \"\"\" Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. \"\"\" if self . _transitions is None : x_times_h = jnp . einsum ( \"ij,iL->ijL\" , self . _hamiltonian , self . _positions ) h_times = jnp . einsum ( \"ij,jL->ijL\" , self . _hamiltonian , self . _positions ) else : positions = self . dipole_operator x_times_h = jnp . einsum ( \"kj,Lik->Lij\" , self . _hamiltonian , positions ) h_times = jnp . einsum ( \"ik,Lkj->Lij\" , self . _hamiltonian , positions ) return - 1 j * ( x_times_h - h_times ) @property @recomputes def transition_energies ( self ): \"\"\" Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: jax.Array: The element `arr[i,j]` contains the transition energy from `i` to `j`. \"\"\" return self . _energies [:, None ] - self . _energies @property @recomputes def wigner_weisskopf_transition_rates ( self ): \"\"\" Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: jax.Array: The element `arr[i,j]` contains the transition rate from `i` to `j`. \"\"\" charge = 1.602e-19 eps_0 = 8.85 * 1e-12 hbar = 1.0545718 * 1e-34 c = 3e8 # 137 (a.u.) factor = 1.6e-29 * charge / ( 3 * jnp . pi * eps_0 * hbar ** 2 * c ** 3 ) te = self . transition_energies transition_dipole_moments = self . dipole_operator_e return ( ( te * ( te > self . eps )) ** 3 * jnp . squeeze ( transition_dipole_moments ** 2 ) * factor ) @staticmethod def _transform_basis ( observable , vectors ): dims_einsum_strings = { 2 : \"ij,jk,lk->il\" , 3 : \"ij,mjk,lk->mil\" } einsum_string = dims_einsum_strings [( observable . ndim )] return jnp . einsum ( einsum_string , vectors , observable , vectors . conj ()) def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors ) def transform_to_energy_basis ( self , observable ): # \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T ) @recomputes def get_charge ( density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None : return jnp . diag ( self . initial_density_matrix * self . electrons ) else : return jnp . diag ( density_matrix * self . electrons ) @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians ) # TODO: make compatbile with orbital @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians ) @recomputes def get_epi ( self , rho : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = self . params . eps if epsilon is None else epsilon rho_without_diagonal = jnp . abs ( rho - jnp . diag ( jnp . diag ( rho ))) rho_normalized = rho_without_diagonal / jnp . linalg . norm ( rho_without_diagonal ) te = self . transition_energies excitonic_transitions = ( rho_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * rho_normalized )) / ( jnp . linalg . norm ( rho_normalized ) * jnp . linalg . norm ( excitonic_transitions ) ) @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . _positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field @staticmethod def get_expectation_value ( operator , density_matrix ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->il\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } return jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , density_matrix , ) # TODO: uff, all of the methods below should be rewritten def get_expectation_value_time_domain ( self , * args , ** kwargs ): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs . pop ( \"operator\" , None ) correction = self . stationary_density_matrix time_axis , density_matrices = self . get_density_matrix_time_domain ( * args , ** kwargs ) try : return time_axis , self . electrons * self . get_expectation_value ( correction - density_matrices . ys , operator ) except AttributeError : return time_axis , self . electrons * self . get_expectation_value ( correction - density_matrices , operator ) def get_expectation_value_frequency_domain ( self , * args , ** kwargs ): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" omega_min = kwargs . pop ( \"omega_min\" , 0 ) omega_max = kwargs . pop ( \"omega_max\" , 100 ) time_axis , exp_val_td = self . get_expectation_value_time_domain ( * args , ** kwargs ) omega , exp_val_omega = _numerics . get_fourier_transform ( time_axis , exp_val_td ) mask = ( omega >= omega_min ) & ( omega <= omega_max ) try : electric_field = jax . vmap ( kwargs [ \"illumination\" ])( time_axis ) field_omega = _numerics . get_fourier_transform ( time_axis , electric_field , return_omega_axis = False ) return omega [ mask ], exp_val_omega [ mask ], field_omega [ mask ] except KeyError : return omega [ mask ], exp_val_omega [ mask ] @recomputes def get_density_matrix_time_domain ( self , end_time : float , illumination : Callable [[ float ], jax . Array ], start_time : Optional [ float ] = None , steps_time : Optional [ int ] = None , skip : Optional [ int ] = None , relaxation_rate : Union [ float , jax . Array ] = None , saturation_functional : Callable [[ float ], float ] = lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))), use_old_method : bool = False , include_induced_contribution : bool = False , use_rwa = False , compute_only_at = None , coulomb_strength = 1.0 , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float ( start_time ) if start_time is not None else 0.0 steps_time = int ( steps_time ) if steps_time is not None else int ( end_time * 1000 ) time_axis = jnp . linspace ( start_time , end_time , steps_time ) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None : relaxation_function = lambda r : 0.0 elif isinstance ( relaxation_rate , jax . Array ): relaxation_function = _numerics . lindblad_saturation_functional ( self . _eigenvectors , relaxation_rate , saturation_functional , self . electrons , self . _stationary_density_matrix , ) else : relaxation_function = _numerics . relaxation_time_approximation ( relaxation_rate , self . stationary_density_matrix , ) # Verify that illumination is a callable if not callable ( illumination ): raise TypeError ( \"Provide a function for e-field\" ) # Initialize common variables coulomb_field_to_from = _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_only_at ) # TODO: not very elegant: we just dump every argument in there by default return time_axis [:: skip ], _numerics . integrate_master_equation ( self . _hamiltonian , coulomb_strength * self . _coulomb , self . dipole_operator , self . electrons , self . velocity_operator , self . initial_density_matrix , self . stationary_density_matrix , time_axis , illumination , relaxation_function , coulomb_field_to_from , include_induced_contribution , use_rwa , solver , stepsize_controller , use_old_method , skip , ) # TODO: uff, again verbose def get_polarizability_rpa ( self , omegas , relaxation_rate , polarization , coulomb_strength = 1.0 , hungry = 0 , phi_ext = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics . rpa_polarizability_function ( self , relaxation_rate , polarization , coulomb_strength , phi_ext , hungry ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] ) def get_susceptibility_rpa ( self , omegas , relaxation_rate , coulomb_strength = 1.0 , hungry = 0 ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics . rpa_polarizability_function ( self , relaxation_rate , coulomb_strength , hungry ) return jax . lax . map ( sus , omegas )","title":"OrbitalList"},{"location":"api/#granad.orbitals.OrbitalList.dipole_operator","text":"Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: \u2013 jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated.","title":"dipole_operator"},{"location":"api/#granad.orbitals.OrbitalList.quadrupole_operator","text":"Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: \u2013 jax.Array: A tensor representing the quadrupole operator.","title":"quadrupole_operator"},{"location":"api/#granad.orbitals.OrbitalList.transition_energies","text":"Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition energy from i to j .","title":"transition_energies"},{"location":"api/#granad.orbitals.OrbitalList.velocity_operator","text":"Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: \u2013 jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian.","title":"velocity_operator"},{"location":"api/#granad.orbitals.OrbitalList.wigner_weisskopf_transition_rates","text":"Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition rate from i to j .","title":"wigner_weisskopf_transition_rates"},{"location":"api/#granad.orbitals.OrbitalList.append","text":"Appends an orbital to the list, ensuring it is not already present. Parameters: other ( Orbital ) \u2013 The orbital to append. Raises: TypeError \u2013 If other is not an instance of Orbital. ValueError \u2013 If other is already in the list. Source code in src/granad/orbitals.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other )","title":"append"},{"location":"api/#granad.orbitals.OrbitalList.get_charge","text":"Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix ( Array , default: None ) \u2013 The density matrix to use for calculating charge. Returns: \u2013 jax.Array: A diagonal array representing charges at each site. Source code in src/granad/orbitals.py 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 @recomputes def get_charge ( density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None : return jnp . diag ( self . initial_density_matrix * self . electrons ) else : return jnp . diag ( density_matrix * self . electrons )","title":"get_charge"},{"location":"api/#granad.orbitals.OrbitalList.get_density_matrix_time_domain","text":"Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time ( float ) \u2013 The end time for the simulation. illumination ( Callable [[ float ], Array ] ) \u2013 A function that returns the electric field at a given time. start_time ( Optional [ float ] , default: None ) \u2013 The start time for the simulation, defaults to zero. steps_time ( Optional [ int ] , default: None ) \u2013 The number of time steps to simulate, defaults to int(end_time * 1000) skip ( Optional [ int ] , default: None ) \u2013 The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate ( Union [ float , Array ] , default: None ) \u2013 The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional ( Callable [[ float ], float ] , default: lambda x: 1 / 1 + exp (-1000000.0 * 2.0 - x ) ) \u2013 A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method ( bool , default: False ) \u2013 Flag to use the old RK method. include_induced_contribution ( bool , default: False ) \u2013 Whether to include induced contributions in the simulation. use_rwa ( bool , default: False ) \u2013 Whether to apply the rotating wave approximation. compute_only_at ( Optional [ any ] , default: None ) \u2013 Specific orbital indices at which the induced field computation is performed. coulomb_strength ( float , default: 1.0 ) \u2013 Strength of Coulomb interactions. solver ( Solver , default: Dopri5 () ) \u2013 The differential equation solver to use. stepsize_controller ( StepSizeController , default: PIDController (rtol=1e-10, atol=1e-10) ) \u2013 The controller for the solver's step size. Returns: \u2013 Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. Source code in src/granad/orbitals.py 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 @recomputes def get_density_matrix_time_domain ( self , end_time : float , illumination : Callable [[ float ], jax . Array ], start_time : Optional [ float ] = None , steps_time : Optional [ int ] = None , skip : Optional [ int ] = None , relaxation_rate : Union [ float , jax . Array ] = None , saturation_functional : Callable [[ float ], float ] = lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))), use_old_method : bool = False , include_induced_contribution : bool = False , use_rwa = False , compute_only_at = None , coulomb_strength = 1.0 , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float ( start_time ) if start_time is not None else 0.0 steps_time = int ( steps_time ) if steps_time is not None else int ( end_time * 1000 ) time_axis = jnp . linspace ( start_time , end_time , steps_time ) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None : relaxation_function = lambda r : 0.0 elif isinstance ( relaxation_rate , jax . Array ): relaxation_function = _numerics . lindblad_saturation_functional ( self . _eigenvectors , relaxation_rate , saturation_functional , self . electrons , self . _stationary_density_matrix , ) else : relaxation_function = _numerics . relaxation_time_approximation ( relaxation_rate , self . stationary_density_matrix , ) # Verify that illumination is a callable if not callable ( illumination ): raise TypeError ( \"Provide a function for e-field\" ) # Initialize common variables coulomb_field_to_from = _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_only_at ) # TODO: not very elegant: we just dump every argument in there by default return time_axis [:: skip ], _numerics . integrate_master_equation ( self . _hamiltonian , coulomb_strength * self . _coulomb , self . dipole_operator , self . electrons , self . velocity_operator , self . initial_density_matrix , self . stationary_density_matrix , time_axis , illumination , relaxation_function , coulomb_field_to_from , include_induced_contribution , use_rwa , solver , stepsize_controller , use_old_method , skip , )","title":"get_density_matrix_time_domain"},{"location":"api/#granad.orbitals.OrbitalList.get_dos","text":"Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the DOS. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The integrated density of states at the specified frequency. Source code in src/granad/orbitals.py 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians )","title":"get_dos"},{"location":"api/#granad.orbitals.OrbitalList.get_epi","text":"Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho ( Array ) \u2013 The density matrix to consider for EPI calculation. omega ( float ) \u2013 The frequency to evaluate the EPI at. epsilon ( float , default: None ) \u2013 The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float ( float ) \u2013 The EPI. Source code in src/granad/orbitals.py 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 @recomputes def get_epi ( self , rho : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = self . params . eps if epsilon is None else epsilon rho_without_diagonal = jnp . abs ( rho - jnp . diag ( jnp . diag ( rho ))) rho_normalized = rho_without_diagonal / jnp . linalg . norm ( rho_without_diagonal ) te = self . transition_energies excitonic_transitions = ( rho_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * rho_normalized )) / ( jnp . linalg . norm ( rho_normalized ) * jnp . linalg . norm ( excitonic_transitions ) )","title":"get_epi"},{"location":"api/#granad.orbitals.OrbitalList.get_expectation_value","text":"Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator ( Array ) \u2013 The operator for which the expectation value is calculated. density_matrix ( Array ) \u2013 The density matrix representing the state of the system. Returns: \u2013 jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. Source code in src/granad/orbitals.py 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 @staticmethod def get_expectation_value ( operator , density_matrix ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->il\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } return jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , density_matrix , )","title":"get_expectation_value"},{"location":"api/#granad.orbitals.OrbitalList.get_expectation_value_frequency_domain","text":"Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: \u2013 Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. Source code in src/granad/orbitals.py 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 def get_expectation_value_frequency_domain ( self , * args , ** kwargs ): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" omega_min = kwargs . pop ( \"omega_min\" , 0 ) omega_max = kwargs . pop ( \"omega_max\" , 100 ) time_axis , exp_val_td = self . get_expectation_value_time_domain ( * args , ** kwargs ) omega , exp_val_omega = _numerics . get_fourier_transform ( time_axis , exp_val_td ) mask = ( omega >= omega_min ) & ( omega <= omega_max ) try : electric_field = jax . vmap ( kwargs [ \"illumination\" ])( time_axis ) field_omega = _numerics . get_fourier_transform ( time_axis , electric_field , return_omega_axis = False ) return omega [ mask ], exp_val_omega [ mask ], field_omega [ mask ] except KeyError : return omega [ mask ], exp_val_omega [ mask ]","title":"get_expectation_value_frequency_domain"},{"location":"api/#granad.orbitals.OrbitalList.get_expectation_value_time_domain","text":"Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: \u2013 Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. Source code in src/granad/orbitals.py 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 def get_expectation_value_time_domain ( self , * args , ** kwargs ): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs . pop ( \"operator\" , None ) correction = self . stationary_density_matrix time_axis , density_matrices = self . get_density_matrix_time_domain ( * args , ** kwargs ) try : return time_axis , self . electrons * self . get_expectation_value ( correction - density_matrices . ys , operator ) except AttributeError : return time_axis , self . electrons * self . get_expectation_value ( correction - density_matrices , operator )","title":"get_expectation_value_time_domain"},{"location":"api/#granad.orbitals.OrbitalList.get_group_ids","text":"Retrieves a list of group IDs for all orbitals managed by this object. Returns: \u2013 List[int]: A list of group IDs for each orbital. Source code in src/granad/orbitals.py 399 400 401 402 403 404 405 406 def get_group_ids ( self ): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [ orb . group_id for orb in self . _list ]","title":"get_group_ids"},{"location":"api/#granad.orbitals.OrbitalList.get_induced_field","text":"Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions ( Array ) \u2013 The positions at which to evaluate the induced field. density_matrix ( Array ) \u2013 The density matrix used to calculate the induced field. Returns: \u2013 jax.Array: The resulting electric field vector at each position. Source code in src/granad/orbitals.py 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . _positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field","title":"get_induced_field"},{"location":"api/#granad.orbitals.OrbitalList.get_ldos","text":"Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the LDOS. site_index ( int ) \u2013 The site index to evaluate the LDOS at. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The local density of states at the specified site and frequency. Source code in src/granad/orbitals.py 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians )","title":"get_ldos"},{"location":"api/#granad.orbitals.OrbitalList.get_polarizability_rpa","text":"Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas ( Array ) \u2013 Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate ( float ) \u2013 The relaxation time parameter. polarization ( Array ) \u2013 Polarization directions or modes. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interaction in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext ( Optional [ Array ] , default: None ) \u2013 External potential influences, if any. Returns: \u2013 jax.Array: The calculated polarizabilities at the specified frequencies. Source code in src/granad/orbitals.py 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 def get_polarizability_rpa ( self , omegas , relaxation_rate , polarization , coulomb_strength = 1.0 , hungry = 0 , phi_ext = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics . rpa_polarizability_function ( self , relaxation_rate , polarization , coulomb_strength , phi_ext , hungry ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] )","title":"get_polarizability_rpa"},{"location":"api/#granad.orbitals.OrbitalList.get_susceptibility_rpa","text":"Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas ( Array ) \u2013 The frequencies at which to compute susceptibility. relaxation_rate ( float ) \u2013 The relaxation time affecting susceptibility calculations. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interactions considered in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: \u2013 jax.Array: The susceptibility values at the given frequencies. Source code in src/granad/orbitals.py 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 def get_susceptibility_rpa ( self , omegas , relaxation_rate , coulomb_strength = 1.0 , hungry = 0 ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics . rpa_polarizability_function ( self , relaxation_rate , coulomb_strength , hungry ) return jax . lax . map ( sus , omegas )","title":"get_susceptibility_rpa"},{"location":"api/#granad.orbitals.OrbitalList.get_unique_group_ids","text":"Retrieves a unique set of group IDs from all orbitals. Returns: \u2013 List[int]: A list of unique group IDs. Source code in src/granad/orbitals.py 408 409 410 411 412 413 414 415 def get_unique_group_ids ( self ): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list ( set ( self . get_group_ids ()))","title":"get_unique_group_ids"},{"location":"api/#granad.orbitals.OrbitalList.make_self_consistent","text":"Configures the list for self-consistent field calculations. Parameters: sc_params ( dict ) \u2013 Parameters for self-consistency. Source code in src/granad/orbitals.py 518 519 520 521 522 523 524 525 526 @mutates def make_self_consistent ( self , sc_params ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self . self_consistency_params = sc_params","title":"make_self_consistent"},{"location":"api/#granad.orbitals.OrbitalList.set_coulomb_element","text":"Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Coulomb interaction element. Source code in src/granad/orbitals.py 467 468 469 470 471 472 473 474 475 476 477 def set_coulomb_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _coulomb_dict )","title":"set_coulomb_element"},{"location":"api/#granad.orbitals.OrbitalList.set_dipole_transition","text":"Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first part of the transition. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second part of the transition. arr ( Array ) \u2013 The 3-element array containing dipole transition elements. Source code in src/granad/orbitals.py 559 560 561 562 563 564 565 566 567 568 569 570 571 572 @mutates def set_dipole_transition ( self , orb_or_index1 , orb_or_index2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _transitions [( orb_or_index1 , orb_or_index2 )] = jnp . array ( arr ) . astype ( complex )","title":"set_dipole_transition"},{"location":"api/#granad.orbitals.OrbitalList.set_excitation","text":"Sets up an excitation process from one state to another with specified electrons. Parameters: from_state ( int, list, or jax.Array ) \u2013 The initial state index or indices. to_state ( int, list, or jax.Array ) \u2013 The final state index or indices. excited_electrons ( int, list, or jax.Array ) \u2013 The indices of electrons to be excited. Notes The states and electron indices may be specified as scalars, lists, or arrays. Source code in src/granad/orbitals.py 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): maybe_int = jnp . array ( maybe_int ) if isinstance ( maybe_int , jax . Array ): return ( jnp . array ( maybe_int ) if maybe_int . ndim > 1 else jnp . array ([ maybe_int ]) ) raise TypeError self . simulation_params . from_state = maybe_int_to_arr ( from_state ) self . simulation_params . to_state = maybe_int_to_arr ( to_state ) self . simulation_params . excited_electrons = maybe_int_to_arr ( excited_electrons )","title":"set_excitation"},{"location":"api/#granad.orbitals.OrbitalList.set_groups_coulomb","text":"Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the Coulomb interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 def set_groups_coulomb ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _coulomb_dict )","title":"set_groups_coulomb"},{"location":"api/#granad.orbitals.OrbitalList.set_groups_hopping","text":"Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the hopping interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def set_groups_hopping ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _hopping_dict )","title":"set_groups_hopping"},{"location":"api/#granad.orbitals.OrbitalList.set_hamiltonian_element","text":"Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Hamiltonian element. Source code in src/granad/orbitals.py 455 456 457 458 459 460 461 462 463 464 465 def set_hamiltonian_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _hopping_dict )","title":"set_hamiltonian_element"},{"location":"api/#granad.orbitals.OrbitalList.shift_by_vector","text":"Shifts all orbitals with a specific tag by a given vector. Parameters: tag ( str ) \u2013 The tag to match orbitals. translation_vector ( Array ) \u2013 The vector by which to translate the orbital positions. Notes This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 @mutates def shift_by_vector ( self , tag , translation_vector ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag (str): The tag to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [ orb for orb in self . _list if orb . tag == tag ] for orb in orbs : orb . position += translation_vector","title":"shift_by_vector"},{"location":"api/#granad.orbitals.OrbitalList.transform_to_energy_basis","text":"Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the energy basis. Source code in src/granad/orbitals.py 757 758 759 760 761 762 763 764 765 766 767 768 def transform_to_energy_basis ( self , observable ): # \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T )","title":"transform_to_energy_basis"},{"location":"api/#granad.orbitals.OrbitalList.transform_to_site_basis","text":"Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the site basis. Source code in src/granad/orbitals.py 745 746 747 748 749 750 751 752 753 754 755 def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors )","title":"transform_to_site_basis"},{"location":"units/","text":"Units GRANAD uses the following unit conventions Quantity Unit Energy eV Distance \u00c5ngstr\u00f6m Time \\(0.659 \\cdot 10^{-15}\\) s Charge \\(1.6 \\cdot 10^{-19}\\) C Electric field strength \\(10^{10}\\) V/m","title":"Units"},{"location":"units/#units","text":"GRANAD uses the following unit conventions Quantity Unit Energy eV Distance \u00c5ngstr\u00f6m Time \\(0.659 \\cdot 10^{-15}\\) s Charge \\(1.6 \\cdot 10^{-19}\\) C Electric field strength \\(10^{10}\\) V/m","title":"Units"},{"location":"tutorials/getting_started/","text":"Getting started We introduce the basics of GRANAD and do a quick simulation. Orbitals At its core, GRANAD is all about orbitals. Let's create one at the origin and inspect it. from granad import Orbital my_first_orbital = Orbital ( position = ( 0 , 0 , 0 ), tag = \"a tag contains arbitrary information\" , ) print ( my_first_orbital ) {'position': Array([0., 0., 0.], dtype=float64), 'layer_index': None, 'tag': 'a tag contains arbitrary information', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 1} The group_id, unsurprisingly, groups orbitals. For example: if you create a two-level adatom, you need two orbitals that share the same group_id. In the same way, all orbitals in a graphene sheet share the same group_id. my_second_orbital = Orbital ( position = ( 1 , 1 , 1 ), tag = \"a new, shifted orbital\" , ) print ( my_second_orbital ) {'position': Array([1., 1., 1.], dtype=float64), 'layer_index': None, 'tag': 'a new, shifted orbital', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 2} This is all there is to know about orbitals! Materials Materials are stuff you can cut orbitals from. We will see below how this works. from granad import Materials Materials . available () Available materials: graphene ssh metal_1d Let's inspect a material. Materials . describe ( \"graphene\" ) Material: graphene Lattice Constant: 2.46 \u00c5 Lattice Basis: [[ 1. 0. 0. ] [-0.5 0.8660254 0. ]] Orbital Species: pz characterized by (n,l,m,s, atom name) = (0, 1, 0, 0, 'C') Orbitals: Position: (0, 0), Tag: sublattice_1, Species: pz Position: (-0.3333333333333333, -0.6666666666666666), Tag: sublattice_2, Species: pz Interactions: Type: hopping, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([0.0, 2.66], <function Material.add_interaction.<locals>.<lambda> at 0x7fadae7eda80>) Type: coulomb, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([16.522, 8.64, 5.333], <function Material.add_interaction.<locals>.<lambda> at 0x7fadae7ee200>) There are parameters regarding the geometry, the type of the involved orbitals (the built-in graphene model contains only a single spin polarized pz orbital) , the position of orbitals in the unit cell and the interactions (currently, GRANAD supports hoppings and Coulomb interactions). Let's pick a concrete material. graphene = Materials . get ( \"graphene\" ) OrbitalLists OrbitalLists are the last class you need to know. Unsurprisingly, an OrbitalList is a list of orbitals. You can create one yourself from the two orbitals you created above from granad import OrbitalList my_first_orbital_list = OrbitalList ([ my_first_orbital , my_second_orbital ]) print ( my_first_orbital_list ) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals Alternatively, you get orbital lists if you cut a flake from a material. You do this by specifying the shape of the flake. You can specify any shape you want, but this is covered in a separate tutorial. For now, we will use a built-in shape: an equilateral triangle with a side length of 15 Angstr\u00f6m. from granad import Triangle import jax.numpy as jnp triangle = Triangle ( 15 , armchair = True ) Now, our shape is ready and we can start cutting. To make sure that we are satisfied with what we get, we plot the flake. By default, GRANAD cuts any \"dangling\" atoms. my_first_flake = graphene . cut_flake ( triangle , plot = True ) print ( my_first_flake ) List with 26 orbitals, 26 electrons. [0] electrons excited from [0] to [0]. group id 3 : 26 orbitals For more information on cutting, including different edge types and how to keep dangling atoms, have a look at the corresponding tutorial. A first simulation To get a feeling of the setup, we first inspect the energies of the flake my_first_flake . show_energies () Physical observables are expectation values of Hermitian operators. GRANAD offers access to the time-resolved density matrix \\(\\rho(t)\\) of a system by integrating a nonlinear master equation. As a result, it is possible to track the evolution of the physical observable associated with a Hermitian operator \\(A\\) by computing \\(a(t) = Tr[\\rho(t) A]\\) . Optical properties in particular are largely determined by the polarization or dipole operator \\(\\hat{P}\\) and they are usually expressed in frequency domain. To this end, GRANAD offers a way to compute the Fourier transform \\(a(\\omega)\\) directly after time propagation. We will look at an example tracking the time evolution of the dipole operator below, where the computation proceeds in two steps: Excite the flake with an electric field. Compute its dipole moment \\(p(\\omega)\\) from the expectation value of its dipole operator. We first do step 1. To obtain a broad frequency spectrum, we must pick a narrow pulse in time-domain from granad import Pulse my_first_illumination = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) For step 2, a few parameters have to be chosen Simulation duration: we go from 0 to 40 in 1e5 steps. Relaxation rate: this is \\(r\\) in the dissipation term \\(D[\\rho] = r \\cdot(\\rho - \\rho_0)\\) in the master equation. Frequency domain limits: we choose the interval [0, 16]. Density matrix sampling rate: producing 1e5 density matrices can quickly exhaust RAM ressources. So we only save every 100th density matrix, such that we get 1000 density matrices. A simulation is just passing all of these parameters to the corresponding method of our flake. omegas , dipole_omega , pulse_omega = my_first_flake . get_expectation_value_frequency_domain ( operator = my_first_flake . dipole_operator , end_time = 40 , steps_time = 1e5 , relaxation_rate = 1 / 10 , illumination = my_first_illumination , omega_min = 0 , omega_max = 10 , skip = 100 , ) We see that three variables are returned: the omega axis we have specified, the dipole moment and the pulse in freqeuency domain. There is no way to control the number of points in the omega axis, because it is the result of a Fourier transform. We now plot the dipole moment and the pulse in frequency domain. import matplotlib.pyplot as plt plt . plot ( omegas , dipole_omega ) plt . plot ( omegas , pulse_omega , \"--\" ) plt . show ()","title":"Getting started"},{"location":"tutorials/getting_started/#getting-started","text":"We introduce the basics of GRANAD and do a quick simulation.","title":"Getting started"},{"location":"tutorials/getting_started/#orbitals","text":"At its core, GRANAD is all about orbitals. Let's create one at the origin and inspect it. from granad import Orbital my_first_orbital = Orbital ( position = ( 0 , 0 , 0 ), tag = \"a tag contains arbitrary information\" , ) print ( my_first_orbital ) {'position': Array([0., 0., 0.], dtype=float64), 'layer_index': None, 'tag': 'a tag contains arbitrary information', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 1} The group_id, unsurprisingly, groups orbitals. For example: if you create a two-level adatom, you need two orbitals that share the same group_id. In the same way, all orbitals in a graphene sheet share the same group_id. my_second_orbital = Orbital ( position = ( 1 , 1 , 1 ), tag = \"a new, shifted orbital\" , ) print ( my_second_orbital ) {'position': Array([1., 1., 1.], dtype=float64), 'layer_index': None, 'tag': 'a new, shifted orbital', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 2} This is all there is to know about orbitals!","title":"Orbitals"},{"location":"tutorials/getting_started/#materials","text":"Materials are stuff you can cut orbitals from. We will see below how this works. from granad import Materials Materials . available () Available materials: graphene ssh metal_1d Let's inspect a material. Materials . describe ( \"graphene\" ) Material: graphene Lattice Constant: 2.46 \u00c5 Lattice Basis: [[ 1. 0. 0. ] [-0.5 0.8660254 0. ]] Orbital Species: pz characterized by (n,l,m,s, atom name) = (0, 1, 0, 0, 'C') Orbitals: Position: (0, 0), Tag: sublattice_1, Species: pz Position: (-0.3333333333333333, -0.6666666666666666), Tag: sublattice_2, Species: pz Interactions: Type: hopping, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([0.0, 2.66], <function Material.add_interaction.<locals>.<lambda> at 0x7fadae7eda80>) Type: coulomb, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([16.522, 8.64, 5.333], <function Material.add_interaction.<locals>.<lambda> at 0x7fadae7ee200>) There are parameters regarding the geometry, the type of the involved orbitals (the built-in graphene model contains only a single spin polarized pz orbital) , the position of orbitals in the unit cell and the interactions (currently, GRANAD supports hoppings and Coulomb interactions). Let's pick a concrete material. graphene = Materials . get ( \"graphene\" )","title":"Materials"},{"location":"tutorials/getting_started/#orbitallists","text":"OrbitalLists are the last class you need to know. Unsurprisingly, an OrbitalList is a list of orbitals. You can create one yourself from the two orbitals you created above from granad import OrbitalList my_first_orbital_list = OrbitalList ([ my_first_orbital , my_second_orbital ]) print ( my_first_orbital_list ) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals Alternatively, you get orbital lists if you cut a flake from a material. You do this by specifying the shape of the flake. You can specify any shape you want, but this is covered in a separate tutorial. For now, we will use a built-in shape: an equilateral triangle with a side length of 15 Angstr\u00f6m. from granad import Triangle import jax.numpy as jnp triangle = Triangle ( 15 , armchair = True ) Now, our shape is ready and we can start cutting. To make sure that we are satisfied with what we get, we plot the flake. By default, GRANAD cuts any \"dangling\" atoms. my_first_flake = graphene . cut_flake ( triangle , plot = True ) print ( my_first_flake ) List with 26 orbitals, 26 electrons. [0] electrons excited from [0] to [0]. group id 3 : 26 orbitals For more information on cutting, including different edge types and how to keep dangling atoms, have a look at the corresponding tutorial.","title":"OrbitalLists"},{"location":"tutorials/getting_started/#a-first-simulation","text":"To get a feeling of the setup, we first inspect the energies of the flake my_first_flake . show_energies () Physical observables are expectation values of Hermitian operators. GRANAD offers access to the time-resolved density matrix \\(\\rho(t)\\) of a system by integrating a nonlinear master equation. As a result, it is possible to track the evolution of the physical observable associated with a Hermitian operator \\(A\\) by computing \\(a(t) = Tr[\\rho(t) A]\\) . Optical properties in particular are largely determined by the polarization or dipole operator \\(\\hat{P}\\) and they are usually expressed in frequency domain. To this end, GRANAD offers a way to compute the Fourier transform \\(a(\\omega)\\) directly after time propagation. We will look at an example tracking the time evolution of the dipole operator below, where the computation proceeds in two steps: Excite the flake with an electric field. Compute its dipole moment \\(p(\\omega)\\) from the expectation value of its dipole operator. We first do step 1. To obtain a broad frequency spectrum, we must pick a narrow pulse in time-domain from granad import Pulse my_first_illumination = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) For step 2, a few parameters have to be chosen Simulation duration: we go from 0 to 40 in 1e5 steps. Relaxation rate: this is \\(r\\) in the dissipation term \\(D[\\rho] = r \\cdot(\\rho - \\rho_0)\\) in the master equation. Frequency domain limits: we choose the interval [0, 16]. Density matrix sampling rate: producing 1e5 density matrices can quickly exhaust RAM ressources. So we only save every 100th density matrix, such that we get 1000 density matrices. A simulation is just passing all of these parameters to the corresponding method of our flake. omegas , dipole_omega , pulse_omega = my_first_flake . get_expectation_value_frequency_domain ( operator = my_first_flake . dipole_operator , end_time = 40 , steps_time = 1e5 , relaxation_rate = 1 / 10 , illumination = my_first_illumination , omega_min = 0 , omega_max = 10 , skip = 100 , ) We see that three variables are returned: the omega axis we have specified, the dipole moment and the pulse in freqeuency domain. There is no way to control the number of points in the omega axis, because it is the result of a Fourier transform. We now plot the dipole moment and the pulse in frequency domain. import matplotlib.pyplot as plt plt . plot ( omegas , dipole_omega ) plt . plot ( omegas , pulse_omega , \"--\" ) plt . show ()","title":"A first simulation"},{"location":"tutorials/linear_response_absorption_cross_section_with_td_and_rpa_simulations/","text":"Linear response absorption cross section with TD and RPA simulations We will calculate the optical absorption in the RPA and compare it to TD simulations with a weak external field. RPA First, we set up the RPA simulation. We will consider a small triangle such that the required simulation time stays in the seconds range. import jax.numpy as jnp from granad import Materials , Triangle # get material graphene = Materials . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ) ) # frequencies omegas_rpa = jnp . linspace ( 0 , 5 , 40 ) We obtain the polarizability for an external \\(x\\) polarized field and from its imaginary part the absorption. polarizability = flake . get_polarizability_rpa ( omegas_rpa , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 ) absorption_rpa = jnp . abs ( polarizability . imag * 4 * jnp . pi * omegas_rpa ) TD For the TD simulations, we specify a spectrally broad external illumination (i.e. a narrow pulse in time domain) to capture the system's response over a large frequency range. from granad import Pulse pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) We then compute the TD dipole moment and Fourier transform it. omegas , dipole_omega , pulse_omega = flake . get_expectation_value_frequency_domain ( operator = flake . dipole_operator , # the dipole moment is the expectation value of the dipole operator end_time = 40 , steps_time = 1e5 , relaxation_rate = 1 / 10 , illumination = pulse , omega_min = 0 , omega_max = 5 , skip = 100 , ) The polarizability is given by \\(p / E\\) (we only take the \\(x\\) - component). absorption_td = jnp . abs ( - omegas * jnp . imag ( dipole_omega [:, 0 ] / pulse_omega [:, 0 ] ) ) We can now compare the two results. import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas_rpa , absorption_rpa / jnp . max ( absorption_rpa ), 'o' , linewidth = 2 , label = 'RPA' ) plt . plot ( omegas , absorption_td / jnp . max ( absorption_td ), linewidth = 2 , ls = '--' , label = 'TD' ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . legend () plt . grid ( True ) plt . show ()","title":"Linear response absorption cross section with td and rpa simulations"},{"location":"tutorials/linear_response_absorption_cross_section_with_td_and_rpa_simulations/#linear-response-absorption-cross-section-with-td-and-rpa-simulations","text":"We will calculate the optical absorption in the RPA and compare it to TD simulations with a weak external field.","title":"Linear response absorption cross section with TD and RPA simulations"},{"location":"tutorials/linear_response_absorption_cross_section_with_td_and_rpa_simulations/#rpa","text":"First, we set up the RPA simulation. We will consider a small triangle such that the required simulation time stays in the seconds range. import jax.numpy as jnp from granad import Materials , Triangle # get material graphene = Materials . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ) ) # frequencies omegas_rpa = jnp . linspace ( 0 , 5 , 40 ) We obtain the polarizability for an external \\(x\\) polarized field and from its imaginary part the absorption. polarizability = flake . get_polarizability_rpa ( omegas_rpa , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 ) absorption_rpa = jnp . abs ( polarizability . imag * 4 * jnp . pi * omegas_rpa )","title":"RPA"},{"location":"tutorials/linear_response_absorption_cross_section_with_td_and_rpa_simulations/#td","text":"For the TD simulations, we specify a spectrally broad external illumination (i.e. a narrow pulse in time domain) to capture the system's response over a large frequency range. from granad import Pulse pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) We then compute the TD dipole moment and Fourier transform it. omegas , dipole_omega , pulse_omega = flake . get_expectation_value_frequency_domain ( operator = flake . dipole_operator , # the dipole moment is the expectation value of the dipole operator end_time = 40 , steps_time = 1e5 , relaxation_rate = 1 / 10 , illumination = pulse , omega_min = 0 , omega_max = 5 , skip = 100 , ) The polarizability is given by \\(p / E\\) (we only take the \\(x\\) - component). absorption_td = jnp . abs ( - omegas * jnp . imag ( dipole_omega [:, 0 ] / pulse_omega [:, 0 ] ) ) We can now compare the two results. import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas_rpa , absorption_rpa / jnp . max ( absorption_rpa ), 'o' , linewidth = 2 , label = 'RPA' ) plt . plot ( omegas , absorption_td / jnp . max ( absorption_td ), linewidth = 2 , ls = '--' , label = 'TD' ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . legend () plt . grid ( True ) plt . show ()","title":"TD"},{"location":"tutorials/rabi_oscillations_in_tls/","text":"Rabi Oscillations in TLS We study Rabi oscillations in isolated two-level system. NOTE: this tutorial makes heavy use of the liberal way GRANAD lets you group orbitals. You might want to consult the tutorial on orbital lists first. Building a two-level system Consider an isolated atom, modelled as a two-level system. Each level is an orbital, so let's combine them in a list. from granad import Orbital , OrbitalList lower_level = Orbital ( tag = \"atom\" ) upper_level = Orbital ( tag = \"atom\" ) atom = OrbitalList ([ lower_level , upper_level ]) We have used a tag to signify that these the orbitals belong to the same atom. Let's see what we have done. print ( atom ) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We see that GRANAD assumes that every orbital is filled. But we want only the one of the levels filled. So, we set the electron number to 1. atom . simulation_params . electrons = 1 print ( atom ) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We now need to specify the Hamiltonian. We can do so by setting the elements corresponding to the orbitals. atom . set_hamiltonian_element ( upper_level , lower_level , 2.0 ) atom . set_hamiltonian_element ( upper_level , upper_level , 0.5 ) atom . set_hamiltonian_element ( lower_level , lower_level , - 0.5 ) print ( atom ) print ( atom . hamiltonian ) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals [[-0.5+0.j 2. +0.j] [ 2. +0.j 0.5+0.j]] Setting dipole transitions is similar. We want the lower and upper level to be connected by a dipole transition in z-direction. atom . set_dipole_transition ( upper_level , lower_level , [ 1 , 0 , 0 ]) print ( atom ) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We set the initial excited state (in our point of view, this is a HOMO-LUMO transition). atom . set_excitation ( atom . homo , atom . homo + 1 , 1 ) print ( atom ) List with 2 orbitals, 1 electrons. [1] electrons excited from [0] to [1]. group id 1 : 1 orbitals group id 2 : 1 orbitals We consider a continuous wave as an external illumination. from granad import Wave wave = Wave ( amplitudes = [ 0.05 , 0 , 0 ], frequency = 2 ) We propagate the system in time. time , density_matrices = atom . get_density_matrix_time_domain ( end_time = 10 , relaxation_rate = 1 , illumination = wave , use_rwa = True ) atom . show_time_dependence ( density_matrices , time = time )","title":"Rabi oscillations in tls"},{"location":"tutorials/rabi_oscillations_in_tls/#rabi-oscillations-in-tls","text":"We study Rabi oscillations in isolated two-level system. NOTE: this tutorial makes heavy use of the liberal way GRANAD lets you group orbitals. You might want to consult the tutorial on orbital lists first.","title":"Rabi Oscillations in TLS"},{"location":"tutorials/rabi_oscillations_in_tls/#building-a-two-level-system","text":"Consider an isolated atom, modelled as a two-level system. Each level is an orbital, so let's combine them in a list. from granad import Orbital , OrbitalList lower_level = Orbital ( tag = \"atom\" ) upper_level = Orbital ( tag = \"atom\" ) atom = OrbitalList ([ lower_level , upper_level ]) We have used a tag to signify that these the orbitals belong to the same atom. Let's see what we have done. print ( atom ) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We see that GRANAD assumes that every orbital is filled. But we want only the one of the levels filled. So, we set the electron number to 1. atom . simulation_params . electrons = 1 print ( atom ) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We now need to specify the Hamiltonian. We can do so by setting the elements corresponding to the orbitals. atom . set_hamiltonian_element ( upper_level , lower_level , 2.0 ) atom . set_hamiltonian_element ( upper_level , upper_level , 0.5 ) atom . set_hamiltonian_element ( lower_level , lower_level , - 0.5 ) print ( atom ) print ( atom . hamiltonian ) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals [[-0.5+0.j 2. +0.j] [ 2. +0.j 0.5+0.j]] Setting dipole transitions is similar. We want the lower and upper level to be connected by a dipole transition in z-direction. atom . set_dipole_transition ( upper_level , lower_level , [ 1 , 0 , 0 ]) print ( atom ) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We set the initial excited state (in our point of view, this is a HOMO-LUMO transition). atom . set_excitation ( atom . homo , atom . homo + 1 , 1 ) print ( atom ) List with 2 orbitals, 1 electrons. [1] electrons excited from [0] to [1]. group id 1 : 1 orbitals group id 2 : 1 orbitals We consider a continuous wave as an external illumination. from granad import Wave wave = Wave ( amplitudes = [ 0.05 , 0 , 0 ], frequency = 2 ) We propagate the system in time. time , density_matrices = atom . get_density_matrix_time_domain ( end_time = 10 , relaxation_rate = 1 , illumination = wave , use_rwa = True ) atom . show_time_dependence ( density_matrices , time = time )","title":"Building a two-level system"}]}