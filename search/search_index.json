{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to GRANAD GRANAD (GRAphene Nanoflakes with ADatoms) is a tight-binding simulation utility geared towards the exploration of systems at the intersection of solid state physics and quantum optics. Features Computes optical and electronic properties Full access to time-dependent density matrices via master equation Relies on JAX for performance and differentiability Installation Linux The recommended way is to install with (mini-)conda. First, set up miniconda: https://docs.anaconda.com/free/miniconda/index.html Then, create a fresh environment conda create -n granad 'python' Activate the environment conda activate granad Now, optionally install jupyter. Finally, install the package with pip install git+https://github.com/GRANADlauncher/granad.git Windows To install on Windows, set up WSL first. Then, follow the instructions above. Quickstart Set up the simulation import jax.numpy as jnp from granad import MaterialCatalog , Triangle # get material graphene = MaterialCatalog . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ) ) # frequencies omegas = jnp . linspace ( 0 , 5 , 50 ) # compute optical properties in the RPA with GPU-acceleration polarizability = flake . get_polarizability_rpa ( omegas , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 # higher numbers are faster and consume more RAM ) absorption = polarizability . imag * 4 * jnp . pi * omegas Plot the results import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas , absorption / jnp . max ( absorption ), linewidth = 2 ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . grid ( True )","title":"Home"},{"location":"#welcome-to-granad","text":"GRANAD (GRAphene Nanoflakes with ADatoms) is a tight-binding simulation utility geared towards the exploration of systems at the intersection of solid state physics and quantum optics.","title":"Welcome to GRANAD"},{"location":"#features","text":"Computes optical and electronic properties Full access to time-dependent density matrices via master equation Relies on JAX for performance and differentiability","title":"Features"},{"location":"#installation","text":"","title":"Installation"},{"location":"#linux","text":"The recommended way is to install with (mini-)conda. First, set up miniconda: https://docs.anaconda.com/free/miniconda/index.html Then, create a fresh environment conda create -n granad 'python' Activate the environment conda activate granad Now, optionally install jupyter. Finally, install the package with pip install git+https://github.com/GRANADlauncher/granad.git","title":"Linux"},{"location":"#windows","text":"To install on Windows, set up WSL first. Then, follow the instructions above.","title":"Windows"},{"location":"#quickstart","text":"Set up the simulation import jax.numpy as jnp from granad import MaterialCatalog , Triangle # get material graphene = MaterialCatalog . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ) ) # frequencies omegas = jnp . linspace ( 0 , 5 , 50 ) # compute optical properties in the RPA with GPU-acceleration polarizability = flake . get_polarizability_rpa ( omegas , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 # higher numbers are faster and consume more RAM ) absorption = polarizability . imag * 4 * jnp . pi * omegas Plot the results import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas , absorption / jnp . max ( absorption ), linewidth = 2 ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . grid ( True )","title":"Quickstart"},{"location":"about/","text":"About GRANAD is developed jointly at the Karlsruhe Institute of Technology by the Institute of Theoretical Solid State Physics and at the Nicolaus Copernicus University in Toru\u0144 by the Department of Quantum Physics .","title":"About"},{"location":"about/#about","text":"GRANAD is developed jointly at the Karlsruhe Institute of Technology by the Institute of Theoretical Solid State Physics and at the Nicolaus Copernicus University in Toru\u0144 by the Department of Quantum Physics .","title":"About"},{"location":"api/","text":"API Couplings dataclass A data class for representing orbital couplings. Attributes: hamiltonian ( _SortedTupleDict ) \u2013 A dictionary-like container holding Hamiltonian terms. coulomb ( _SortedTupleDict ) \u2013 A dictionary-like container for Coulomb interaction terms. dipole_transitions ( _SortedTupleDict ) \u2013 A dictionary-like container for storing dipole transition elements. Source code in src/granad/orbitals.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 @dataclass class Couplings : \"\"\" A data class for representing orbital couplings. Attributes: hamiltonian (_SortedTupleDict): A dictionary-like container holding Hamiltonian terms. coulomb (_SortedTupleDict): A dictionary-like container for Coulomb interaction terms. dipole_transitions (_SortedTupleDict): A dictionary-like container for storing dipole transition elements. \"\"\" hamiltonian : _SortedTupleDict = field ( default_factory = _SortedTupleDict ) coulomb : _SortedTupleDict = field ( default_factory = _SortedTupleDict ) dipole_transitions : _SortedTupleDict = field ( default_factory = _SortedTupleDict ) def __str__ ( self ): return def __add__ ( self , other ): if isinstance ( other , Couplings ): return Couplings ( _SortedTupleDict ( self . hamiltonian | other . hamiltonian ), _SortedTupleDict ( self . coulomb | other . coulomb ), _SortedTupleDict ( self . dipole_transitions | other . dipole_transitions ) ) raise ValueError Orbital dataclass Attributes: position ( Array ) \u2013 The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index ( Optional [ int ] ) \u2013 An optional index representing the layer of the orbital within its atom, may be None if not specified. tag ( Optional [ str ] ) \u2013 An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level ( Optional [ int ] ) \u2013 The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum ( Optional [ int ] ) \u2013 The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z ( Optional [ int ] ) \u2013 The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin ( Optional [ int ] ) \u2013 The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name ( Optional [ str ] ) \u2013 The name of the atom this orbital belongs to, can be None if not applicable. group_id ( int ) \u2013 A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. For example, all pz orbitals in a single graphene flake get the same group_id. Source code in src/granad/orbitals.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @dataclass class Orbital : \"\"\" Attributes: position (jax.Array): The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom, may be None if not specified. tag (Optional[str]): An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable. group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. For example, all pz orbitals in a single graphene flake get the same group_id. \"\"\" position : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 , 0 , 0 ]), hash = False , compare = False ) layer_index : Optional [ int ] = None tag : Optional [ str ] = None energy_level : Optional [ int ] = None angular_momentum : Optional [ int ] = None angular_momentum_z : Optional [ int ] = None spin : Optional [ int ] = None atom_name : Optional [ str ] = None group_id : _watchdog . GroupId = field ( default_factory = _watchdog . _Watchdog . next_value ) def __post_init__ ( self ): object . __setattr__ ( self , \"position\" , jnp . array ( self . position ) . astype ( float )) def __hash__ ( self ): # Include only immutable fields in hash calculation return hash ( ( self . layer_index , self . tag , self . energy_level , self . angular_momentum , self . angular_momentum_z , self . angular_momentum , self . spin , self . atom_name , self . group_id . id , ) ) def __str__ ( self ): return pformat ( vars ( self ), sort_dicts = False ) def __eq__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id == other . group_id and self . layer_index == other . layer_index def __lt__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id < other . group_id def __le__ ( self , other ): return self < other or self == other def __gt__ ( self , other ): return not self <= other def __ge__ ( self , other ): return not self < other def __ne__ ( self , other ): return not self == other OrbitalList A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list, while also maintaining additional functionalities for coupling orbitals and managing their relationships. The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries, where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float or a function representing the coupling strength or mechanism between the orbitals). The class also stores simulation parameters like the number of electrons and temperature in a dataclass. The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so quantity_x == quantity. The class exposes simulation methods. Attributes: _list ( list) ) \u2013 the underlying list that contains the orbitals params ( Params ) \u2013 Simulation parameters like electron count and temperature. couplings ( _SortedTupleDict ) \u2013 A (customized) dictionary where keys are tuples of orbital identifiers and values are the couplings (either float values or functions). Note Orbital Identification : Orbitals can be identified either by their group_id, a direct reference to the orbital object itself, or via a user-defined tag. Index Access : Orbitals can be accessed and managed by their index in the list, allowing for list-like manipulation (addition, removal, access). Coupling Definition : Allows for the definition and adjustment of couplings between pairs of orbitals, identified by a tuple of their respective identifiers. These couplings can dynamically represent the interaction strength or be a computational function that defines the interaction. Source code in src/granad/orbitals.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 @plotting_methods class OrbitalList : \"\"\" A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list, while also maintaining additional functionalities for coupling orbitals and managing their relationships. The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries, where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float or a function representing the coupling strength or mechanism between the orbitals). The class also stores simulation parameters like the number of electrons and temperature in a dataclass. The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so quantity_x == quantity. The class exposes simulation methods. Attributes: _list (list) : the underlying list that contains the orbitals params (Params): Simulation parameters like electron count and temperature. couplings (_SortedTupleDict): A (customized) dictionary where keys are tuples of orbital identifiers and values are the couplings (either float values or functions). Note: - **Orbital Identification**: Orbitals can be identified either by their group_id, a direct reference to the orbital object itself, or via a user-defined tag. - **Index Access**: Orbitals can be accessed and managed by their index in the list, allowing for list-like manipulation (addition, removal, access). - **Coupling Definition**: Allows for the definition and adjustment of couplings between pairs of orbitals, identified by a tuple of their respective identifiers. These couplings can dynamically represent the interaction strength or be a computational function that defines the interaction. \"\"\" def __init__ ( self , orbs = None , couplings = None , params = None , recompute = True ): self . _list = orbs if orbs is not None else [] self . couplings = couplings if couplings is not None else Couplings ( ) self . params = params if params is not None else Params ( len ( orbs ) ) self . _recompute = recompute def __getattr__ ( self , property_name ): if property_name . endswith ( \"_x\" ): original_name = property_name [: - 2 ] try : return getattr ( self , original_name ) except AttributeError : pass elif property_name . endswith ( \"_e\" ): original_name = property_name [: - 2 ] try : return self . transform_to_energy_basis ( getattr ( self , original_name )) except AttributeError : pass raise AttributeError ( f \" { self . __class__ . __name__ !r} object has no attribute { property_name !r} \" ) def __len__ ( self ): return len ( self . _list ) # can't mutate, because orbitals are immutable def __getitem__ ( self , position ): return self . _list [ position ] def __repr__ ( self ): info = f \"List with { len ( self ) } orbitals, { self . electrons } electrons.\" info += f \"Excitation: f { self . params . excitation } \" # TODO: add sth about groups return \" \\n \" . join (( info , repr ( self . _list ))) def __iter__ ( self ): return iter ( self . _list ) def __add__ ( self , other ): if not self . _are_orbs ( other ): raise TypeError if any ( orb in other for orb in self . _list ): raise ValueError if isinstance ( other , OrbitalList ): new_list = ( self . _list + list ( other )) . copy () new_couplings = self . couplings + other . couplings new_params = self . params + other . params return OrbitalList ( new_list , new_couplings , new_params ) @mutates def __setitem__ ( self , position , value ): if isinstance ( value , Orbital ): self . _list [ position ] = value raise TypeError def _delete_coupling ( self , orb , coupling ): keys_to_remove = [ key for key in coupling if orb in key ] for key in keys_to_remove : del coupling [ key ] @mutates def __delitem__ ( self , position ): orb = self . _list [ position ] self . _delete_coupling ( orb , self . couplings . hamiltonian ) self . _delete_coupling ( orb , self . couplings . coulomb ) self . _delete_coupling ( orb , self . couplings . dipole_transitions ) self . params . electrons -= 1 del self . _list [ position ] @staticmethod def _are_orbs ( candidate ): return all ( isinstance ( orb , Orbital ) for orb in candidate ) @mutates def _set_coupling ( self , orb1 , orb2 , val_or_func , coupling ): for o1 in orb1 : for o2 in orb2 : coupling [( o1 , o2 )] = val_or_func def _hamiltonian_coulomb ( self ): def fill_matrix ( matrix , coupling_dict ): dummy = jnp . arange ( len ( self )) triangle_mask = dummy [:, None ] >= dummy # TODO: in principle we can build a big tensor NxNxgroups, vmap over the last axis and sum the groups # first, we loop over all group_id couplings => interactions between groups for key , function in coupling_dict . group_id_items (): # TODO: big uff: we rely on the correct ordering of the group_ids for cols and rows, first key is always smaller than last keys => we get upper triangular valid indices # if it were the other way around, these would be zeroed by the triangle mask cols = group_ids == key [ 0 ] . id rows = ( group_ids == key [ 1 ] . id )[:, None ] combination_indices = jnp . logical_and ( rows , cols ) valid_indices = jnp . logical_and ( triangle_mask , combination_indices ) function = jax . vmap ( function ) matrix = matrix . at [ valid_indices ] . set ( function ( distances [ valid_indices ]) ) matrix += matrix . conj () . T - jnp . diag ( jnp . diag ( matrix )) # we now set single elements rows , cols , vals = [], [], [] for key , val in coupling_dict . orbital_items (): rows . append ( self . _list . index ( key [ 0 ])) cols . append ( self . _list . index ( key [ 1 ])) vals . append ( val ) # TODO: uff not good vals = jnp . array ( vals ) matrix = matrix . at [ rows , cols ] . set ( vals ) matrix = matrix . at [ cols , rows ] . set ( vals . conj ()) return matrix # TODO: rounding positions = self . positions distances = jnp . round ( jnp . linalg . norm ( positions - positions [:, None ], axis =- 1 ), 6 ) group_ids = jnp . array ( [ orb . group_id . id for orb in self . _list ] ) hamiltonian = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . couplings . hamiltonian ) coulomb = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . couplings . coulomb ) return hamiltonian , coulomb # TODO: abstract this boilerplate away @mutates def set_dipole_element ( self , orb1 , orb2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb1: Identifier for orbital(s) for the first part of the transition. orb2: Identifier for orbital(s) for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), jnp . array ( arr ) . astype ( complex ), self . couplings . dipole_transitions ) def set_hamiltonian_groups ( self , orb1 , orb2 , func ): \"\"\" Sets the hamiltonian coupling between two groups of orbitals. Parameters: orb1: Identifier for orbital(s) for the first group. orb2: Identifier for orbital(s) for the second group. func (callable): Function that defines the hamiltonian interaction. Note: The function `func` should be complex-valued. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , _watchdog . GroupId ), self . filter_orbs ( orb2 , _watchdog . GroupId ), self . _ensure_complex ( func ), self . couplings . hamiltonian ) def set_coulomb_groups ( self , orb1 , orb2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb1: Identifier for orbital(s) for the first group. orb2: Identifier for orbital(s) for the second group. func (callable): Function that defines the Coulomb interaction. Note: The function `func` should be complex-valued. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , _watchdog . GroupId ), self . filter_orbs ( orb2 , _watchdog . GroupId ), self . _ensure_complex ( func ), self . couplings . coulomb ) def set_hamiltonian_element ( self , orb1 , orb2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb1: Identifier for orbital(s) for the first element. orb2: Identifier for orbital(s) for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), self . _ensure_complex ( val ), self . couplings . hamiltonian ) def set_coulomb_element ( self , orb1 , orb2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb1: Identifier for orbital(s) for the first element. orb2: Identifier for orbital(s) for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), self . _ensure_complex ( val ), self . couplings . coulomb ) def _ensure_complex ( self , func_or_val ): if callable ( func_or_val ): return lambda x : func_or_val ( x ) + 0.0 j if isinstance ( func_or_val , ( int , float , complex )): return func_or_val + 0.0 j raise TypeError def _build ( self ): assert len ( self ) > 0 self . _hamiltonian , self . _coulomb = self . _hamiltonian_coulomb () # TODO: there is something weird happening here! self . _eigenvectors , self . _energies = jax . lax . linalg . eigh ( self . _hamiltonian ) self . _initial_density_matrix = _numerics . _density_matrix ( self . _energies , self . params . electrons , self . params . spin_degeneracy , self . params . eps , self . params . excitation , self . params . beta , ) self . _stationary_density_matrix = _numerics . _density_matrix ( self . _energies , self . params . electrons , self . params . spin_degeneracy , self . params . eps , Params ( 0 ) . excitation , self . params . beta , ) if len ( self . params . self_consistency_params ) != 0 : ( self . _hamiltonian , self . _initial_density_matrix , self . _stationary_density_matrix , self . _energies , self . _eigenvectors , ) = _numerics . _get_self_consistent ( self . _hamiltonian , self . _coulomb , self . positions , self . params . excitation , self . params . spin_degeneracy , self . params . electrons , self . params . eps , self . _eigenvectors , self . _stationary_density_matrix , ** self . params . self_consistency_params , ) self . _initial_density_matrix = self . transform_to_site_basis ( self . _initial_density_matrix ) self . _stationary_density_matrix = self . transform_to_site_basis ( self . _stationary_density_matrix ) def set_open_shell ( self ): if any ( orb . spin is None for orb in self . _list ): raise ValueError self . simulation_params . spin_degeneracy = 1.0 def set_closed_shell ( self ): self . simulation_params . spin_degeneracy = 2.0 def index ( self , orb ): return self . _list . index ( orb ) @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other ) self . params . electrons += 1 # TODO: replace if else with action map def filter_orbs ( self , orb_id , t ): def filter_single_orb ( orb_id , t ): if type ( orb_id ) == t : return [ orb_id ] # index to group, orb, tag => group_id / orb / tag at index, if isinstance ( orb_id , int ) and t == _watchdog . GroupId : return [ self . _list [ orb_id ] . group_id ] if isinstance ( orb_id , int ) and t == Orbital : return [ self . _list [ orb_id ]] if isinstance ( orb_id , int ) and t == str : return [ self . _list [ orb_id ] . tag ] # group to index, orb, tag => group_id / orb / tag at index, if isinstance ( orb_id , _watchdog . GroupId ) and t == str : return [ orb . tag for orb in self if orb . group_id == orb_id ] if isinstance ( orb_id , _watchdog . GroupId ) and t == Orbital : return [ orb for orb in self if orb . group_id == orb_id ] if isinstance ( orb_id , _watchdog . GroupId ) and t == int : return [ i for i , orb in enumerate ( self ) if orb . group_id == orb_id ] # tag to group, orb, index => group_id / orb / tag at index, if isinstance ( orb_id , str ) and t == _watchdog . GroupId : return [ orb . group_id for orb in self if orb . tag == orb_id ] if isinstance ( orb_id , str ) and t == int : return [ i for i , orb in enumerate ( self ) if orb . tag == orb_id ] if isinstance ( orb_id , str ) and t == Orbital : return [ orb for orb in self if orb . tag == orb_id ] # orb to index, group, tag if isinstance ( orb_id , Orbital ) and t == _watchdog . GroupId : return [ orb_id . group_id ] if isinstance ( orb_id , Orbital ) and t == int : return [ self . _list . index ( orb_id )] if isinstance ( orb_id , Orbital ) and t == str : return [ orb_id . tag ] # TODO: this is bad, do action map if not isinstance ( orb_id , OrbitalList ): orb_id = [ orb_id ] return [ x for orb in orb_id for x in filter_single_orb ( orb , t ) ] @mutates def shift_by_vector ( self , translation_vector , orb_id = None ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: translation_vector (list or jax.Array): The vector by which to translate the orbital positions. orb_id: Identifier for the orbital(s) to shift. Note: This operation mutates the positions of the matched orbitals. \"\"\" filtered_orbs = self . filter_orbs ( orb_id , Orbital ) if orb_id is not None else self for orb in filtered_orbs : orb . position += jnp . array ( translation_vector ) @mutates def set_position ( self , position , orb_id = None ): \"\"\" Sets the position of all orbitals with a specific tag. Parameters: position (list or jax.Array): The vector at which to move the orbitals orb_id: Identifier for the orbital(s) to shift. Note: This operation mutates the positions of the matched orbitals. \"\"\" filtered_orbs = self . filter_orbs ( orb_id , Orbital ) if orb_id is not None else self for orb in filtered_orbs : orb . position = position @mutates def set_self_consistent ( self , ** kwargs ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" default = { \"accuracy\" : 1e-6 , \"mix\" : 0.3 , \"iterations\" : 500 , \"coulomb_strength\" : 1.0 } self . params . self_consistency_params = default | kwargs @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Note: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): return jnp . array ( maybe_int ) raise TypeError self . params . excitation = [ maybe_int_to_arr ( from_state ), maybe_int_to_arr ( to_state ), maybe_int_to_arr ( excited_electrons )] @property def positions ( self ): return jnp . array ([ orb . position for orb in self . _list ]) # TODO: too verbose @property def electrons ( self ): return self . params . electrons @mutates def set_electrons ( self , val ): self . params . electrons = val @property def eps ( self ): return self . params . eps @mutates def set_eps ( self , val ): self . params . eps = val @property def spin_degeneracy ( self ): return self . params . spin_degeneracy @property @recomputes def homo ( self ): return ( self . electrons * self . stationary_density_matrix_e ) . real . diagonal () . round ( 2 ) . nonzero ()[ 0 ][ - 1 ] . item () @property @recomputes def eigenvectors ( self ): return self . _eigenvectors @property @recomputes def energies ( self ): return self . _energies @property @recomputes def hamiltonian ( self ): return self . _hamiltonian @property @recomputes def coulomb ( self ): return self . _coulomb @property @recomputes def initial_density_matrix ( self ): return self . _initial_density_matrix @property @recomputes def stationary_density_matrix ( self ): return self . _stationary_density_matrix @property @recomputes def quadrupole_operator ( self ): \"\"\" Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: jax.Array: A tensor representing the quadrupole operator. \"\"\" dip = self . dipole_operator term = jnp . einsum ( \"ijk,jlm->ilkm\" , dip , dip ) diag = jnp . einsum ( \"ijk,jlk->il\" , dip , dip ) diag = jnp . einsum ( \"ij,kl->ijkl\" , diag , jnp . eye ( term . shape [ - 1 ])) return 3 * term - diag @property @recomputes def dipole_operator ( self ): \"\"\" Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. \"\"\" N = self . positions . shape [ 0 ] dipole_operator = jnp . zeros (( 3 , N , N )) . astype ( complex ) for i in range ( 3 ): dipole_operator = dipole_operator . at [ i , :, :] . set ( jnp . diag ( self . positions [:, i ] / 2 ) ) for orbital_combination , value in self . couplings . dipole_transitions . items (): i , j = self . _list . index ( orbital_combination [ 0 ]), self . _list . index ( orbital_combination [ 1 ] ) k = value . nonzero ()[ 0 ] dipole_operator = dipole_operator . at [ k , i , j ] . set ( value [ k ]) return dipole_operator + jnp . transpose ( dipole_operator , ( 0 , 2 , 1 )) . conj () @property @recomputes def velocity_operator ( self ): \"\"\" Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. \"\"\" if self . couplings . dipole_transitions is None : x_times_h = jnp . einsum ( \"ij,iL->ijL\" , self . _hamiltonian , self . positions ) h_times = jnp . einsum ( \"ij,jL->ijL\" , self . _hamiltonian , self . positions ) else : positions = self . dipole_operator x_times_h = jnp . einsum ( \"kj,Lik->Lij\" , self . _hamiltonian , positions ) h_times = jnp . einsum ( \"ik,Lkj->Lij\" , self . _hamiltonian , positions ) return - 1 j * ( x_times_h - h_times ) @property @recomputes def transition_energies ( self ): \"\"\" Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: jax.Array: The element `arr[i,j]` contains the transition energy from `i` to `j`. \"\"\" return self . _energies [:, None ] - self . _energies @property @recomputes def wigner_weisskopf_transition_rates ( self ): \"\"\" Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: jax.Array: The element `arr[i,j]` contains the transition rate from `i` to `j`. \"\"\" charge = 1.602e-19 eps_0 = 8.85 * 1e-12 hbar = 1.0545718 * 1e-34 c = 3e8 # 137 (a.u.) factor = 1.6e-29 * charge / ( 3 * jnp . pi * eps_0 * hbar ** 2 * c ** 3 ) te = self . transition_energies transition_dipole_moments = self . dipole_operator_e return ( ( te * ( te > self . eps )) ** 3 * jnp . squeeze ( transition_dipole_moments ** 2 ) * factor ) @staticmethod def _transform_basis ( observable , vectors ): dims_einsum_strings = { 2 : \"ij,jk,lk->il\" , 3 : \"ij,mjk,lk->mil\" } einsum_string = dims_einsum_strings [( observable . ndim )] return jnp . einsum ( einsum_string , vectors , observable , vectors . conj ()) def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors ) def transform_to_energy_basis ( self , observable ): \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T ) @recomputes def get_charge ( self , density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. If omitted, the initial density matrix is used. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" density_matrix = self . initial_density_matrix if density_matrix is None else density_matrix return jnp . diag ( density_matrix * self . electrons ) @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians ) @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians ) @recomputes def get_epi ( self , density_matrix_stat : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = epsilon if epsilon is not None else self . eps density_matrix_stat_without_diagonal = jnp . abs ( density_matrix_stat - jnp . diag ( jnp . diag ( density_matrix_stat ))) density_matrix_stat_normalized = density_matrix_stat_without_diagonal / jnp . linalg . norm ( density_matrix_stat_without_diagonal ) te = self . transition_energies excitonic_transitions = ( density_matrix_stat_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * density_matrix_stat_normalized )) / ( jnp . linalg . norm ( density_matrix_stat_normalized ) * jnp . linalg . norm ( excitonic_transitions ) ) @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field def get_expectation_value ( self , * , operator , density_matrix , induced = True ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->li\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } correction = self . stationary_density_matrix_x if induced == True else 0 return self . electrons * jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , correction - density_matrix , ) def get_args ( self , relaxation_rate = 0.0 , coulomb_strength = 1.0 , propagator = None ): return TDArgs ( self . hamiltonian , self . energies , self . coulomb * coulomb_strength , self . initial_density_matrix , self . stationary_density_matrix , self . eigenvectors , self . dipole_operator , self . electrons , relaxation_rate , propagator , self . spin_degeneracy , self . positions ) @staticmethod def get_hamiltonian ( illumination = None , use_rwa = False , add_induced = False ): \"\"\"Dict holding terms of the default hamiltonian: bare + coulomb + dipole gauge coupling to external field + (optional) induced field (optionally in RWA)\"\"\" contents = {} contents [ \"bare_hamiltonian\" ] = potentials . BareHamiltonian () contents [ \"coulomb\" ] = potentials . Coulomb () if illumination is not None : contents [ \"potential\" ] = potentials . DipoleGauge ( illumination , use_rwa ) if add_induced == True : contents [ \"induced\" ] = potentials . Induced ( ) return contents # TODO: default saturation @staticmethod def get_dissipator ( relaxation_rate = None , saturation = None ): \"\"\"Dict holding the term of the default dissipator: either decoherence time from relaxation_rate as float and ignored saturation or lindblad from relaxation_rate as array and saturation function\"\"\" if relaxation_rate is None and saturation is None : return { \"no_dissipation\" : lambda t , r , args : 0.0 } if isinstance ( relaxation_rate , float ): return { \"decoherence_time\" : dissipators . DecoherenceTime () } return { \"lindblad\" : dissipators . SaturationLindblad ( lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))) ) } # TODO: rewrite, should be static, leaks mem def get_postprocesses ( self , expectation_values , density_matrix ): postprocesses = {} if isinstance ( expectation_values , jax . Array ): expectation_values = [ expectation_values ] if expectation_values is not None : ops = jnp . concatenate ( expectation_values ) postprocesses [ \"expectation_values\" ] = lambda rho , args : self . get_expectation_value ( operator = ops , density_matrix = rho ) if density_matrix is None : return postprocesses if isinstance ( density_matrix , str ): density_matrix = [ density_matrix ] for option in density_matrix : if option == \"occ_x\" : postprocesses [ option ] = lambda rho , args : args . electrons * jnp . diagonal ( rho , axis1 =- 1 , axis2 =- 2 ) elif option == \"occ_e\" : postprocesses [ option ] = lambda rho , args : args . electrons * jnp . diagonal ( args . eigenvectors . conj () . T @ rho @ args . eigenvectors , axis1 =- 1 , axis2 =- 2 ) elif option == \"full\" : postprocesses [ option ] = lambda rho , args : rho return postprocesses # TODO: illumination is too implicit, args may be too implicit, but idk what else to do rn @recomputes def master_equation ( self , * , end_time : float , start_time : float = 0.0 , dt : float = 1e-4 , grid : Union [ int , jax . Array ] = 100 , max_mem_gb : float = 0.5 , initial_density_matrix : Optional [ jax . Array ] = None , coulomb_strength : float = 1.0 , illumination : Callable = None , relaxation_rate : float = None , compute_at : Optional [ jax . Array ] = None , expectation_values : Optional [ list [ jax . Array ]] = None , density_matrix : Optional [ list [ str ]] = None , use_rwa : bool = False , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), hamiltonian : dict = None , dissipator : dict = None , postprocesses : dict = None , rhs_args = None , ): \"\"\" Simulates the time evolution of the density matrix, computing observables, density matrices or extracting custom information. Args: end_time (float): The final time for the simulation. start_time (float): The starting time for the simulation. Defaults to 0.0. dt (float): The time step size for the simulation. Defaults to 1e-4. grid (Union[int, jax.Array]): Determines the output times for the simulation results. If an integer, results are saved every 'grid'-th time step. If an array, results are saved at the specified times. max_mem_gb (float): Maximum memory in gigabytes allowed for each batch of intermediate density matrices. initial_density_matrix (Optional[jax.Array]): The initial state of the density matrix. If not provided, `self.initial_density_matrix` is used. coulomb_strength (float): Scaling factor for the Coulomb interaction matrix. illumination (Callable): Function describing the time-dependent external illumination applied to the system. relaxation_rate (Union[float, jax.Array, Callable]): Specifies the relaxation dynamics. A float indicates a uniform decoherence time, an array provides state-specific rates. compute_at (Optional[jax.Array]): The orbitals indexed by this array will experience induced fields. expectation_values (Optional[list[jax.Array]]): Expectation values to compute during the simulation. density_matrix (Optional[list[str]]): Tags for additional density matrix computations. \"full\", \"occ_x\", \"occ_e\". May be deprecated. computation (Optional[Callable]): Additional computation to be performed at each step. use_rwa (bool): Whether to use the rotating wave approximation. Defaults to False. solver: The numerical solver instance to use for integrating the differential equations. stepsize_controller: Controller for adjusting the solver's step size based on error tolerance. hamiltonian: dict of functions representing terms in the hamiltonian. functions must have signature `t, r, args->jax.Array`. keys don't matter. dissipator:: dict of functions representing terms in the dissipator. functions must have signature `t, r, args->jax.Array`. keys don't matter. postprocesses: (bool): dict of functions representing information to extract from the simulation. functions must have signature `r, args->jax.Array`. keys don't matter. rhs_args: arguments passed to hamiltonian, dissipator, postprocesses during the simulation. namedtuple. Returns: ResultTD \"\"\" # arguments to evolution function if rhs_args is None : rhs_args = self . get_args ( relaxation_rate , coulomb_strength , _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_at ) ) if illumination is None : illumination = lambda t : jnp . array ( [ 0 j , 0 j , 0 j ] ) # each of these functions is applied to a density matrix batch postprocesses = self . get_postprocesses ( expectation_values , density_matrix ) if postprocesses is None else postprocesses # hermitian rhs hamiltonian = self . get_hamiltonian ( illumination , use_rwa , compute_at is not None ) if hamiltonian is None else hamiltonian # non hermitian rhs dissipator = self . get_dissipator ( relaxation_rate , None ) if dissipator is None else dissipator # set reasonable default initial_density_matrix = initial_density_matrix if initial_density_matrix is not None else rhs_args . initial_density_matrix return self . _integrate_master_equation ( list ( hamiltonian . values ()), list ( dissipator . values ()), list ( postprocesses . values ()), rhs_args , illumination , solver , stepsize_controller , initial_density_matrix , start_time , end_time , grid , max_mem_gb , dt ) @staticmethod def _integrate_master_equation ( hamiltonian , dissipator , postprocesses , rhs_args , illumination , solver , stepsize_controller , initial_density_matrix , start_time , end_time , grid , max_mem_gb , dt ): # batched time axis to save memory mat_size = initial_density_matrix . size * initial_density_matrix . itemsize / 1e9 time_axis = _numerics . get_time_axis ( mat_size = mat_size , grid = grid , start_time = start_time , end_time = end_time , max_mem_gb = max_mem_gb , dt = dt ) ## integrate final , output = _numerics . td_run ( initial_density_matrix , _numerics . get_integrator ( hamiltonian , dissipator , postprocesses , solver , stepsize_controller , dt ), time_axis , rhs_args ) return TDResult ( td_illumination = jax . vmap ( illumination )( jnp . concatenate ( time_axis )) , output = output , final_density_matrix = final , time_axis = jnp . concatenate ( time_axis ) ) def get_polarizability_rpa ( self , omegas , polarization , coulomb_strength = 1.0 , relaxation_rate = 1 / 10 , hungry = 0 , phi_ext = None , args = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. args (Optional): numeric representation of an orbital list, as obtained by `get_args` Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" if args is None : args = self . get_args ( relaxation_rate = relaxation_rate , coulomb_strength = coulomb_strength , propagator = None ) alpha = _numerics . rpa_polarizability_function ( args , polarization , hungry , phi_ext ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] ) def get_susceptibility_rpa ( self , omegas , relaxation_rate = 1 / 10 , coulomb_strength = 1.0 , hungry = 0 , args = None , ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. args (Optional): numeric representation of an orbital list, as obtained by `get_args` Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" if args is None : args = self . get_args ( relaxation_rate = relaxation_rate , coulomb_strength = coulomb_strength , propagator = None ) sus = _numerics . rpa_polarizability_function ( args , hungry ) return jax . lax . map ( sus , omegas ) def get_mean_field_hamiltonian ( self , overlap = None ): \"\"\"convert an orbital list to a set of parameters usable for the rhf procedure. currently, only an empirical direct channel interaction specified specified in a the list's coulomb dict is taken into account. \"\"\" # Since we consider <1i|U|i1> => U_{11ii} eri = self . coulomb [ None , None ] overlap = overlap if overlap is not None else jnp . eye ( self . hamiltonian . shape [ 0 ]) return _rhf ( self . hamiltonian , eri , overlap , self . electrons ) @property def atoms ( self ): atoms_pos = defaultdict ( list ) for orb in self . _list : atoms_pos [ orb . atom_name ] += [[ str ( x ) for x in orb . position ]] return atoms_pos def to_xyz ( self , name : str = None ): atoms = self . atoms number_of_atoms = sum ( [ len ( x ) for x in atoms . values ()] ) str_rep = str ( number_of_atoms ) + \" \\n\\n \" for atom , positions in atoms . items (): for pos in positions : str_rep += f ' { atom } { \" \" . join ( pos ) } \\n ' if name is None : return str_rep with open ( name , \"w\" ) as f : f . writelines ( str_rep ) # TODO: this far too simplistic @classmethod def from_xyz ( cls , name : str ): orbs , group_id = [], _watchdog . _Watchdog . next_value () with open ( name , 'r' ) as f : for line in f : processed = line . strip () . split () if len ( processed ) <= 1 : continue atom_name , x , y , z = processed orbs . append ( Orbital ( group_id = group_id , atom_name = atom_name , position = [ float ( x ), float ( y ), float ( z )] ) ) return cls ( orbs ) dipole_operator property Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: \u2013 jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. quadrupole_operator property Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: \u2013 jax.Array: A tensor representing the quadrupole operator. transition_energies property Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition energy from i to j . velocity_operator property Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: \u2013 jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. wigner_weisskopf_transition_rates property Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition rate from i to j . append ( other ) Appends an orbital to the list, ensuring it is not already present. Parameters: other ( Orbital ) \u2013 The orbital to append. Raises: TypeError \u2013 If other is not an instance of Orbital. ValueError \u2013 If other is already in the list. Source code in src/granad/orbitals.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other ) self . params . electrons += 1 get_charge ( density_matrix = None ) Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix ( Array , default: None ) \u2013 The density matrix to use for calculating charge. If omitted, the initial density matrix is used. Returns: \u2013 jax.Array: A diagonal array representing charges at each site. Source code in src/granad/orbitals.py 906 907 908 909 910 911 912 913 914 915 916 917 918 919 @recomputes def get_charge ( self , density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. If omitted, the initial density matrix is used. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" density_matrix = self . initial_density_matrix if density_matrix is None else density_matrix return jnp . diag ( density_matrix * self . electrons ) get_dissipator ( relaxation_rate = None , saturation = None ) staticmethod Dict holding the term of the default dissipator: either decoherence time from relaxation_rate as float and ignored saturation or lindblad from relaxation_rate as array and saturation function Source code in src/granad/orbitals.py 1070 1071 1072 1073 1074 1075 1076 1077 @staticmethod def get_dissipator ( relaxation_rate = None , saturation = None ): \"\"\"Dict holding the term of the default dissipator: either decoherence time from relaxation_rate as float and ignored saturation or lindblad from relaxation_rate as array and saturation function\"\"\" if relaxation_rate is None and saturation is None : return { \"no_dissipation\" : lambda t , r , args : 0.0 } if isinstance ( relaxation_rate , float ): return { \"decoherence_time\" : dissipators . DecoherenceTime () } return { \"lindblad\" : dissipators . SaturationLindblad ( lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))) ) } get_dos ( omega , broadening = 0.1 ) Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the DOS. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The integrated density of states at the specified frequency. Source code in src/granad/orbitals.py 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians ) get_epi ( density_matrix_stat , omega , epsilon = None ) Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat ( Array ) \u2013 The density matrix to consider for EPI calculation. omega ( float ) \u2013 The frequency to evaluate the EPI at. epsilon ( float , default: None ) \u2013 The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float ( float ) \u2013 The EPI. Source code in src/granad/orbitals.py 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 @recomputes def get_epi ( self , density_matrix_stat : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = epsilon if epsilon is not None else self . eps density_matrix_stat_without_diagonal = jnp . abs ( density_matrix_stat - jnp . diag ( jnp . diag ( density_matrix_stat ))) density_matrix_stat_normalized = density_matrix_stat_without_diagonal / jnp . linalg . norm ( density_matrix_stat_without_diagonal ) te = self . transition_energies excitonic_transitions = ( density_matrix_stat_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * density_matrix_stat_normalized )) / ( jnp . linalg . norm ( density_matrix_stat_normalized ) * jnp . linalg . norm ( excitonic_transitions ) ) get_expectation_value ( * , operator , density_matrix , induced = True ) Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator ( Array ) \u2013 The operator for which the expectation value is calculated. density_matrix ( Array ) \u2013 The density matrix representing the state of the system. Returns: \u2013 jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. Source code in src/granad/orbitals.py 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 def get_expectation_value ( self , * , operator , density_matrix , induced = True ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->li\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } correction = self . stationary_density_matrix_x if induced == True else 0 return self . electrons * jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , correction - density_matrix , ) get_hamiltonian ( illumination = None , use_rwa = False , add_induced = False ) staticmethod Dict holding terms of the default hamiltonian: bare + coulomb + dipole gauge coupling to external field + (optional) induced field (optionally in RWA) Source code in src/granad/orbitals.py 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 @staticmethod def get_hamiltonian ( illumination = None , use_rwa = False , add_induced = False ): \"\"\"Dict holding terms of the default hamiltonian: bare + coulomb + dipole gauge coupling to external field + (optional) induced field (optionally in RWA)\"\"\" contents = {} contents [ \"bare_hamiltonian\" ] = potentials . BareHamiltonian () contents [ \"coulomb\" ] = potentials . Coulomb () if illumination is not None : contents [ \"potential\" ] = potentials . DipoleGauge ( illumination , use_rwa ) if add_induced == True : contents [ \"induced\" ] = potentials . Induced ( ) return contents get_induced_field ( positions , density_matrix ) Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions ( Array ) \u2013 The positions at which to evaluate the induced field. density_matrix ( Array ) \u2013 The density matrix used to calculate the induced field. Returns: \u2013 jax.Array: The resulting electric field vector at each position. Source code in src/granad/orbitals.py 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field get_ldos ( omega , site_index , broadening = 0.1 ) Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the LDOS. site_index ( int ) \u2013 The site index to evaluate the LDOS at. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The local density of states at the specified site and frequency. Source code in src/granad/orbitals.py 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians ) get_mean_field_hamiltonian ( overlap = None ) convert an orbital list to a set of parameters usable for the rhf procedure. currently, only an empirical direct channel interaction specified specified in a the list's coulomb dict is taken into account. Source code in src/granad/orbitals.py 1273 1274 1275 1276 1277 1278 1279 1280 1281 def get_mean_field_hamiltonian ( self , overlap = None ): \"\"\"convert an orbital list to a set of parameters usable for the rhf procedure. currently, only an empirical direct channel interaction specified specified in a the list's coulomb dict is taken into account. \"\"\" # Since we consider <1i|U|i1> => U_{11ii} eri = self . coulomb [ None , None ] overlap = overlap if overlap is not None else jnp . eye ( self . hamiltonian . shape [ 0 ]) return _rhf ( self . hamiltonian , eri , overlap , self . electrons ) get_polarizability_rpa ( omegas , polarization , coulomb_strength = 1.0 , relaxation_rate = 1 / 10 , hungry = 0 , phi_ext = None , args = None ) Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas ( Array ) \u2013 Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate ( float , default: 1 / 10 ) \u2013 The relaxation time parameter. polarization ( Array ) \u2013 Polarization directions or modes. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interaction in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext ( Optional [ Array ] , default: None ) \u2013 External potential influences, if any. args ( Optional , default: None ) \u2013 numeric representation of an orbital list, as obtained by get_args Returns: \u2013 jax.Array: The calculated polarizabilities at the specified frequencies. Source code in src/granad/orbitals.py 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 def get_polarizability_rpa ( self , omegas , polarization , coulomb_strength = 1.0 , relaxation_rate = 1 / 10 , hungry = 0 , phi_ext = None , args = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. args (Optional): numeric representation of an orbital list, as obtained by `get_args` Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" if args is None : args = self . get_args ( relaxation_rate = relaxation_rate , coulomb_strength = coulomb_strength , propagator = None ) alpha = _numerics . rpa_polarizability_function ( args , polarization , hungry , phi_ext ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] ) get_susceptibility_rpa ( omegas , relaxation_rate = 1 / 10 , coulomb_strength = 1.0 , hungry = 0 , args = None ) Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas ( Array ) \u2013 The frequencies at which to compute susceptibility. relaxation_rate ( float , default: 1 / 10 ) \u2013 The relaxation time affecting susceptibility calculations. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interactions considered in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. args ( Optional , default: None ) \u2013 numeric representation of an orbital list, as obtained by get_args Returns: \u2013 jax.Array: The susceptibility values at the given frequencies. Source code in src/granad/orbitals.py 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 def get_susceptibility_rpa ( self , omegas , relaxation_rate = 1 / 10 , coulomb_strength = 1.0 , hungry = 0 , args = None , ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. args (Optional): numeric representation of an orbital list, as obtained by `get_args` Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" if args is None : args = self . get_args ( relaxation_rate = relaxation_rate , coulomb_strength = coulomb_strength , propagator = None ) sus = _numerics . rpa_polarizability_function ( args , hungry ) return jax . lax . map ( sus , omegas ) master_equation ( * , end_time , start_time = 0.0 , dt = 0.0001 , grid = 100 , max_mem_gb = 0.5 , initial_density_matrix = None , coulomb_strength = 1.0 , illumination = None , relaxation_rate = None , compute_at = None , expectation_values = None , density_matrix = None , use_rwa = False , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), hamiltonian = None , dissipator = None , postprocesses = None , rhs_args = None ) Simulates the time evolution of the density matrix, computing observables, density matrices or extracting custom information. Parameters: end_time ( float ) \u2013 The final time for the simulation. start_time ( float , default: 0.0 ) \u2013 The starting time for the simulation. Defaults to 0.0. dt ( float , default: 0.0001 ) \u2013 The time step size for the simulation. Defaults to 1e-4. grid ( Union [ int , Array ] , default: 100 ) \u2013 Determines the output times for the simulation results. If an integer, results are saved every 'grid'-th time step. If an array, results are saved at the specified times. max_mem_gb ( float , default: 0.5 ) \u2013 Maximum memory in gigabytes allowed for each batch of intermediate density matrices. initial_density_matrix ( Optional [ Array ] , default: None ) \u2013 The initial state of the density matrix. If not provided, self.initial_density_matrix is used. coulomb_strength ( float , default: 1.0 ) \u2013 Scaling factor for the Coulomb interaction matrix. illumination ( Callable , default: None ) \u2013 Function describing the time-dependent external illumination applied to the system. relaxation_rate ( Union [ float , Array , Callable ] , default: None ) \u2013 Specifies the relaxation dynamics. A float indicates a uniform decoherence time, an array provides state-specific rates. compute_at ( Optional [ Array ] , default: None ) \u2013 The orbitals indexed by this array will experience induced fields. expectation_values ( Optional [ list [ Array ]] , default: None ) \u2013 Expectation values to compute during the simulation. density_matrix ( Optional [ list [ str ]] , default: None ) \u2013 Tags for additional density matrix computations. \"full\", \"occ_x\", \"occ_e\". May be deprecated. computation ( Optional [ Callable ] ) \u2013 Additional computation to be performed at each step. use_rwa ( bool , default: False ) \u2013 Whether to use the rotating wave approximation. Defaults to False. solver \u2013 The numerical solver instance to use for integrating the differential equations. stepsize_controller \u2013 Controller for adjusting the solver's step size based on error tolerance. hamiltonian ( dict , default: None ) \u2013 dict of functions representing terms in the hamiltonian. functions must have signature t, r, args->jax.Array . keys don't matter. dissipator ( dict , default: None ) \u2013 : dict of functions representing terms in the dissipator. functions must have signature t, r, args->jax.Array . keys don't matter. postprocesses ( dict , default: None ) \u2013 (bool): dict of functions representing information to extract from the simulation. functions must have signature r, args->jax.Array . keys don't matter. rhs_args \u2013 arguments passed to hamiltonian, dissipator, postprocesses during the simulation. namedtuple. Returns: \u2013 ResultTD Source code in src/granad/orbitals.py 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 @recomputes def master_equation ( self , * , end_time : float , start_time : float = 0.0 , dt : float = 1e-4 , grid : Union [ int , jax . Array ] = 100 , max_mem_gb : float = 0.5 , initial_density_matrix : Optional [ jax . Array ] = None , coulomb_strength : float = 1.0 , illumination : Callable = None , relaxation_rate : float = None , compute_at : Optional [ jax . Array ] = None , expectation_values : Optional [ list [ jax . Array ]] = None , density_matrix : Optional [ list [ str ]] = None , use_rwa : bool = False , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), hamiltonian : dict = None , dissipator : dict = None , postprocesses : dict = None , rhs_args = None , ): \"\"\" Simulates the time evolution of the density matrix, computing observables, density matrices or extracting custom information. Args: end_time (float): The final time for the simulation. start_time (float): The starting time for the simulation. Defaults to 0.0. dt (float): The time step size for the simulation. Defaults to 1e-4. grid (Union[int, jax.Array]): Determines the output times for the simulation results. If an integer, results are saved every 'grid'-th time step. If an array, results are saved at the specified times. max_mem_gb (float): Maximum memory in gigabytes allowed for each batch of intermediate density matrices. initial_density_matrix (Optional[jax.Array]): The initial state of the density matrix. If not provided, `self.initial_density_matrix` is used. coulomb_strength (float): Scaling factor for the Coulomb interaction matrix. illumination (Callable): Function describing the time-dependent external illumination applied to the system. relaxation_rate (Union[float, jax.Array, Callable]): Specifies the relaxation dynamics. A float indicates a uniform decoherence time, an array provides state-specific rates. compute_at (Optional[jax.Array]): The orbitals indexed by this array will experience induced fields. expectation_values (Optional[list[jax.Array]]): Expectation values to compute during the simulation. density_matrix (Optional[list[str]]): Tags for additional density matrix computations. \"full\", \"occ_x\", \"occ_e\". May be deprecated. computation (Optional[Callable]): Additional computation to be performed at each step. use_rwa (bool): Whether to use the rotating wave approximation. Defaults to False. solver: The numerical solver instance to use for integrating the differential equations. stepsize_controller: Controller for adjusting the solver's step size based on error tolerance. hamiltonian: dict of functions representing terms in the hamiltonian. functions must have signature `t, r, args->jax.Array`. keys don't matter. dissipator:: dict of functions representing terms in the dissipator. functions must have signature `t, r, args->jax.Array`. keys don't matter. postprocesses: (bool): dict of functions representing information to extract from the simulation. functions must have signature `r, args->jax.Array`. keys don't matter. rhs_args: arguments passed to hamiltonian, dissipator, postprocesses during the simulation. namedtuple. Returns: ResultTD \"\"\" # arguments to evolution function if rhs_args is None : rhs_args = self . get_args ( relaxation_rate , coulomb_strength , _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_at ) ) if illumination is None : illumination = lambda t : jnp . array ( [ 0 j , 0 j , 0 j ] ) # each of these functions is applied to a density matrix batch postprocesses = self . get_postprocesses ( expectation_values , density_matrix ) if postprocesses is None else postprocesses # hermitian rhs hamiltonian = self . get_hamiltonian ( illumination , use_rwa , compute_at is not None ) if hamiltonian is None else hamiltonian # non hermitian rhs dissipator = self . get_dissipator ( relaxation_rate , None ) if dissipator is None else dissipator # set reasonable default initial_density_matrix = initial_density_matrix if initial_density_matrix is not None else rhs_args . initial_density_matrix return self . _integrate_master_equation ( list ( hamiltonian . values ()), list ( dissipator . values ()), list ( postprocesses . values ()), rhs_args , illumination , solver , stepsize_controller , initial_density_matrix , start_time , end_time , grid , max_mem_gb , dt ) set_coulomb_element ( orb1 , orb2 , val ) Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb1 \u2013 Identifier for orbital(s) for the first element. orb2 \u2013 Identifier for orbital(s) for the second element. val ( complex ) \u2013 The complex value to set for the Coulomb interaction element. Source code in src/granad/orbitals.py 512 513 514 515 516 517 518 519 520 521 def set_coulomb_element ( self , orb1 , orb2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb1: Identifier for orbital(s) for the first element. orb2: Identifier for orbital(s) for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), self . _ensure_complex ( val ), self . couplings . coulomb ) set_coulomb_groups ( orb1 , orb2 , func ) Sets the Coulomb coupling between two groups of orbitals. Parameters: orb1 \u2013 Identifier for orbital(s) for the first group. orb2 \u2013 Identifier for orbital(s) for the second group. func ( callable ) \u2013 Function that defines the Coulomb interaction. Note The function func should be complex-valued. Source code in src/granad/orbitals.py 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def set_coulomb_groups ( self , orb1 , orb2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb1: Identifier for orbital(s) for the first group. orb2: Identifier for orbital(s) for the second group. func (callable): Function that defines the Coulomb interaction. Note: The function `func` should be complex-valued. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , _watchdog . GroupId ), self . filter_orbs ( orb2 , _watchdog . GroupId ), self . _ensure_complex ( func ), self . couplings . coulomb ) set_dipole_element ( orb1 , orb2 , arr ) Sets a dipole transition for specified orbital or index pairs. Parameters: orb1 \u2013 Identifier for orbital(s) for the first part of the transition. orb2 \u2013 Identifier for orbital(s) for the second part of the transition. arr ( Array ) \u2013 The 3-element array containing dipole transition elements. Source code in src/granad/orbitals.py 457 458 459 460 461 462 463 464 465 466 467 @mutates def set_dipole_element ( self , orb1 , orb2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb1: Identifier for orbital(s) for the first part of the transition. orb2: Identifier for orbital(s) for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), jnp . array ( arr ) . astype ( complex ), self . couplings . dipole_transitions ) set_excitation ( from_state , to_state , excited_electrons ) Sets up an excitation process from one state to another with specified electrons. Parameters: from_state ( int, list, or jax.Array ) \u2013 The initial state index or indices. to_state ( int, list, or jax.Array ) \u2013 The final state index or indices. excited_electrons ( int, list, or jax.Array ) \u2013 The indices of electrons to be excited. Note The states and electron indices may be specified as scalars, lists, or arrays. Source code in src/granad/orbitals.py 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Note: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): return jnp . array ( maybe_int ) raise TypeError self . params . excitation = [ maybe_int_to_arr ( from_state ), maybe_int_to_arr ( to_state ), maybe_int_to_arr ( excited_electrons )] set_hamiltonian_element ( orb1 , orb2 , val ) Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb1 \u2013 Identifier for orbital(s) for the first element. orb2 \u2013 Identifier for orbital(s) for the second element. val ( complex ) \u2013 The complex value to set for the Hamiltonian element. Source code in src/granad/orbitals.py 501 502 503 504 505 506 507 508 509 510 def set_hamiltonian_element ( self , orb1 , orb2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb1: Identifier for orbital(s) for the first element. orb2: Identifier for orbital(s) for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), self . _ensure_complex ( val ), self . couplings . hamiltonian ) set_hamiltonian_groups ( orb1 , orb2 , func ) Sets the hamiltonian coupling between two groups of orbitals. Parameters: orb1 \u2013 Identifier for orbital(s) for the first group. orb2 \u2013 Identifier for orbital(s) for the second group. func ( callable ) \u2013 Function that defines the hamiltonian interaction. Note The function func should be complex-valued. Source code in src/granad/orbitals.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 def set_hamiltonian_groups ( self , orb1 , orb2 , func ): \"\"\" Sets the hamiltonian coupling between two groups of orbitals. Parameters: orb1: Identifier for orbital(s) for the first group. orb2: Identifier for orbital(s) for the second group. func (callable): Function that defines the hamiltonian interaction. Note: The function `func` should be complex-valued. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , _watchdog . GroupId ), self . filter_orbs ( orb2 , _watchdog . GroupId ), self . _ensure_complex ( func ), self . couplings . hamiltonian ) set_position ( position , orb_id = None ) Sets the position of all orbitals with a specific tag. Parameters: position ( list or Array ) \u2013 The vector at which to move the orbitals orb_id \u2013 Identifier for the orbital(s) to shift. Note This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 @mutates def set_position ( self , position , orb_id = None ): \"\"\" Sets the position of all orbitals with a specific tag. Parameters: position (list or jax.Array): The vector at which to move the orbitals orb_id: Identifier for the orbital(s) to shift. Note: This operation mutates the positions of the matched orbitals. \"\"\" filtered_orbs = self . filter_orbs ( orb_id , Orbital ) if orb_id is not None else self for orb in filtered_orbs : orb . position = position set_self_consistent ( ** kwargs ) Configures the list for self-consistent field calculations. Parameters: sc_params ( dict ) \u2013 Parameters for self-consistency. Source code in src/granad/orbitals.py 689 690 691 692 693 694 695 696 697 698 @mutates def set_self_consistent ( self , ** kwargs ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" default = { \"accuracy\" : 1e-6 , \"mix\" : 0.3 , \"iterations\" : 500 , \"coulomb_strength\" : 1.0 } self . params . self_consistency_params = default | kwargs shift_by_vector ( translation_vector , orb_id = None ) Shifts all orbitals with a specific tag by a given vector. Parameters: translation_vector ( list or Array ) \u2013 The vector by which to translate the orbital positions. orb_id \u2013 Identifier for the orbital(s) to shift. Note This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 @mutates def shift_by_vector ( self , translation_vector , orb_id = None ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: translation_vector (list or jax.Array): The vector by which to translate the orbital positions. orb_id: Identifier for the orbital(s) to shift. Note: This operation mutates the positions of the matched orbitals. \"\"\" filtered_orbs = self . filter_orbs ( orb_id , Orbital ) if orb_id is not None else self for orb in filtered_orbs : orb . position += jnp . array ( translation_vector ) transform_to_energy_basis ( observable ) Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the energy basis. Source code in src/granad/orbitals.py 893 894 895 896 897 898 899 900 901 902 903 904 def transform_to_energy_basis ( self , observable ): \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T ) transform_to_site_basis ( observable ) Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the site basis. Source code in src/granad/orbitals.py 881 882 883 884 885 886 887 888 889 890 891 def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors ) Params dataclass Stores parameters characterizing a given structure. Attributes: excitation ( Array ) \u2013 from state, to state, excited electrons eps ( float ) \u2013 Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5. beta ( float ) \u2013 Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to jax.numpy.inf by default, implying zero temperature. self_consistency_params ( dict ) \u2013 A dictionary to hold additional parameters required for self-consistency calculations within the simulation. Defaults to an empty dictionary. spin_degeneracy ( float ) \u2013 Factor to account for the degeneracy of spin states in the simulation. Typically set to 2, considering spin up and spin down. electrons ( Optional [ int ] ) \u2013 The total number of electrons in the structure. If not provided, it is assumed that the system's electron number needs to be calculated or is managed elsewhere. Note This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state of OrbitalList. Source code in src/granad/orbitals.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @dataclass class Params : \"\"\" Stores parameters characterizing a given structure. Attributes: excitation (jax.Array): from state, to state, excited electrons eps (float): Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5. beta (float): Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to `jax.numpy.inf` by default, implying zero temperature. self_consistency_params (dict): A dictionary to hold additional parameters required for self-consistency calculations within the simulation. Defaults to an empty dictionary. spin_degeneracy (float): Factor to account for the degeneracy of spin states in the simulation. Typically set to 2, considering spin up and spin down. electrons (Optional[int]): The total number of electrons in the structure. If not provided, it is assumed that the system's electron number needs to be calculated or is managed elsewhere. Note: This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state of OrbitalList. \"\"\" electrons : int excitation : list [ jax . Array ] = field ( default_factory = lambda : [ jnp . array ([ 0 ]), jnp . array ([ 0 ]), jnp . array ([ 0 ])]) eps : float = 1e-5 beta : float = jnp . inf self_consistency_params : dict = field ( default_factory = dict ) spin_degeneracy : float = 2.0 def __add__ ( self , other ): if isinstance ( other , Params ): return Params ( self . electrons + other . electrons ) raise ValueError TDResult dataclass A data class for storing the results of time-dependent simulations. Attributes: td_illumination ( Array ) \u2013 An array containing the time-dependent illumination function applied to the system, typically representing an external electromagnetic field. time_axis ( Array ) \u2013 An array representing the time points at which the simulation was evaluated. final_density_matrix ( Array ) \u2013 The resulting density matrix at the end of the simulation, representing the state of the system. output ( list [ Array ] ) \u2013 A list of arrays containing various output data from the simulation, such as observables over time. Source code in src/granad/orbitals.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 @dataclass class TDResult : \"\"\" A data class for storing the results of time-dependent simulations. Attributes: td_illumination (jax.Array): An array containing the time-dependent illumination function applied to the system, typically representing an external electromagnetic field. time_axis (jax.Array): An array representing the time points at which the simulation was evaluated. final_density_matrix (jax.Array): The resulting density matrix at the end of the simulation, representing the state of the system. output (list[jax.Array]): A list of arrays containing various output data from the simulation, such as observables over time. \"\"\" td_illumination : jax . Array time_axis : jax . Array final_density_matrix : jax . Array output : list [ jax . Array ] def ft_output ( self , omega_max , omega_min ): \"\"\" Computes the Fourier transform of each element in the output data across a specified frequency range. Args: omega_max (float): The maximum frequency bound for the Fourier transform. omega_min (float): The minimum frequency bound for the Fourier transform. Returns: list[jax.Array]: A list of Fourier transformed arrays corresponding to each element in the `output` attribute, evaluated over the specified frequency range. Note: This method applies a Fourier transform to each array in the `output` list to analyze the frequency components between `omega_min` and `omega_max`. \"\"\" ft = lambda o : _numerics . get_fourier_transform ( self . time_axis , o , omega_max , omega_min , False ) return [ ft ( o ) for o in self . output ] def ft_illumination ( self , omega_max , omega_min , return_omega_axis = True ): \"\"\" Calculates the Fourier transform of the time-dependent illumination function over a specified frequency range, with an option to return the frequency axis. Args: omega_max (float): The maximum frequency limit for the Fourier transform. omega_min (float): The minimum frequency limit for the Fourier transform. return_omega_axis (bool): If True, the function also returns the frequency axis along with the Fourier transformed illumination function. Defaults to True. Returns: jax.Array, optional[jax.Array]: The Fourier transformed illumination function. If `return_omega_axis` is True, a tuple containing the Fourier transformed data and the corresponding frequency axis is returned. Otherwise, only the Fourier transformed data is returned. \"\"\" return _numerics . get_fourier_transform ( self . time_axis , self . td_illumination , omega_max , omega_min , return_omega_axis ) def save ( self , name ): jnp . savez ( f \" { name } .npz\" , ** asdict ( self ) ) @classmethod def load ( cls , name ): with jnp . load ( f ' { name } .npz' ) as data : return cls ( ** data ) ft_illumination ( omega_max , omega_min , return_omega_axis = True ) Calculates the Fourier transform of the time-dependent illumination function over a specified frequency range, with an option to return the frequency axis. Parameters: omega_max ( float ) \u2013 The maximum frequency limit for the Fourier transform. omega_min ( float ) \u2013 The minimum frequency limit for the Fourier transform. return_omega_axis ( bool , default: True ) \u2013 If True, the function also returns the frequency axis along with the Fourier transformed illumination function. Defaults to True. Returns: \u2013 jax.Array, optional[jax.Array]: The Fourier transformed illumination function. If return_omega_axis is True, a tuple containing the Fourier transformed data and the corresponding frequency axis is returned. Otherwise, only the Fourier transformed data is returned. Source code in src/granad/orbitals.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def ft_illumination ( self , omega_max , omega_min , return_omega_axis = True ): \"\"\" Calculates the Fourier transform of the time-dependent illumination function over a specified frequency range, with an option to return the frequency axis. Args: omega_max (float): The maximum frequency limit for the Fourier transform. omega_min (float): The minimum frequency limit for the Fourier transform. return_omega_axis (bool): If True, the function also returns the frequency axis along with the Fourier transformed illumination function. Defaults to True. Returns: jax.Array, optional[jax.Array]: The Fourier transformed illumination function. If `return_omega_axis` is True, a tuple containing the Fourier transformed data and the corresponding frequency axis is returned. Otherwise, only the Fourier transformed data is returned. \"\"\" return _numerics . get_fourier_transform ( self . time_axis , self . td_illumination , omega_max , omega_min , return_omega_axis ) ft_output ( omega_max , omega_min ) Computes the Fourier transform of each element in the output data across a specified frequency range. Parameters: omega_max ( float ) \u2013 The maximum frequency bound for the Fourier transform. omega_min ( float ) \u2013 The minimum frequency bound for the Fourier transform. Returns: \u2013 list[jax.Array]: A list of Fourier transformed arrays corresponding to each element in the output attribute, evaluated over the specified frequency range. Note This method applies a Fourier transform to each array in the output list to analyze the frequency components between omega_min and omega_max . Source code in src/granad/orbitals.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def ft_output ( self , omega_max , omega_min ): \"\"\" Computes the Fourier transform of each element in the output data across a specified frequency range. Args: omega_max (float): The maximum frequency bound for the Fourier transform. omega_min (float): The minimum frequency bound for the Fourier transform. Returns: list[jax.Array]: A list of Fourier transformed arrays corresponding to each element in the `output` attribute, evaluated over the specified frequency range. Note: This method applies a Fourier transform to each array in the `output` list to analyze the frequency components between `omega_min` and `omega_max`. \"\"\" ft = lambda o : _numerics . get_fourier_transform ( self . time_axis , o , omega_max , omega_min , False ) return [ ft ( o ) for o in self . output ] Pulse ( amplitudes , frequency , peak , fwhm ) Function for computing temporally located time-harmonics electric fields. The pulse is implemented as a temporal Gaussian. Parameters: amplitudes ( list [ float ] ) \u2013 electric field amplitudes in xyz-components frequency ( float ) \u2013 frequency of the electric field peak ( float ) \u2013 time where the pulse reaches its peak fwhm ( float ) \u2013 full width at half maximum Returns: \u2013 Function that computes the electric field Source code in src/granad/fields.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def Pulse ( amplitudes : list [ float ], frequency : float , peak : float , fwhm : float , ): \"\"\"Function for computing temporally located time-harmonics electric fields. The pulse is implemented as a temporal Gaussian. Args: amplitudes: electric field amplitudes in xyz-components frequency: frequency of the electric field peak: time where the pulse reaches its peak fwhm: full width at half maximum Returns: Function that computes the electric field \"\"\" static_part = jnp . array ( amplitudes ) sigma = fwhm / ( 2.0 * jnp . sqrt ( jnp . log ( 2 ))) return lambda t : ( static_part * jnp . exp ( - 1 j * jnp . pi / 2 + 1 j * frequency * ( t - peak )) * jnp . exp ( - (( t - peak ) ** 2 ) / sigma ** 2 ) ) Ramp ( amplitudes , frequency , ramp_duration , time_ramp ) Function for computing ramping up time-harmonic electric fields. Parameters: amplitudes ( list [ float ] ) \u2013 electric field amplitudes in xyz-components frequency ( float ) \u2013 frequency ramp_duration ( float ) \u2013 specifies how long does the electric field ramps up time_ramp ( float ) \u2013 specifies time at which the field starts to ramp up Returns: \u2013 Function that computes the electric field as a functon of time Source code in src/granad/fields.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def Ramp ( amplitudes : list [ float ], frequency : float , ramp_duration : float , time_ramp : float , ): \"\"\"Function for computing ramping up time-harmonic electric fields. Args: amplitudes: electric field amplitudes in xyz-components frequency: frequency ramp_duration: specifies how long does the electric field ramps up time_ramp: specifies time at which the field starts to ramp up Returns: Function that computes the electric field as a functon of time \"\"\" static_part = jnp . array ( amplitudes ) p = 0.99 ramp_constant = 2 * jnp . log ( p / ( 1 - p )) / ramp_duration return lambda t : ( static_part * jnp . exp ( 1 j * frequency * t ) / ( 1 + 1.0 * jnp . exp ( - ramp_constant * ( t - time_ramp ))) ) Wave ( amplitudes , frequency ) Function for computing time-harmonic electric fields. Parameters: amplitudes ( list [ float ] ) \u2013 electric field amplitudes in xyz-components frequency ( float ) \u2013 frequency Returns: \u2013 Function that computes the electric field as a functon of time Source code in src/granad/fields.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def Wave ( amplitudes : list [ float ], frequency : float , ): \"\"\"Function for computing time-harmonic electric fields. Args: amplitudes: electric field amplitudes in xyz-components frequency: frequency Returns: Function that computes the electric field as a functon of time \"\"\" static_part = jnp . array ( amplitudes ) return lambda t : ( jnp . exp ( 1 j * frequency * t ) * static_part ) Material Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name ( str ) \u2013 The name of the material. species ( dict ) \u2013 Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals ( defaultdict [ list ] ) \u2013 A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions ( defaultdict [ dict ] ) \u2013 Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hamiltonian', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Note The Material class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hamiltonian and Coulomb interactions among these orbitals. graphene = ( Material ( \"graphene\" ) . lattice_constant ( 2.46 ) . lattice_basis ([ [ 1 , 0 , 0 ], [ - 0.5 , jnp . sqrt ( 3 ) / 2 , 0 ] ]) . add_orbital_species ( \"pz\" , l = 1 , atom = 'C' ) . add_orbital ( position = ( 0 , 0 ), tag = \"sublattice_1\" , species = \"pz\" ) . add_orbital ( position = ( - 1 / 3 , - 2 / 3 ), tag = \"sublattice_2\" , species = \"pz\" ) . add_interaction ( \"hamiltonian\" , participants = ( \"pz\" , \"pz\" ), parameters = [ 0.0 , 2.66 ], ) . add_interaction ( \"coulomb\" , participants = ( \"pz\" , \"pz\" ), parameters = [ 16.522 , 8.64 , 5.333 ], expression = lambda r : 1 / r + 0 j ) ) Source code in src/granad/materials.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 class Material : \"\"\" Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name (str): The name of the material. species (dict): Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals (defaultdict[list]): A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions (defaultdict[dict]): Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hamiltonian', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Note: The `Material` class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hamiltonian and Coulomb interactions among these orbitals. ```python graphene = ( Material(\"graphene\") .lattice_constant(2.46) .lattice_basis([ [1, 0, 0], [-0.5, jnp.sqrt(3)/2, 0] ]) .add_orbital_species(\"pz\", l=1, atom='C') .add_orbital(position=(0, 0), tag=\"sublattice_1\", species=\"pz\") .add_orbital(position=(-1/3, -2/3), tag=\"sublattice_2\", species=\"pz\") .add_interaction( \"hamiltonian\", participants=(\"pz\", \"pz\"), parameters=[0.0, 2.66], ) .add_interaction( \"coulomb\", participants=(\"pz\", \"pz\"), parameters=[16.522, 8.64, 5.333], expression=lambda r : 1/r + 0j ) ) ``` \"\"\" def __init__ ( self , name ): self . name = name self . species = {} self . orbitals = defaultdict ( list ) self . interactions = defaultdict ( dict ) self . _species_to_groups = {} self . dim = None def __str__ ( self ): description = f \"Material: { self . name } \\n \" if self . lattice_constant : description += f \" Lattice Constant: { self . lattice_constant } \u00c5 \\n \" if self . lattice_basis : description += f \" Lattice Basis: \\n { self . _lattice_basis } \\n \" if self . species : description += \" Orbital Species: \\n \" for species_name , attributes in self . species . items (): description += f \" { species_name } characterized by (n,l,m,s, atom name) = { attributes } \\n \" if self . orbitals : description += \" Orbitals: \\n \" for spec , orbs in self . orbitals . items (): for orb in orbs : description += f \" Position: { orb [ 'position' ] } , Tag: { orb [ 'tag' ] } , Species: { spec } \\n \" if self . interactions : description += \" Interactions: \\n \" for type_ , interaction in self . interactions . items (): for participants , coupling in interaction . items (): description += f \"\"\" Type: { type_ } , Participants: { participants } : NN Couplings: { ', ' . join ( map ( str , coupling [ 0 ])) } \"\"\" # Check if there's a docstring on the function if coupling [ 1 ] . __doc__ is not None : function_description = coupling [ 1 ] . __doc__ else : function_description = \"No description available for this function.\" description += f \"Other neighbors: { function_description } \\n \" return description def lattice_constant ( self , value ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . lattice_constant = value return self def lattice_basis ( self , values , periodic = None ): \"\"\" Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values (list of list of float): A list of vectors representing the lattice basis. periodic (list of int, optional): Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material: Returns self to enable method chaining. \"\"\" self . _lattice_basis = jnp . array ( values ) total = set ( range ( len ( self . _lattice_basis ))) periodic = set ( periodic ) if periodic is not None else total self . periodic = list ( periodic ) self . finite = list ( total - periodic ) self . dim = len ( self . periodic ) return self @_finalize def cut_flake ( self ): \"\"\" Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. \"\"\" pass def add_orbital ( self , position , species , tag = '' ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . orbitals [ species ] . append ({ 'position' : position , 'tag' : tag }) return self def add_orbital_species ( self , name , n = 0 , l = 0 , m = 0 , s = 0 , atom = '' ): \"\"\" Adds a species definition for orbitals in the material. Parameters: name (str): The name of the orbital species. n (int): Principal quantum number. l (int): Orbital angular momentum quantum number. m (int): Magnetic quantum number. s (int): Spin quantum number. atom (str, optional): Name of the atom the orbital belongs to. Returns: Material: Returns self to enable method chaining. \"\"\" self . species [ name ] = ( n , l , m , s , atom ) return self def add_interaction ( self , interaction_type , participants , parameters = None , expression = zero_coupling ): \"\"\" Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type (str): The type of interaction (e.g., 'hamiltonian', 'Coulomb'). participants (tuple): A tuple identifying the participants in the interaction. parameters (dict): Parameters relevant to the interaction. expression (function): A function defining the mathematical form of the interaction. Returns: Material: Returns self to enable method chaining. \"\"\" self . interactions [ interaction_type ][ participants ] = ( parameters if parameters is not None else [], expression ) return self def _get_positions_in_uc ( self , species = None ): if species is None : return jnp . array ( [ x [ \"position\" ] for orb in list ( self . orbitals . values ()) for x in orb ] ) return jnp . array ( [ orb_group [ 'position' ] for s in species for orb_group in self . orbitals [ s ] ] ) def _get_positions_in_lattice ( self , uc_positions , grid ): shift = jnp . array ( uc_positions ) @ self . _lattice_basis return self . lattice_constant * ( grid @ self . _lattice_basis + shift [:, None , :] ) . reshape ( shift . shape [ 0 ] * grid . shape [ 0 ], 3 ) def _get_grid ( self , ns ): grid = [( 1 ,) for i in range ( len ( self . finite ) + len ( self . periodic )) ] for i , p in enumerate ( self . periodic ): grid [ p ] = range ( * ns [ i ]) return jnp . array ( list ( product ( * ( x for x in grid ) ) ) ) def _keep_matching_positions ( self , positions , candidates ): idxs = ( jnp . round ( jnp . linalg . norm ( positions - candidates [:, None ], axis =- 1 ), 4 ) == 0 ) . nonzero ()[ 0 ] return candidates [ idxs ] def _couplings_to_function ( self , couplings , outside_fun , species ): if len ( couplings ) == 0 : return outside_fun couplings = jnp . array ( couplings ) . astype ( complex ) grid = self . _get_grid ( [ ( 0 , len ( couplings )) for i in range ( self . dim ) ] ) pos_uc_1 = self . _get_positions_in_uc ( ( species [ 0 ],) ) pos_uc_2 = self . _get_positions_in_uc ( ( species [ 1 ],) ) positions_1 = self . _get_positions_in_lattice ( pos_uc_1 , grid ) positions_2 = self . _get_positions_in_lattice ( pos_uc_2 , grid ) distances = jnp . unique ( jnp . round ( jnp . linalg . norm ( positions_1 - positions_2 [:, None , :], axis = 2 ), 5 ) )[: len ( couplings )] def inner ( d ): return jax . lax . cond ( jnp . min ( jnp . abs ( d - distances )) < 1e-5 , lambda x : couplings [ jnp . argmin ( jnp . abs ( x - distances ))], outside_fun , d , ) return inner def _set_couplings ( self , setter_func , interaction_type ): interaction_dict = self . interactions [ interaction_type ] for ( species_1 , species_2 ), couplings in interaction_dict . items (): distance_func = self . _couplings_to_function ( * couplings , ( species_1 , species_2 ) ) setter_func ( self . _species_to_groups [ species_1 ], self . _species_to_groups [ species_2 ], distance_func ) def _get_orbital_list ( self , allowed_positions , grid ): raw_list , layer_index = [], 0 for species , orb_group in self . orbitals . items (): for orb_uc in orb_group : uc_positions = jnp . array ( [ orb_uc [ 'position' ]] ) rs_positions = self . _get_positions_in_lattice ( uc_positions , grid ) final_positions = self . _keep_matching_positions ( allowed_positions , rs_positions ) for position in final_positions : orb = Orbital ( position = position , layer_index = layer_index , tag = orb_uc [ 'tag' ], group_id = self . _species_to_groups [ species ], energy_level = self . species [ species ][ 0 ], angular_momentum = self . species [ species ][ 1 ], angular_momentum_z = self . species [ species ][ 2 ], spin = self . species [ species ][ 3 ], atom_name = self . species [ species ][ 4 ] ) layer_index += 1 raw_list . append ( orb ) orbital_list = OrbitalList ( raw_list ) self . _set_couplings ( orbital_list . set_hamiltonian_groups , \"hamiltonian\" ) self . _set_couplings ( orbital_list . set_coulomb_groups , \"coulomb\" ) return orbital_list add_interaction ( interaction_type , participants , parameters = None , expression = zero_coupling ) Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type ( str ) \u2013 The type of interaction (e.g., 'hamiltonian', 'Coulomb'). participants ( tuple ) \u2013 A tuple identifying the participants in the interaction. parameters ( dict , default: None ) \u2013 Parameters relevant to the interaction. expression ( function , default: zero_coupling ) \u2013 A function defining the mathematical form of the interaction. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def add_interaction ( self , interaction_type , participants , parameters = None , expression = zero_coupling ): \"\"\" Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type (str): The type of interaction (e.g., 'hamiltonian', 'Coulomb'). participants (tuple): A tuple identifying the participants in the interaction. parameters (dict): Parameters relevant to the interaction. expression (function): A function defining the mathematical form of the interaction. Returns: Material: Returns self to enable method chaining. \"\"\" self . interactions [ interaction_type ][ participants ] = ( parameters if parameters is not None else [], expression ) return self add_orbital ( position , species , tag = '' ) Sets the lattice constant for the material. Parameters: value ( float ) \u2013 The lattice constant value. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 354 355 356 357 358 359 360 361 362 363 364 365 def add_orbital ( self , position , species , tag = '' ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . orbitals [ species ] . append ({ 'position' : position , 'tag' : tag }) return self add_orbital_species ( name , n = 0 , l = 0 , m = 0 , s = 0 , atom = '' ) Adds a species definition for orbitals in the material. Parameters: name ( str ) \u2013 The name of the orbital species. n ( int , default: 0 ) \u2013 Principal quantum number. l ( int , default: 0 ) \u2013 Orbital angular momentum quantum number. m ( int , default: 0 ) \u2013 Magnetic quantum number. s ( int , default: 0 ) \u2013 Spin quantum number. atom ( str , default: '' ) \u2013 Name of the atom the orbital belongs to. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 def add_orbital_species ( self , name , n = 0 , l = 0 , m = 0 , s = 0 , atom = '' ): \"\"\" Adds a species definition for orbitals in the material. Parameters: name (str): The name of the orbital species. n (int): Principal quantum number. l (int): Orbital angular momentum quantum number. m (int): Magnetic quantum number. s (int): Spin quantum number. atom (str, optional): Name of the atom the orbital belongs to. Returns: Material: Returns self to enable method chaining. \"\"\" self . species [ name ] = ( n , l , m , s , atom ) return self cut_flake () Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. Source code in src/granad/materials.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 @_finalize def cut_flake ( self ): \"\"\" Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. \"\"\" pass lattice_basis ( values , periodic = None ) Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values ( list of list of float ) \u2013 A list of vectors representing the lattice basis. periodic ( list of int , default: None ) \u2013 Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def lattice_basis ( self , values , periodic = None ): \"\"\" Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values (list of list of float): A list of vectors representing the lattice basis. periodic (list of int, optional): Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material: Returns self to enable method chaining. \"\"\" self . _lattice_basis = jnp . array ( values ) total = set ( range ( len ( self . _lattice_basis ))) periodic = set ( periodic ) if periodic is not None else total self . periodic = list ( periodic ) self . finite = list ( total - periodic ) self . dim = len ( self . periodic ) return self lattice_constant ( value ) Sets the lattice constant for the material. Parameters: value ( float ) \u2013 The lattice constant value. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 302 303 304 305 306 307 308 309 310 311 312 313 def lattice_constant ( self , value ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . lattice_constant = value return self MaterialCatalog A class to manage and access built-in material properties within a simulation or modeling framework. This class provides a central repository for predefined materials, allowing for easy retrieval and description of their properties. Attributes: _materials ( dict ) \u2013 A private dictionary that maps material names to their respective data objects. This dictionary is pre-populated with several example materials such as graphene and MoS2. Methods: Name Description get Retrieves the data object associated with the given material name. describe Prints a description or the data object of the specified material. available Prints a list of all available materials stored in the catalog. Source code in src/granad/materials.py 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 class MaterialCatalog : \"\"\" A class to manage and access built-in material properties within a simulation or modeling framework. This class provides a central repository for predefined materials, allowing for easy retrieval and description of their properties. Attributes: _materials (dict): A private dictionary that maps material names to their respective data objects. This dictionary is pre-populated with several example materials such as graphene and MoS2. Methods: get(material): Retrieves the data object associated with the given material name. describe(material): Prints a description or the data object of the specified material. available(): Prints a list of all available materials stored in the catalog. \"\"\" _materials = { \"graphene\" : _graphene , \"ssh\" : _ssh , \"metal_1d\" : _metal_1d , \"MoS2\" : _MoS2 , \"hBN\" : _hBN } @staticmethod def get ( material : str ): \"\"\" Retrieves the material data object for the specified material. Args: material (str): The name of the material to retrieve. Returns: The data object associated with the specified material. Example: ```python graphene_data = MaterialCatalog.get('graphene') ``` \"\"\" return MaterialCatalog . _materials [ material ] @staticmethod def describe ( material : str ): \"\"\" Prints a description or the raw data of the specified material from the catalog. Args: material (str): The name of the material to describe. Example: ```python MaterialCatalog.describe('graphene') ``` \"\"\" print ( MaterialCatalog . _materials [ material ]) @staticmethod def available (): \"\"\" Prints a list of all materials available in the catalog. Example: ```python MaterialCatalog.available() ``` \"\"\" available_materials = \" \\n \" . join ( MaterialCatalog . _materials . keys ()) print ( f \"Available materials: \\n { available_materials } \" ) available () staticmethod Prints a list of all materials available in the catalog. Example MaterialCatalog . available () Source code in src/granad/materials.py 699 700 701 702 703 704 705 706 707 708 709 710 @staticmethod def available (): \"\"\" Prints a list of all materials available in the catalog. Example: ```python MaterialCatalog.available() ``` \"\"\" available_materials = \" \\n \" . join ( MaterialCatalog . _materials . keys ()) print ( f \"Available materials: \\n { available_materials } \" ) describe ( material ) staticmethod Prints a description or the raw data of the specified material from the catalog. Parameters: material ( str ) \u2013 The name of the material to describe. Example MaterialCatalog . describe ( 'graphene' ) Source code in src/granad/materials.py 684 685 686 687 688 689 690 691 692 693 694 695 696 697 @staticmethod def describe ( material : str ): \"\"\" Prints a description or the raw data of the specified material from the catalog. Args: material (str): The name of the material to describe. Example: ```python MaterialCatalog.describe('graphene') ``` \"\"\" print ( MaterialCatalog . _materials [ material ]) get ( material ) staticmethod Retrieves the material data object for the specified material. Parameters: material ( str ) \u2013 The name of the material to retrieve. Returns: \u2013 The data object associated with the specified material. Example graphene_data = MaterialCatalog . get ( 'graphene' ) Source code in src/granad/materials.py 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 @staticmethod def get ( material : str ): \"\"\" Retrieves the material data object for the specified material. Args: material (str): The name of the material to retrieve. Returns: The data object associated with the specified material. Example: ```python graphene_data = MaterialCatalog.get('graphene') ``` \"\"\" return MaterialCatalog . _materials [ material ] cut_flake_1d ( material , unit_cells , plot = False ) Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. unit_cells ( int ) \u2013 The number of unit cells to include in the flake. plot ( bool , default: False ) \u2013 If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list \u2013 A list of orbitals positioned within the specified range of the material's lattice. Note The function utilizes internal methods of the Material class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. Source code in src/granad/materials.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def cut_flake_1d ( material , unit_cells , plot = False ): \"\"\" Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material (Material): The material instance from which to cut the flake. unit_cells (int): The number of unit cells to include in the flake. plot (bool, optional): If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list: A list of orbitals positioned within the specified range of the material's lattice. Note: The function utilizes internal methods of the `Material` class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. \"\"\" orbital_positions_uc = material . _get_positions_in_uc () grid = material . _get_grid ( [( 0 , unit_cells )] ) orbital_positions = material . _get_positions_in_lattice ( orbital_positions_uc , grid ) if plot : _display_lattice_cut ( orbital_positions , orbital_positions ) orbital_positions = jnp . unique ( orbital_positions , axis = 0 ) return material . _get_orbital_list ( orbital_positions , grid ) cut_flake_2d ( material , polygon , plot = False , minimum_neighbor_number = 2 ) Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. polygon ( array - like ) \u2013 An array of coordinates defining the vertices of the polygon within which to cut the flake. plot ( bool , default: False ) \u2013 If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number ( int , default: 2 ) \u2013 The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list \u2013 A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Note The function assumes the underlying lattice to be in the xy-plane. Source code in src/granad/materials.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def cut_flake_2d ( material , polygon , plot = False , minimum_neighbor_number : int = 2 ): \"\"\" Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material (Material): The material instance from which to cut the flake. polygon (array-like): An array of coordinates defining the vertices of the polygon within which to cut the flake. plot (bool, optional): If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number (int, optional): The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list: A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Note: The function assumes the underlying lattice to be in the xy-plane. \"\"\" def _prune_neighbors ( positions , minimum_neighbor_number , remaining_old = jnp . inf ): \"\"\" Recursively prunes positions to ensure each position has a sufficient number of neighboring positions based on a minimum distance calculated from the unique set of distances between positions. Parameters: positions (array-like): Array of positions to prune. minimum_neighbor_number (int): Minimum required number of neighbors for a position to be retained. remaining_old (int): The count of positions remaining from the previous iteration; used to detect convergence. Returns: array-like: Array of positions that meet the neighbor count criterion. \"\"\" if minimum_neighbor_number <= 0 : return positions distances = jnp . round ( jnp . linalg . norm ( positions [:, material . periodic ] - positions [:, None , material . periodic ], axis =- 1 ), 4 ) minimum = jnp . unique ( distances )[ 1 ] mask = ( distances <= minimum ) . sum ( axis = 0 ) > minimum_neighbor_number remaining = mask . sum () if remaining_old == remaining : return positions [ mask ] else : return _prune_neighbors ( positions [ mask ], minimum_neighbor_number , remaining ) # to cover the plane, we solve the linear equation P = L C, where P are the polygon vertices, L is the lattice basis and C are the coefficients L = material . _lattice_basis [ material . periodic ,: 2 ] * material . lattice_constant coeffs = jnp . linalg . inv ( L . T ) @ polygon . T # we just take the largest extent of the shape u1 , u2 = jnp . ceil ( coeffs ) . max ( axis = 1 ) l1 , l2 = jnp . floor ( coeffs ) . min ( axis = 1 ) grid = material . _get_grid ( [ ( int ( l1 ), int ( u1 )), ( int ( l2 ), int ( u2 )) ] ) # get atom positions in the unit cell in fractional coordinates orbital_positions = material . _get_positions_in_uc () unit_cell_fractional_atom_positions = jnp . unique ( jnp . round ( orbital_positions , 6 ), axis = 0 ) initial_atom_positions = material . _get_positions_in_lattice ( unit_cell_fractional_atom_positions , grid ) polygon_path = Path ( polygon ) flags = polygon_path . contains_points ( initial_atom_positions [:, : 2 ]) # get atom positions where every atom has at least minimum_neighbor_number neighbors final_atom_positions = _prune_neighbors ( initial_atom_positions [ flags ], minimum_neighbor_number ) if plot == True : _display_lattice_cut ( initial_atom_positions , final_atom_positions , polygon ) return material . _get_orbital_list ( final_atom_positions , grid ) cut_flake_generic ( material , grid_range ) Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. grid_range ( list of tuples ) \u2013 Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list \u2013 A list of orbitals within the specified grid range, uniquely positioned. Note The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. Source code in src/granad/materials.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def cut_flake_generic ( material , grid_range ): \"\"\" Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material (Material): The material instance from which to cut the flake. grid_range (list of tuples): Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list: A list of orbitals within the specified grid range, uniquely positioned. Note: The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. \"\"\" orbital_positions_uc = material . _get_positions_in_uc () grid = material . _get_grid ( grid_range ) orbital_positions = material . _get_positions_in_lattice ( orbital_positions_uc , grid ) orbital_positions = jnp . unique ( orbital_positions , axis = 0 ) return material . _get_orbital_list ( orbital_positions , grid ) ohno_potential ( offset = 0 , start = 14.399 ) Generates a callable that represents a regularized Coulomb-like potential. The potential function is parameterized to provide flexibility in adjusting the starting value and an offset, which can be used to avoid singularities at zero distance. Parameters: offset ( float , default: 0 ) \u2013 The offset added to the distance to prevent division by zero and to regularize the potential at short distances. Defaults to 0. start ( float , default: 14.399 ) \u2013 The initial strength or scaling factor of the potential. Defaults to 14.399. Returns: \u2013 Callable[[float], complex]: A function that takes a distance 'd' and returns the computed Coulomb-like potential as a complex number. Note potential = ohno_potential () print ( potential ( 1 )) # Output: (14.399 + 0j) if default parameters used Source code in src/granad/materials.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def ohno_potential ( offset = 0 , start = 14.399 ): \"\"\" Generates a callable that represents a regularized Coulomb-like potential. The potential function is parameterized to provide flexibility in adjusting the starting value and an offset, which can be used to avoid singularities at zero distance. Args: offset (float): The offset added to the distance to prevent division by zero and to regularize the potential at short distances. Defaults to 0. start (float): The initial strength or scaling factor of the potential. Defaults to 14.399. Returns: Callable[[float], complex]: A function that takes a distance 'd' and returns the computed Coulomb-like potential as a complex number. Note: ```python potential = ohno_potential() print(potential(1)) # Output: (14.399 + 0j) if default parameters used ``` \"\"\" def inner ( d ): \"\"\"Coupling with a (regularized) Coulomb-like potential\"\"\" return start / ( d + offset ) + 0 j return inner zero_coupling ( d ) Returns a zero coupling constant as a complex number. Parameters: d ( float ) \u2013 A parameter (typically representing distance or some other factor) that is ignored by the function, as the output is always zero. Returns: complex \u2013 Returns 0.0 as a complex number (0.0j). Source code in src/granad/materials.py 15 16 17 18 19 20 21 22 23 24 25 def zero_coupling ( d ): \"\"\" Returns a zero coupling constant as a complex number. Args: d (float): A parameter (typically representing distance or some other factor) that is ignored by the function, as the output is always zero. Returns: complex: Returns 0.0 as a complex number (0.0j). \"\"\" return 0.0 j Circle ( radius , n_vertices = 8 ) Generates the vertices of a polygon that approximates a circle, given the radius and the number of vertices. The circle approximation is created by calculating points along the circumference using the radius provided. The number of vertices specifies how many sides the polygon will have, thus controlling the granularity of the approximation. By default, an octagon is generated. Parameters: radius ( float ) \u2013 The radius of the circle to approximate, in arbitrary units. n_vertices ( int , default: 8 ) \u2013 The number of vertices (or sides) of the approximating polygon. Default is 8. Returns: \u2013 jax.numpy.ndarray: An array of shape (n_vertices+1, 2), representing the vertices of the polygon, including the first vertex repeated at the end to close the shape. Note The accuracy of the circle approximation improves with an increase in the number of vertices. For a smoother circle, increase the number of vertices. # Create an approximate circle with a radius of 20 units and default vertices circle_octagon = Circle ( 20 ) # Create an approximate circle with a radius of 15 units using 12 vertices circle_dodecagon = Circle ( 15 , 12 ) Source code in src/granad/shapes.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def Circle ( radius , n_vertices = 8 ): \"\"\" Generates the vertices of a polygon that approximates a circle, given the radius and the number of vertices. The circle approximation is created by calculating points along the circumference using the radius provided. The number of vertices specifies how many sides the polygon will have, thus controlling the granularity of the approximation. By default, an octagon is generated. Parameters: radius (float): The radius of the circle to approximate, in arbitrary units. n_vertices (int): The number of vertices (or sides) of the approximating polygon. Default is 8. Returns: jax.numpy.ndarray: An array of shape (n_vertices+1, 2), representing the vertices of the polygon, including the first vertex repeated at the end to close the shape. Note: The accuracy of the circle approximation improves with an increase in the number of vertices. For a smoother circle, increase the number of vertices. ```python # Create an approximate circle with a radius of 20 units and default vertices circle_octagon = Circle(20) # Create an approximate circle with a radius of 15 units using 12 vertices circle_dodecagon = Circle(15, 12) ``` \"\"\" circle = jnp . array ([ ( radius * jnp . cos ( 2 * jnp . pi * i / n_vertices ), radius * jnp . sin ( 2 * jnp . pi * i / n_vertices )) for i in range ( n_vertices ) ]) return jnp . vstack ([ circle , circle [ 0 ]]) Hexagon ( length ) Generates the vertices of a regular hexagon given the side length. The hexagon is oriented such that one vertex points upwards and the function is designed to be used with the @_edge_type decorator for positional adjustments and rotations. Parameters: length ( float ) \u2013 The length of each side of the hexagon, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (7, 2), representing the vertices of the hexagon, including the starting vertex repeated at the end for drawing closed shapes. Note # Hexagon with side length of 1.0 angstrom hexagon = Hexagon ( 1.0 ) Source code in src/granad/shapes.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @_edge_type def Hexagon ( length ): \"\"\" Generates the vertices of a regular hexagon given the side length. The hexagon is oriented such that one vertex points upwards and the function is designed to be used with the @_edge_type decorator for positional adjustments and rotations. Parameters: length (float): The length of each side of the hexagon, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (7, 2), representing the vertices of the hexagon, including the starting vertex repeated at the end for drawing closed shapes. Note: ```python # Hexagon with side length of 1.0 angstrom hexagon = Hexagon(1.0) ``` \"\"\" n = 6 s = 1 angle = 2 * jnp . pi / n vertices = length * jnp . array ( [ ( s * jnp . cos ( i * angle ), s * jnp . sin ( i * angle )) for i in [ x for x in range ( n )] + [ 0 ] ] ) return vertices Rectangle ( length_x , length_y ) Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x ( float ) \u2013 The length of the rectangle along the x-axis, specified in angstroms. length_y ( float ) \u2013 The length of the rectangle along the y-axis, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Note # Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle ( 2.0 , 1.0 ) Source code in src/granad/shapes.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @_edge_type def Rectangle ( length_x , length_y ): \"\"\" Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x (float): The length of the rectangle along the x-axis, specified in angstroms. length_y (float): The length of the rectangle along the y-axis, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Note: ```python # Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle(2.0, 1.0) ``` \"\"\" vertices = jnp . array ( [ ( - 1 * length_x , - 0.5 * length_y ), ( 1 * length_x , - 0.5 * length_y ), ( 1 * length_x , 0.5 * length_y ), ( - 1 * length_x , 0.5 * length_y ), ( - 1 * length_x , - 0.5 * length_y ), ] ) return vertices Rhomboid ( base , height ) Generates the vertices of a rhomboid given the base length and height. The rhomboid is initially oriented with the base along the x-axis, and one angle being 30 degrees, designed to be adjusted for position and orientation using the @_edge_type decorator. Parameters: base ( float ) \u2013 The length of the base of the rhomboid, specified in angstroms. height ( float ) \u2013 The vertical height of the rhomboid, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rhomboid, starting and ending at the same vertex to complete the shape. Note # Rhomboid with base 2.0 angstroms and height 1.0 angstrom rhomboid = Rhomboid ( 2.0 , 1.0 ) Source code in src/granad/shapes.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 @_edge_type def Rhomboid ( base , height ): \"\"\" Generates the vertices of a rhomboid given the base length and height. The rhomboid is initially oriented with the base along the x-axis, and one angle being 30 degrees, designed to be adjusted for position and orientation using the @_edge_type decorator. Parameters: base (float): The length of the base of the rhomboid, specified in angstroms. height (float): The vertical height of the rhomboid, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rhomboid, starting and ending at the same vertex to complete the shape. Note: ```python # Rhomboid with base 2.0 angstroms and height 1.0 angstrom rhomboid = Rhomboid(2.0, 1.0) ``` \"\"\" angle = jnp . radians ( 30 ) vertices = jnp . array ( [ ( 0 , 0 ), ( base , 0 ), ( base + height * jnp . sin ( angle ), height * jnp . cos ( angle )), ( height * jnp . sin ( angle ), height * jnp . cos ( angle )), ( 0 , 0 ), ] ) return vertices Triangle ( side_length ) Generates the vertices of an equilateral triangle given the side length. The triangle is oriented such that one vertex points upwards and the base is horizontal. This function is designed to be used with the @_edge_type decorator, which adds functionality to shift the triangle's position or rotate it based on additional 'shift' and 'armchair' parameters passed to the function. Parameters: side_length ( float ) \u2013 The length of each side of the triangle, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (4, 2), representing the vertices of the triangle, including the starting vertex repeated at the end to facilitate drawing closed shapes. Note # Create a triangle with side length of 1.0 angstrom, no shift or rotation triangle = Triangle ( 1.0 ) # Create a triangle with side length of 1.0 angstrom, shifted by [1, 1] units triangle_shifted = Triangle ( 1.0 , shift = [ 1 , 1 ]) # Create a triangle with side length of 1.0 angstrom, rotated by 90 degrees (armchair orientation) triangle_rotated = Triangle ( 1.0 , armchair = True ) Source code in src/granad/shapes.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @_edge_type def Triangle ( side_length ): \"\"\" Generates the vertices of an equilateral triangle given the side length. The triangle is oriented such that one vertex points upwards and the base is horizontal. This function is designed to be used with the @_edge_type decorator, which adds functionality to shift the triangle's position or rotate it based on additional 'shift' and 'armchair' parameters passed to the function. Parameters: side_length (float): The length of each side of the triangle, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (4, 2), representing the vertices of the triangle, including the starting vertex repeated at the end to facilitate drawing closed shapes. Note: ```python # Create a triangle with side length of 1.0 angstrom, no shift or rotation triangle = Triangle(1.0) # Create a triangle with side length of 1.0 angstrom, shifted by [1, 1] units triangle_shifted = Triangle(1.0, shift=[1, 1]) # Create a triangle with side length of 1.0 angstrom, rotated by 90 degrees (armchair orientation) triangle_rotated = Triangle(1.0, armchair=True) ``` \"\"\" vertices = side_length * jnp . array ( [ ( 0 , jnp . sqrt ( 3 ) / 3 ), ( - 0.5 , - jnp . sqrt ( 3 ) / 6 ), ( 0.5 , - jnp . sqrt ( 3 ) / 6 ), ( 0 , jnp . sqrt ( 3 ) / 3 ), ] ) return vertices BareHamiltonian () Represents the unperturbed single-particle tight-binding mean field Hamiltonian, denoted as \\(= h^{(0)}\\) . Returns: Function \u2013 Provides the bare Hamiltonian matrix, representing the unperturbed state of the system. Source code in src/granad/potentials.py 152 153 154 155 156 157 158 def BareHamiltonian (): \"\"\"Represents the unperturbed single-particle tight-binding mean field Hamiltonian, denoted as $= h^{(0)}$. Returns: Function: Provides the bare Hamiltonian matrix, representing the unperturbed state of the system. \"\"\" return lambda t , r , args : args . hamiltonian Coulomb () Calculates the induced Coulomb potential based on deviations from a stationary density matrix, represented as \\(\\sim \\lambda C(\\rho-\\rho_0)\\) . Here, \\(\\lambda\\) is a scaling factor. Returns: Function \u2013 Computes the Coulomb interaction scaled by deviations from the stationary state. Source code in src/granad/potentials.py 144 145 146 147 148 149 150 def Coulomb (): \"\"\"Calculates the induced Coulomb potential based on deviations from a stationary density matrix, represented as $\\sim \\lambda C(\\\\rho-\\\\rho_0)$. Here, $\\lambda$ is a scaling factor. Returns: Function: Computes the Coulomb interaction scaled by deviations from the stationary state. \"\"\" return lambda t , r , args : jnp . diag ( args . coulomb_scaled @ ( r - args . stationary_density_matrix ) . diagonal () * args . electrons ) Diamagnetic ( vector_potential ) Diamagnetic Coulomb gauge coupling to an external vector potential represented as \\(\\sim A^2\\) . Parameters: vector_potential ( callable ) \u2013 Function that returns the vector potential at a given time. Returns: Function \u2013 Computes the square of the vector potential, representing diamagnetic interactions. Source code in src/granad/potentials.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def Diamagnetic ( vector_potential ): \"\"\"Diamagnetic Coulomb gauge coupling to an external vector potential represented as $\\sim A^2$. Args: vector_potential (callable): Function that returns the vector potential at a given time. Returns: Function: Computes the square of the vector potential, representing diamagnetic interactions. \"\"\" def inner ( t , r , args ): # ~ A^2 q = m = 1 return jnp . diag ( q ** 2 / m * 0.5 * jnp . sum ( vector_potential ( t ) ** 2 , axis = 1 )) return inner DipoleGauge ( illumination , use_rwa = False , intra_only = False ) Dipole gauge coupling to an external electric field, represented as \\(E \\cdot \\hat{P}\\) . The dipole / polarization operator is defined by \\(P^{c}_{ij} = <i|\\hat{r}_c|j>\\) , where \\(i,j\\) correspond to localized (TB) orbitals, such that \\(\\hat{r}^c|i> = r^c{i}|i>\\) in absence of dipole transitions. Parameters: illumination ( callable ) \u2013 Function that returns the electric field at a given time. use_rwa ( bool , default: False ) \u2013 If True, uses the rotating wave approximation which simplifies the calculations by considering only resonant terms. intra_only ( bool , default: False ) \u2013 If True, subtracts the diagonal of the potential matrix, focusing only on the interactions between different elements. Returns: Function \u2013 Computes the electric potential based on the given illumination and options for RWA and intramolecular interactions. Source code in src/granad/potentials.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def DipoleGauge ( illumination , use_rwa = False , intra_only = False ): \"\"\"Dipole gauge coupling to an external electric field, represented as $E \\cdot \\hat{P}$. The dipole / polarization operator is defined by $P^{c}_{ij} = <i|\\hat{r}_c|j>$, where $i,j$ correspond to localized (TB) orbitals, such that $\\hat{r}^c|i> = r^c{i}|i>$ in absence of dipole transitions. Args: illumination (callable): Function that returns the electric field at a given time. use_rwa (bool): If True, uses the rotating wave approximation which simplifies the calculations by considering only resonant terms. intra_only (bool): If True, subtracts the diagonal of the potential matrix, focusing only on the interactions between different elements. Returns: Function: Computes the electric potential based on the given illumination and options for RWA and intramolecular interactions. \"\"\" def electric_potential ( t , r , args ): return jnp . einsum ( einsum_string , args . dipole_operator , illumination ( t ) . real ) def electric_potential_rwa ( t , r , args ): # the missing real part is crucial here! the RWA (for real dipole moments) makes the fields complex and divides by 2 total_field_potential = jnp . einsum ( einsum_string , args . dipole_operator , illumination ( t )) # Get the indices for the lower triangle, excluding the diagonal lower_indices = jnp . tril_indices ( total_field_potential . shape [ 0 ], - 1 ) # Replace elements in the lower triangle with their complex conjugates tmp = total_field_potential . at [ lower_indices ] . set ( jnp . conj ( total_field_potential [ lower_indices ]) ) # make hermitian again return tmp - 1 j * jnp . diag ( tmp . diagonal () . imag ) # TODO: redundant evaluation maybe_diag = lambda f : f if intra_only == True : maybe_diag = lambda f : lambda t , r , args : f ( t , r , args ) - jnp . diag ( f ( t , r , args ) . diagonal () ) einsum_string = 'Kij,K->ij' if illumination ( 0. ) . shape == ( 3 ,) else 'Kij,iK->ij' if use_rwa == True : return maybe_diag ( electric_potential_rwa ) return maybe_diag ( electric_potential ) DipolePulse ( dipole_moment , source_location , omega , sigma , t0 = 0.0 , kick = False ) Function to compute the potential due to a pulsed dipole. The potential can optionally include a 'kick' which is an instantaneous spike at a specific time. Parameters: dipole_moment \u2013 Vector representing the dipole moment in xyz-components. source_location \u2013 Location of the source of the dipole in xyz-coordinates. omega \u2013 Angular frequency of the oscillation. sigma \u2013 Standard deviation of the pulse's temporal Gaussian profile. t0 \u2013 Time at which the pulse is centered (default is 0.0). kick \u2013 If True, adds an instantaneous spike to the pulse at time t0 (default is False). Returns: \u2013 Function that computes the dipole potential at a given time and location, with adjustments for distance and orientation relative to the dipole. Note Recommended only with solver=diffrax.Dopri8. Source code in src/granad/potentials.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def DipolePulse ( dipole_moment , source_location , omega , sigma , t0 = 0.0 , kick = False ): \"\"\"Function to compute the potential due to a pulsed dipole. The potential can optionally include a 'kick' which is an instantaneous spike at a specific time. Args: dipole_moment: Vector representing the dipole moment in xyz-components. source_location: Location of the source of the dipole in xyz-coordinates. omega: Angular frequency of the oscillation. sigma: Standard deviation of the pulse's temporal Gaussian profile. t0: Time at which the pulse is centered (default is 0.0). kick: If True, adds an instantaneous spike to the pulse at time t0 (default is False). Returns: Function that computes the dipole potential at a given time and location, with adjustments for distance and orientation relative to the dipole. Note: Recommended only with solver=diffrax.Dopri8. \"\"\" loc = jnp . array ( source_location )[:, None ] dip = jnp . array ( dipole_moment ) f = lambda t : jnp . cos ( omega * t ) * jnp . exp ( - ( t - t0 ) ** 2 / sigma ** 2 ) if kick == True : f = lambda t : jnp . abs ( t - t0 ) < 1e-10 def pot ( t , r , args ): distances = args . dipole_operator . diagonal ( axis1 =- 1 , axis2 =- 2 ) - loc r_term = ( dip @ distances ) / jnp . linalg . norm ( distances , axis = 0 ) return jnp . diag ( jnp . nan_to_num ( r_term ) * f ( t ) ) return pot Induced () Calculates the induced potential, which propagates the coulomb effect of induced charges in the system according to \\(\\sim \\sum_r q_r/|r-r'|\\) . Returns: Function \u2013 Computes the induced potential at a given time and location based on charge propagation. Source code in src/granad/potentials.py 103 104 105 106 107 108 109 110 111 112 def Induced (): \"\"\"Calculates the induced potential, which propagates the coulomb effect of induced charges in the system according to $\\sim \\sum_r q_r/|r-r'|$. Returns: Function: Computes the induced potential at a given time and location based on charge propagation. \"\"\" def inner ( t , r , args ): field = jnp . einsum ( \"ijK,j->iK\" , args . propagator , - args . electrons * r . diagonal ()) return jnp . einsum ( \"Kij,iK->ij\" , args . dipole_operator , field . real ) return inner Paramagnetic ( vector_potential ) Paramagnetic Coulomb gauge coupling to an external vector potential represented as \\(\\sim A \\hat{v}\\) . Parameters: vector_potential ( callable ) \u2013 Function that returns the vector potential at a given time. Returns: Function \u2013 Computes the interaction of the vector potential with the velocity operator. Source code in src/granad/potentials.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def Paramagnetic ( vector_potential ): \"\"\"Paramagnetic Coulomb gauge coupling to an external vector potential represented as $\\sim A \\hat{v}$. Args: vector_potential (callable): Function that returns the vector potential at a given time. Returns: Function: Computes the interaction of the vector potential with the velocity operator. \"\"\" def inner ( t , r , args ): # ~ A p q = 1 return - q * jnp . einsum ( \"Kij, iK -> ij\" , args . velocity_operator , vector_potential ( t )) return inner WavePulse ( amplitudes , omega , sigma , t0 = 0.0 , kick = False ) Function to compute the wave potential using amplitude modulation. This function creates a pulse with temporal Gaussian characteristics and can include an optional 'kick' which introduces an instantaneous amplitude peak. Parameters: amplitudes \u2013 List of amplitudes for the wave components in xyz-directions. omega \u2013 Angular frequency of the wave oscillation. sigma \u2013 Standard deviation of the Gaussian pulse in time. t0 \u2013 Central time around which the pulse peaks (default is 0.0). kick \u2013 If set to True, an instantaneous spike is added to the pulse at time t0 instead of the Gaussian modulated cosine wave (default is False). Returns: \u2013 Function that computes the potential at a given time and location, incorporating the wave characteristics and specified modulations. Note This function, when not kicked, computes the same term as Pulse . Source code in src/granad/potentials.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def WavePulse ( amplitudes , omega , sigma , t0 = 0.0 , kick = False ): \"\"\"Function to compute the wave potential using amplitude modulation. This function creates a pulse with temporal Gaussian characteristics and can include an optional 'kick' which introduces an instantaneous amplitude peak. Args: amplitudes: List of amplitudes for the wave components in xyz-directions. omega: Angular frequency of the wave oscillation. sigma: Standard deviation of the Gaussian pulse in time. t0: Central time around which the pulse peaks (default is 0.0). kick: If set to True, an instantaneous spike is added to the pulse at time `t0` instead of the Gaussian modulated cosine wave (default is False). Returns: Function that computes the potential at a given time and location, incorporating the wave characteristics and specified modulations. Note: This function, when not kicked, computes the same term as `Pulse`. \"\"\" amplitudes = jnp . array ( amplitudes ) f = lambda t : amplitudes * jnp . cos ( omega * t ) * jnp . exp ( - ( t - t0 ) ** 2 / sigma ** 2 ) if kick == True : f = lambda t : amplitudes * ( jnp . abs ( t - t0 ) < 1e-10 ) def pot ( t , r , args ): return jnp . einsum ( 'Kij,K->ij' , args . dipole_operator , f ( t )) return pot","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#granad.orbitals.Couplings","text":"A data class for representing orbital couplings. Attributes: hamiltonian ( _SortedTupleDict ) \u2013 A dictionary-like container holding Hamiltonian terms. coulomb ( _SortedTupleDict ) \u2013 A dictionary-like container for Coulomb interaction terms. dipole_transitions ( _SortedTupleDict ) \u2013 A dictionary-like container for storing dipole transition elements. Source code in src/granad/orbitals.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 @dataclass class Couplings : \"\"\" A data class for representing orbital couplings. Attributes: hamiltonian (_SortedTupleDict): A dictionary-like container holding Hamiltonian terms. coulomb (_SortedTupleDict): A dictionary-like container for Coulomb interaction terms. dipole_transitions (_SortedTupleDict): A dictionary-like container for storing dipole transition elements. \"\"\" hamiltonian : _SortedTupleDict = field ( default_factory = _SortedTupleDict ) coulomb : _SortedTupleDict = field ( default_factory = _SortedTupleDict ) dipole_transitions : _SortedTupleDict = field ( default_factory = _SortedTupleDict ) def __str__ ( self ): return def __add__ ( self , other ): if isinstance ( other , Couplings ): return Couplings ( _SortedTupleDict ( self . hamiltonian | other . hamiltonian ), _SortedTupleDict ( self . coulomb | other . coulomb ), _SortedTupleDict ( self . dipole_transitions | other . dipole_transitions ) ) raise ValueError","title":"Couplings"},{"location":"api/#granad.orbitals.Orbital","text":"Attributes: position ( Array ) \u2013 The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index ( Optional [ int ] ) \u2013 An optional index representing the layer of the orbital within its atom, may be None if not specified. tag ( Optional [ str ] ) \u2013 An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level ( Optional [ int ] ) \u2013 The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum ( Optional [ int ] ) \u2013 The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z ( Optional [ int ] ) \u2013 The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin ( Optional [ int ] ) \u2013 The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name ( Optional [ str ] ) \u2013 The name of the atom this orbital belongs to, can be None if not applicable. group_id ( int ) \u2013 A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. For example, all pz orbitals in a single graphene flake get the same group_id. Source code in src/granad/orbitals.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @dataclass class Orbital : \"\"\" Attributes: position (jax.Array): The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom, may be None if not specified. tag (Optional[str]): An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable. group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. For example, all pz orbitals in a single graphene flake get the same group_id. \"\"\" position : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 , 0 , 0 ]), hash = False , compare = False ) layer_index : Optional [ int ] = None tag : Optional [ str ] = None energy_level : Optional [ int ] = None angular_momentum : Optional [ int ] = None angular_momentum_z : Optional [ int ] = None spin : Optional [ int ] = None atom_name : Optional [ str ] = None group_id : _watchdog . GroupId = field ( default_factory = _watchdog . _Watchdog . next_value ) def __post_init__ ( self ): object . __setattr__ ( self , \"position\" , jnp . array ( self . position ) . astype ( float )) def __hash__ ( self ): # Include only immutable fields in hash calculation return hash ( ( self . layer_index , self . tag , self . energy_level , self . angular_momentum , self . angular_momentum_z , self . angular_momentum , self . spin , self . atom_name , self . group_id . id , ) ) def __str__ ( self ): return pformat ( vars ( self ), sort_dicts = False ) def __eq__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id == other . group_id and self . layer_index == other . layer_index def __lt__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id < other . group_id def __le__ ( self , other ): return self < other or self == other def __gt__ ( self , other ): return not self <= other def __ge__ ( self , other ): return not self < other def __ne__ ( self , other ): return not self == other","title":"Orbital"},{"location":"api/#granad.orbitals.OrbitalList","text":"A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list, while also maintaining additional functionalities for coupling orbitals and managing their relationships. The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries, where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float or a function representing the coupling strength or mechanism between the orbitals). The class also stores simulation parameters like the number of electrons and temperature in a dataclass. The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so quantity_x == quantity. The class exposes simulation methods. Attributes: _list ( list) ) \u2013 the underlying list that contains the orbitals params ( Params ) \u2013 Simulation parameters like electron count and temperature. couplings ( _SortedTupleDict ) \u2013 A (customized) dictionary where keys are tuples of orbital identifiers and values are the couplings (either float values or functions). Note Orbital Identification : Orbitals can be identified either by their group_id, a direct reference to the orbital object itself, or via a user-defined tag. Index Access : Orbitals can be accessed and managed by their index in the list, allowing for list-like manipulation (addition, removal, access). Coupling Definition : Allows for the definition and adjustment of couplings between pairs of orbitals, identified by a tuple of their respective identifiers. These couplings can dynamically represent the interaction strength or be a computational function that defines the interaction. Source code in src/granad/orbitals.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 @plotting_methods class OrbitalList : \"\"\" A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list, while also maintaining additional functionalities for coupling orbitals and managing their relationships. The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries, where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float or a function representing the coupling strength or mechanism between the orbitals). The class also stores simulation parameters like the number of electrons and temperature in a dataclass. The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so quantity_x == quantity. The class exposes simulation methods. Attributes: _list (list) : the underlying list that contains the orbitals params (Params): Simulation parameters like electron count and temperature. couplings (_SortedTupleDict): A (customized) dictionary where keys are tuples of orbital identifiers and values are the couplings (either float values or functions). Note: - **Orbital Identification**: Orbitals can be identified either by their group_id, a direct reference to the orbital object itself, or via a user-defined tag. - **Index Access**: Orbitals can be accessed and managed by their index in the list, allowing for list-like manipulation (addition, removal, access). - **Coupling Definition**: Allows for the definition and adjustment of couplings between pairs of orbitals, identified by a tuple of their respective identifiers. These couplings can dynamically represent the interaction strength or be a computational function that defines the interaction. \"\"\" def __init__ ( self , orbs = None , couplings = None , params = None , recompute = True ): self . _list = orbs if orbs is not None else [] self . couplings = couplings if couplings is not None else Couplings ( ) self . params = params if params is not None else Params ( len ( orbs ) ) self . _recompute = recompute def __getattr__ ( self , property_name ): if property_name . endswith ( \"_x\" ): original_name = property_name [: - 2 ] try : return getattr ( self , original_name ) except AttributeError : pass elif property_name . endswith ( \"_e\" ): original_name = property_name [: - 2 ] try : return self . transform_to_energy_basis ( getattr ( self , original_name )) except AttributeError : pass raise AttributeError ( f \" { self . __class__ . __name__ !r} object has no attribute { property_name !r} \" ) def __len__ ( self ): return len ( self . _list ) # can't mutate, because orbitals are immutable def __getitem__ ( self , position ): return self . _list [ position ] def __repr__ ( self ): info = f \"List with { len ( self ) } orbitals, { self . electrons } electrons.\" info += f \"Excitation: f { self . params . excitation } \" # TODO: add sth about groups return \" \\n \" . join (( info , repr ( self . _list ))) def __iter__ ( self ): return iter ( self . _list ) def __add__ ( self , other ): if not self . _are_orbs ( other ): raise TypeError if any ( orb in other for orb in self . _list ): raise ValueError if isinstance ( other , OrbitalList ): new_list = ( self . _list + list ( other )) . copy () new_couplings = self . couplings + other . couplings new_params = self . params + other . params return OrbitalList ( new_list , new_couplings , new_params ) @mutates def __setitem__ ( self , position , value ): if isinstance ( value , Orbital ): self . _list [ position ] = value raise TypeError def _delete_coupling ( self , orb , coupling ): keys_to_remove = [ key for key in coupling if orb in key ] for key in keys_to_remove : del coupling [ key ] @mutates def __delitem__ ( self , position ): orb = self . _list [ position ] self . _delete_coupling ( orb , self . couplings . hamiltonian ) self . _delete_coupling ( orb , self . couplings . coulomb ) self . _delete_coupling ( orb , self . couplings . dipole_transitions ) self . params . electrons -= 1 del self . _list [ position ] @staticmethod def _are_orbs ( candidate ): return all ( isinstance ( orb , Orbital ) for orb in candidate ) @mutates def _set_coupling ( self , orb1 , orb2 , val_or_func , coupling ): for o1 in orb1 : for o2 in orb2 : coupling [( o1 , o2 )] = val_or_func def _hamiltonian_coulomb ( self ): def fill_matrix ( matrix , coupling_dict ): dummy = jnp . arange ( len ( self )) triangle_mask = dummy [:, None ] >= dummy # TODO: in principle we can build a big tensor NxNxgroups, vmap over the last axis and sum the groups # first, we loop over all group_id couplings => interactions between groups for key , function in coupling_dict . group_id_items (): # TODO: big uff: we rely on the correct ordering of the group_ids for cols and rows, first key is always smaller than last keys => we get upper triangular valid indices # if it were the other way around, these would be zeroed by the triangle mask cols = group_ids == key [ 0 ] . id rows = ( group_ids == key [ 1 ] . id )[:, None ] combination_indices = jnp . logical_and ( rows , cols ) valid_indices = jnp . logical_and ( triangle_mask , combination_indices ) function = jax . vmap ( function ) matrix = matrix . at [ valid_indices ] . set ( function ( distances [ valid_indices ]) ) matrix += matrix . conj () . T - jnp . diag ( jnp . diag ( matrix )) # we now set single elements rows , cols , vals = [], [], [] for key , val in coupling_dict . orbital_items (): rows . append ( self . _list . index ( key [ 0 ])) cols . append ( self . _list . index ( key [ 1 ])) vals . append ( val ) # TODO: uff not good vals = jnp . array ( vals ) matrix = matrix . at [ rows , cols ] . set ( vals ) matrix = matrix . at [ cols , rows ] . set ( vals . conj ()) return matrix # TODO: rounding positions = self . positions distances = jnp . round ( jnp . linalg . norm ( positions - positions [:, None ], axis =- 1 ), 6 ) group_ids = jnp . array ( [ orb . group_id . id for orb in self . _list ] ) hamiltonian = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . couplings . hamiltonian ) coulomb = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . couplings . coulomb ) return hamiltonian , coulomb # TODO: abstract this boilerplate away @mutates def set_dipole_element ( self , orb1 , orb2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb1: Identifier for orbital(s) for the first part of the transition. orb2: Identifier for orbital(s) for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), jnp . array ( arr ) . astype ( complex ), self . couplings . dipole_transitions ) def set_hamiltonian_groups ( self , orb1 , orb2 , func ): \"\"\" Sets the hamiltonian coupling between two groups of orbitals. Parameters: orb1: Identifier for orbital(s) for the first group. orb2: Identifier for orbital(s) for the second group. func (callable): Function that defines the hamiltonian interaction. Note: The function `func` should be complex-valued. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , _watchdog . GroupId ), self . filter_orbs ( orb2 , _watchdog . GroupId ), self . _ensure_complex ( func ), self . couplings . hamiltonian ) def set_coulomb_groups ( self , orb1 , orb2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb1: Identifier for orbital(s) for the first group. orb2: Identifier for orbital(s) for the second group. func (callable): Function that defines the Coulomb interaction. Note: The function `func` should be complex-valued. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , _watchdog . GroupId ), self . filter_orbs ( orb2 , _watchdog . GroupId ), self . _ensure_complex ( func ), self . couplings . coulomb ) def set_hamiltonian_element ( self , orb1 , orb2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb1: Identifier for orbital(s) for the first element. orb2: Identifier for orbital(s) for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), self . _ensure_complex ( val ), self . couplings . hamiltonian ) def set_coulomb_element ( self , orb1 , orb2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb1: Identifier for orbital(s) for the first element. orb2: Identifier for orbital(s) for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), self . _ensure_complex ( val ), self . couplings . coulomb ) def _ensure_complex ( self , func_or_val ): if callable ( func_or_val ): return lambda x : func_or_val ( x ) + 0.0 j if isinstance ( func_or_val , ( int , float , complex )): return func_or_val + 0.0 j raise TypeError def _build ( self ): assert len ( self ) > 0 self . _hamiltonian , self . _coulomb = self . _hamiltonian_coulomb () # TODO: there is something weird happening here! self . _eigenvectors , self . _energies = jax . lax . linalg . eigh ( self . _hamiltonian ) self . _initial_density_matrix = _numerics . _density_matrix ( self . _energies , self . params . electrons , self . params . spin_degeneracy , self . params . eps , self . params . excitation , self . params . beta , ) self . _stationary_density_matrix = _numerics . _density_matrix ( self . _energies , self . params . electrons , self . params . spin_degeneracy , self . params . eps , Params ( 0 ) . excitation , self . params . beta , ) if len ( self . params . self_consistency_params ) != 0 : ( self . _hamiltonian , self . _initial_density_matrix , self . _stationary_density_matrix , self . _energies , self . _eigenvectors , ) = _numerics . _get_self_consistent ( self . _hamiltonian , self . _coulomb , self . positions , self . params . excitation , self . params . spin_degeneracy , self . params . electrons , self . params . eps , self . _eigenvectors , self . _stationary_density_matrix , ** self . params . self_consistency_params , ) self . _initial_density_matrix = self . transform_to_site_basis ( self . _initial_density_matrix ) self . _stationary_density_matrix = self . transform_to_site_basis ( self . _stationary_density_matrix ) def set_open_shell ( self ): if any ( orb . spin is None for orb in self . _list ): raise ValueError self . simulation_params . spin_degeneracy = 1.0 def set_closed_shell ( self ): self . simulation_params . spin_degeneracy = 2.0 def index ( self , orb ): return self . _list . index ( orb ) @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other ) self . params . electrons += 1 # TODO: replace if else with action map def filter_orbs ( self , orb_id , t ): def filter_single_orb ( orb_id , t ): if type ( orb_id ) == t : return [ orb_id ] # index to group, orb, tag => group_id / orb / tag at index, if isinstance ( orb_id , int ) and t == _watchdog . GroupId : return [ self . _list [ orb_id ] . group_id ] if isinstance ( orb_id , int ) and t == Orbital : return [ self . _list [ orb_id ]] if isinstance ( orb_id , int ) and t == str : return [ self . _list [ orb_id ] . tag ] # group to index, orb, tag => group_id / orb / tag at index, if isinstance ( orb_id , _watchdog . GroupId ) and t == str : return [ orb . tag for orb in self if orb . group_id == orb_id ] if isinstance ( orb_id , _watchdog . GroupId ) and t == Orbital : return [ orb for orb in self if orb . group_id == orb_id ] if isinstance ( orb_id , _watchdog . GroupId ) and t == int : return [ i for i , orb in enumerate ( self ) if orb . group_id == orb_id ] # tag to group, orb, index => group_id / orb / tag at index, if isinstance ( orb_id , str ) and t == _watchdog . GroupId : return [ orb . group_id for orb in self if orb . tag == orb_id ] if isinstance ( orb_id , str ) and t == int : return [ i for i , orb in enumerate ( self ) if orb . tag == orb_id ] if isinstance ( orb_id , str ) and t == Orbital : return [ orb for orb in self if orb . tag == orb_id ] # orb to index, group, tag if isinstance ( orb_id , Orbital ) and t == _watchdog . GroupId : return [ orb_id . group_id ] if isinstance ( orb_id , Orbital ) and t == int : return [ self . _list . index ( orb_id )] if isinstance ( orb_id , Orbital ) and t == str : return [ orb_id . tag ] # TODO: this is bad, do action map if not isinstance ( orb_id , OrbitalList ): orb_id = [ orb_id ] return [ x for orb in orb_id for x in filter_single_orb ( orb , t ) ] @mutates def shift_by_vector ( self , translation_vector , orb_id = None ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: translation_vector (list or jax.Array): The vector by which to translate the orbital positions. orb_id: Identifier for the orbital(s) to shift. Note: This operation mutates the positions of the matched orbitals. \"\"\" filtered_orbs = self . filter_orbs ( orb_id , Orbital ) if orb_id is not None else self for orb in filtered_orbs : orb . position += jnp . array ( translation_vector ) @mutates def set_position ( self , position , orb_id = None ): \"\"\" Sets the position of all orbitals with a specific tag. Parameters: position (list or jax.Array): The vector at which to move the orbitals orb_id: Identifier for the orbital(s) to shift. Note: This operation mutates the positions of the matched orbitals. \"\"\" filtered_orbs = self . filter_orbs ( orb_id , Orbital ) if orb_id is not None else self for orb in filtered_orbs : orb . position = position @mutates def set_self_consistent ( self , ** kwargs ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" default = { \"accuracy\" : 1e-6 , \"mix\" : 0.3 , \"iterations\" : 500 , \"coulomb_strength\" : 1.0 } self . params . self_consistency_params = default | kwargs @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Note: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): return jnp . array ( maybe_int ) raise TypeError self . params . excitation = [ maybe_int_to_arr ( from_state ), maybe_int_to_arr ( to_state ), maybe_int_to_arr ( excited_electrons )] @property def positions ( self ): return jnp . array ([ orb . position for orb in self . _list ]) # TODO: too verbose @property def electrons ( self ): return self . params . electrons @mutates def set_electrons ( self , val ): self . params . electrons = val @property def eps ( self ): return self . params . eps @mutates def set_eps ( self , val ): self . params . eps = val @property def spin_degeneracy ( self ): return self . params . spin_degeneracy @property @recomputes def homo ( self ): return ( self . electrons * self . stationary_density_matrix_e ) . real . diagonal () . round ( 2 ) . nonzero ()[ 0 ][ - 1 ] . item () @property @recomputes def eigenvectors ( self ): return self . _eigenvectors @property @recomputes def energies ( self ): return self . _energies @property @recomputes def hamiltonian ( self ): return self . _hamiltonian @property @recomputes def coulomb ( self ): return self . _coulomb @property @recomputes def initial_density_matrix ( self ): return self . _initial_density_matrix @property @recomputes def stationary_density_matrix ( self ): return self . _stationary_density_matrix @property @recomputes def quadrupole_operator ( self ): \"\"\" Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: jax.Array: A tensor representing the quadrupole operator. \"\"\" dip = self . dipole_operator term = jnp . einsum ( \"ijk,jlm->ilkm\" , dip , dip ) diag = jnp . einsum ( \"ijk,jlk->il\" , dip , dip ) diag = jnp . einsum ( \"ij,kl->ijkl\" , diag , jnp . eye ( term . shape [ - 1 ])) return 3 * term - diag @property @recomputes def dipole_operator ( self ): \"\"\" Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. \"\"\" N = self . positions . shape [ 0 ] dipole_operator = jnp . zeros (( 3 , N , N )) . astype ( complex ) for i in range ( 3 ): dipole_operator = dipole_operator . at [ i , :, :] . set ( jnp . diag ( self . positions [:, i ] / 2 ) ) for orbital_combination , value in self . couplings . dipole_transitions . items (): i , j = self . _list . index ( orbital_combination [ 0 ]), self . _list . index ( orbital_combination [ 1 ] ) k = value . nonzero ()[ 0 ] dipole_operator = dipole_operator . at [ k , i , j ] . set ( value [ k ]) return dipole_operator + jnp . transpose ( dipole_operator , ( 0 , 2 , 1 )) . conj () @property @recomputes def velocity_operator ( self ): \"\"\" Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. \"\"\" if self . couplings . dipole_transitions is None : x_times_h = jnp . einsum ( \"ij,iL->ijL\" , self . _hamiltonian , self . positions ) h_times = jnp . einsum ( \"ij,jL->ijL\" , self . _hamiltonian , self . positions ) else : positions = self . dipole_operator x_times_h = jnp . einsum ( \"kj,Lik->Lij\" , self . _hamiltonian , positions ) h_times = jnp . einsum ( \"ik,Lkj->Lij\" , self . _hamiltonian , positions ) return - 1 j * ( x_times_h - h_times ) @property @recomputes def transition_energies ( self ): \"\"\" Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: jax.Array: The element `arr[i,j]` contains the transition energy from `i` to `j`. \"\"\" return self . _energies [:, None ] - self . _energies @property @recomputes def wigner_weisskopf_transition_rates ( self ): \"\"\" Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: jax.Array: The element `arr[i,j]` contains the transition rate from `i` to `j`. \"\"\" charge = 1.602e-19 eps_0 = 8.85 * 1e-12 hbar = 1.0545718 * 1e-34 c = 3e8 # 137 (a.u.) factor = 1.6e-29 * charge / ( 3 * jnp . pi * eps_0 * hbar ** 2 * c ** 3 ) te = self . transition_energies transition_dipole_moments = self . dipole_operator_e return ( ( te * ( te > self . eps )) ** 3 * jnp . squeeze ( transition_dipole_moments ** 2 ) * factor ) @staticmethod def _transform_basis ( observable , vectors ): dims_einsum_strings = { 2 : \"ij,jk,lk->il\" , 3 : \"ij,mjk,lk->mil\" } einsum_string = dims_einsum_strings [( observable . ndim )] return jnp . einsum ( einsum_string , vectors , observable , vectors . conj ()) def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors ) def transform_to_energy_basis ( self , observable ): \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T ) @recomputes def get_charge ( self , density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. If omitted, the initial density matrix is used. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" density_matrix = self . initial_density_matrix if density_matrix is None else density_matrix return jnp . diag ( density_matrix * self . electrons ) @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians ) @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians ) @recomputes def get_epi ( self , density_matrix_stat : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = epsilon if epsilon is not None else self . eps density_matrix_stat_without_diagonal = jnp . abs ( density_matrix_stat - jnp . diag ( jnp . diag ( density_matrix_stat ))) density_matrix_stat_normalized = density_matrix_stat_without_diagonal / jnp . linalg . norm ( density_matrix_stat_without_diagonal ) te = self . transition_energies excitonic_transitions = ( density_matrix_stat_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * density_matrix_stat_normalized )) / ( jnp . linalg . norm ( density_matrix_stat_normalized ) * jnp . linalg . norm ( excitonic_transitions ) ) @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field def get_expectation_value ( self , * , operator , density_matrix , induced = True ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->li\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } correction = self . stationary_density_matrix_x if induced == True else 0 return self . electrons * jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , correction - density_matrix , ) def get_args ( self , relaxation_rate = 0.0 , coulomb_strength = 1.0 , propagator = None ): return TDArgs ( self . hamiltonian , self . energies , self . coulomb * coulomb_strength , self . initial_density_matrix , self . stationary_density_matrix , self . eigenvectors , self . dipole_operator , self . electrons , relaxation_rate , propagator , self . spin_degeneracy , self . positions ) @staticmethod def get_hamiltonian ( illumination = None , use_rwa = False , add_induced = False ): \"\"\"Dict holding terms of the default hamiltonian: bare + coulomb + dipole gauge coupling to external field + (optional) induced field (optionally in RWA)\"\"\" contents = {} contents [ \"bare_hamiltonian\" ] = potentials . BareHamiltonian () contents [ \"coulomb\" ] = potentials . Coulomb () if illumination is not None : contents [ \"potential\" ] = potentials . DipoleGauge ( illumination , use_rwa ) if add_induced == True : contents [ \"induced\" ] = potentials . Induced ( ) return contents # TODO: default saturation @staticmethod def get_dissipator ( relaxation_rate = None , saturation = None ): \"\"\"Dict holding the term of the default dissipator: either decoherence time from relaxation_rate as float and ignored saturation or lindblad from relaxation_rate as array and saturation function\"\"\" if relaxation_rate is None and saturation is None : return { \"no_dissipation\" : lambda t , r , args : 0.0 } if isinstance ( relaxation_rate , float ): return { \"decoherence_time\" : dissipators . DecoherenceTime () } return { \"lindblad\" : dissipators . SaturationLindblad ( lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))) ) } # TODO: rewrite, should be static, leaks mem def get_postprocesses ( self , expectation_values , density_matrix ): postprocesses = {} if isinstance ( expectation_values , jax . Array ): expectation_values = [ expectation_values ] if expectation_values is not None : ops = jnp . concatenate ( expectation_values ) postprocesses [ \"expectation_values\" ] = lambda rho , args : self . get_expectation_value ( operator = ops , density_matrix = rho ) if density_matrix is None : return postprocesses if isinstance ( density_matrix , str ): density_matrix = [ density_matrix ] for option in density_matrix : if option == \"occ_x\" : postprocesses [ option ] = lambda rho , args : args . electrons * jnp . diagonal ( rho , axis1 =- 1 , axis2 =- 2 ) elif option == \"occ_e\" : postprocesses [ option ] = lambda rho , args : args . electrons * jnp . diagonal ( args . eigenvectors . conj () . T @ rho @ args . eigenvectors , axis1 =- 1 , axis2 =- 2 ) elif option == \"full\" : postprocesses [ option ] = lambda rho , args : rho return postprocesses # TODO: illumination is too implicit, args may be too implicit, but idk what else to do rn @recomputes def master_equation ( self , * , end_time : float , start_time : float = 0.0 , dt : float = 1e-4 , grid : Union [ int , jax . Array ] = 100 , max_mem_gb : float = 0.5 , initial_density_matrix : Optional [ jax . Array ] = None , coulomb_strength : float = 1.0 , illumination : Callable = None , relaxation_rate : float = None , compute_at : Optional [ jax . Array ] = None , expectation_values : Optional [ list [ jax . Array ]] = None , density_matrix : Optional [ list [ str ]] = None , use_rwa : bool = False , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), hamiltonian : dict = None , dissipator : dict = None , postprocesses : dict = None , rhs_args = None , ): \"\"\" Simulates the time evolution of the density matrix, computing observables, density matrices or extracting custom information. Args: end_time (float): The final time for the simulation. start_time (float): The starting time for the simulation. Defaults to 0.0. dt (float): The time step size for the simulation. Defaults to 1e-4. grid (Union[int, jax.Array]): Determines the output times for the simulation results. If an integer, results are saved every 'grid'-th time step. If an array, results are saved at the specified times. max_mem_gb (float): Maximum memory in gigabytes allowed for each batch of intermediate density matrices. initial_density_matrix (Optional[jax.Array]): The initial state of the density matrix. If not provided, `self.initial_density_matrix` is used. coulomb_strength (float): Scaling factor for the Coulomb interaction matrix. illumination (Callable): Function describing the time-dependent external illumination applied to the system. relaxation_rate (Union[float, jax.Array, Callable]): Specifies the relaxation dynamics. A float indicates a uniform decoherence time, an array provides state-specific rates. compute_at (Optional[jax.Array]): The orbitals indexed by this array will experience induced fields. expectation_values (Optional[list[jax.Array]]): Expectation values to compute during the simulation. density_matrix (Optional[list[str]]): Tags for additional density matrix computations. \"full\", \"occ_x\", \"occ_e\". May be deprecated. computation (Optional[Callable]): Additional computation to be performed at each step. use_rwa (bool): Whether to use the rotating wave approximation. Defaults to False. solver: The numerical solver instance to use for integrating the differential equations. stepsize_controller: Controller for adjusting the solver's step size based on error tolerance. hamiltonian: dict of functions representing terms in the hamiltonian. functions must have signature `t, r, args->jax.Array`. keys don't matter. dissipator:: dict of functions representing terms in the dissipator. functions must have signature `t, r, args->jax.Array`. keys don't matter. postprocesses: (bool): dict of functions representing information to extract from the simulation. functions must have signature `r, args->jax.Array`. keys don't matter. rhs_args: arguments passed to hamiltonian, dissipator, postprocesses during the simulation. namedtuple. Returns: ResultTD \"\"\" # arguments to evolution function if rhs_args is None : rhs_args = self . get_args ( relaxation_rate , coulomb_strength , _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_at ) ) if illumination is None : illumination = lambda t : jnp . array ( [ 0 j , 0 j , 0 j ] ) # each of these functions is applied to a density matrix batch postprocesses = self . get_postprocesses ( expectation_values , density_matrix ) if postprocesses is None else postprocesses # hermitian rhs hamiltonian = self . get_hamiltonian ( illumination , use_rwa , compute_at is not None ) if hamiltonian is None else hamiltonian # non hermitian rhs dissipator = self . get_dissipator ( relaxation_rate , None ) if dissipator is None else dissipator # set reasonable default initial_density_matrix = initial_density_matrix if initial_density_matrix is not None else rhs_args . initial_density_matrix return self . _integrate_master_equation ( list ( hamiltonian . values ()), list ( dissipator . values ()), list ( postprocesses . values ()), rhs_args , illumination , solver , stepsize_controller , initial_density_matrix , start_time , end_time , grid , max_mem_gb , dt ) @staticmethod def _integrate_master_equation ( hamiltonian , dissipator , postprocesses , rhs_args , illumination , solver , stepsize_controller , initial_density_matrix , start_time , end_time , grid , max_mem_gb , dt ): # batched time axis to save memory mat_size = initial_density_matrix . size * initial_density_matrix . itemsize / 1e9 time_axis = _numerics . get_time_axis ( mat_size = mat_size , grid = grid , start_time = start_time , end_time = end_time , max_mem_gb = max_mem_gb , dt = dt ) ## integrate final , output = _numerics . td_run ( initial_density_matrix , _numerics . get_integrator ( hamiltonian , dissipator , postprocesses , solver , stepsize_controller , dt ), time_axis , rhs_args ) return TDResult ( td_illumination = jax . vmap ( illumination )( jnp . concatenate ( time_axis )) , output = output , final_density_matrix = final , time_axis = jnp . concatenate ( time_axis ) ) def get_polarizability_rpa ( self , omegas , polarization , coulomb_strength = 1.0 , relaxation_rate = 1 / 10 , hungry = 0 , phi_ext = None , args = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. args (Optional): numeric representation of an orbital list, as obtained by `get_args` Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" if args is None : args = self . get_args ( relaxation_rate = relaxation_rate , coulomb_strength = coulomb_strength , propagator = None ) alpha = _numerics . rpa_polarizability_function ( args , polarization , hungry , phi_ext ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] ) def get_susceptibility_rpa ( self , omegas , relaxation_rate = 1 / 10 , coulomb_strength = 1.0 , hungry = 0 , args = None , ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. args (Optional): numeric representation of an orbital list, as obtained by `get_args` Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" if args is None : args = self . get_args ( relaxation_rate = relaxation_rate , coulomb_strength = coulomb_strength , propagator = None ) sus = _numerics . rpa_polarizability_function ( args , hungry ) return jax . lax . map ( sus , omegas ) def get_mean_field_hamiltonian ( self , overlap = None ): \"\"\"convert an orbital list to a set of parameters usable for the rhf procedure. currently, only an empirical direct channel interaction specified specified in a the list's coulomb dict is taken into account. \"\"\" # Since we consider <1i|U|i1> => U_{11ii} eri = self . coulomb [ None , None ] overlap = overlap if overlap is not None else jnp . eye ( self . hamiltonian . shape [ 0 ]) return _rhf ( self . hamiltonian , eri , overlap , self . electrons ) @property def atoms ( self ): atoms_pos = defaultdict ( list ) for orb in self . _list : atoms_pos [ orb . atom_name ] += [[ str ( x ) for x in orb . position ]] return atoms_pos def to_xyz ( self , name : str = None ): atoms = self . atoms number_of_atoms = sum ( [ len ( x ) for x in atoms . values ()] ) str_rep = str ( number_of_atoms ) + \" \\n\\n \" for atom , positions in atoms . items (): for pos in positions : str_rep += f ' { atom } { \" \" . join ( pos ) } \\n ' if name is None : return str_rep with open ( name , \"w\" ) as f : f . writelines ( str_rep ) # TODO: this far too simplistic @classmethod def from_xyz ( cls , name : str ): orbs , group_id = [], _watchdog . _Watchdog . next_value () with open ( name , 'r' ) as f : for line in f : processed = line . strip () . split () if len ( processed ) <= 1 : continue atom_name , x , y , z = processed orbs . append ( Orbital ( group_id = group_id , atom_name = atom_name , position = [ float ( x ), float ( y ), float ( z )] ) ) return cls ( orbs )","title":"OrbitalList"},{"location":"api/#granad.orbitals.OrbitalList.dipole_operator","text":"Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: \u2013 jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated.","title":"dipole_operator"},{"location":"api/#granad.orbitals.OrbitalList.quadrupole_operator","text":"Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: \u2013 jax.Array: A tensor representing the quadrupole operator.","title":"quadrupole_operator"},{"location":"api/#granad.orbitals.OrbitalList.transition_energies","text":"Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition energy from i to j .","title":"transition_energies"},{"location":"api/#granad.orbitals.OrbitalList.velocity_operator","text":"Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: \u2013 jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian.","title":"velocity_operator"},{"location":"api/#granad.orbitals.OrbitalList.wigner_weisskopf_transition_rates","text":"Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition rate from i to j .","title":"wigner_weisskopf_transition_rates"},{"location":"api/#granad.orbitals.OrbitalList.append","text":"Appends an orbital to the list, ensuring it is not already present. Parameters: other ( Orbital ) \u2013 The orbital to append. Raises: TypeError \u2013 If other is not an instance of Orbital. ValueError \u2013 If other is already in the list. Source code in src/granad/orbitals.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other ) self . params . electrons += 1","title":"append"},{"location":"api/#granad.orbitals.OrbitalList.get_charge","text":"Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix ( Array , default: None ) \u2013 The density matrix to use for calculating charge. If omitted, the initial density matrix is used. Returns: \u2013 jax.Array: A diagonal array representing charges at each site. Source code in src/granad/orbitals.py 906 907 908 909 910 911 912 913 914 915 916 917 918 919 @recomputes def get_charge ( self , density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. If omitted, the initial density matrix is used. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" density_matrix = self . initial_density_matrix if density_matrix is None else density_matrix return jnp . diag ( density_matrix * self . electrons )","title":"get_charge"},{"location":"api/#granad.orbitals.OrbitalList.get_dissipator","text":"Dict holding the term of the default dissipator: either decoherence time from relaxation_rate as float and ignored saturation or lindblad from relaxation_rate as array and saturation function Source code in src/granad/orbitals.py 1070 1071 1072 1073 1074 1075 1076 1077 @staticmethod def get_dissipator ( relaxation_rate = None , saturation = None ): \"\"\"Dict holding the term of the default dissipator: either decoherence time from relaxation_rate as float and ignored saturation or lindblad from relaxation_rate as array and saturation function\"\"\" if relaxation_rate is None and saturation is None : return { \"no_dissipation\" : lambda t , r , args : 0.0 } if isinstance ( relaxation_rate , float ): return { \"decoherence_time\" : dissipators . DecoherenceTime () } return { \"lindblad\" : dissipators . SaturationLindblad ( lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))) ) }","title":"get_dissipator"},{"location":"api/#granad.orbitals.OrbitalList.get_dos","text":"Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the DOS. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The integrated density of states at the specified frequency. Source code in src/granad/orbitals.py 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians )","title":"get_dos"},{"location":"api/#granad.orbitals.OrbitalList.get_epi","text":"Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat ( Array ) \u2013 The density matrix to consider for EPI calculation. omega ( float ) \u2013 The frequency to evaluate the EPI at. epsilon ( float , default: None ) \u2013 The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float ( float ) \u2013 The EPI. Source code in src/granad/orbitals.py 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 @recomputes def get_epi ( self , density_matrix_stat : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = epsilon if epsilon is not None else self . eps density_matrix_stat_without_diagonal = jnp . abs ( density_matrix_stat - jnp . diag ( jnp . diag ( density_matrix_stat ))) density_matrix_stat_normalized = density_matrix_stat_without_diagonal / jnp . linalg . norm ( density_matrix_stat_without_diagonal ) te = self . transition_energies excitonic_transitions = ( density_matrix_stat_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * density_matrix_stat_normalized )) / ( jnp . linalg . norm ( density_matrix_stat_normalized ) * jnp . linalg . norm ( excitonic_transitions ) )","title":"get_epi"},{"location":"api/#granad.orbitals.OrbitalList.get_expectation_value","text":"Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator ( Array ) \u2013 The operator for which the expectation value is calculated. density_matrix ( Array ) \u2013 The density matrix representing the state of the system. Returns: \u2013 jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. Source code in src/granad/orbitals.py 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 def get_expectation_value ( self , * , operator , density_matrix , induced = True ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->li\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } correction = self . stationary_density_matrix_x if induced == True else 0 return self . electrons * jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , correction - density_matrix , )","title":"get_expectation_value"},{"location":"api/#granad.orbitals.OrbitalList.get_hamiltonian","text":"Dict holding terms of the default hamiltonian: bare + coulomb + dipole gauge coupling to external field + (optional) induced field (optionally in RWA) Source code in src/granad/orbitals.py 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 @staticmethod def get_hamiltonian ( illumination = None , use_rwa = False , add_induced = False ): \"\"\"Dict holding terms of the default hamiltonian: bare + coulomb + dipole gauge coupling to external field + (optional) induced field (optionally in RWA)\"\"\" contents = {} contents [ \"bare_hamiltonian\" ] = potentials . BareHamiltonian () contents [ \"coulomb\" ] = potentials . Coulomb () if illumination is not None : contents [ \"potential\" ] = potentials . DipoleGauge ( illumination , use_rwa ) if add_induced == True : contents [ \"induced\" ] = potentials . Induced ( ) return contents","title":"get_hamiltonian"},{"location":"api/#granad.orbitals.OrbitalList.get_induced_field","text":"Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions ( Array ) \u2013 The positions at which to evaluate the induced field. density_matrix ( Array ) \u2013 The density matrix used to calculate the induced field. Returns: \u2013 jax.Array: The resulting electric field vector at each position. Source code in src/granad/orbitals.py 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field","title":"get_induced_field"},{"location":"api/#granad.orbitals.OrbitalList.get_ldos","text":"Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the LDOS. site_index ( int ) \u2013 The site index to evaluate the LDOS at. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The local density of states at the specified site and frequency. Source code in src/granad/orbitals.py 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians )","title":"get_ldos"},{"location":"api/#granad.orbitals.OrbitalList.get_mean_field_hamiltonian","text":"convert an orbital list to a set of parameters usable for the rhf procedure. currently, only an empirical direct channel interaction specified specified in a the list's coulomb dict is taken into account. Source code in src/granad/orbitals.py 1273 1274 1275 1276 1277 1278 1279 1280 1281 def get_mean_field_hamiltonian ( self , overlap = None ): \"\"\"convert an orbital list to a set of parameters usable for the rhf procedure. currently, only an empirical direct channel interaction specified specified in a the list's coulomb dict is taken into account. \"\"\" # Since we consider <1i|U|i1> => U_{11ii} eri = self . coulomb [ None , None ] overlap = overlap if overlap is not None else jnp . eye ( self . hamiltonian . shape [ 0 ]) return _rhf ( self . hamiltonian , eri , overlap , self . electrons )","title":"get_mean_field_hamiltonian"},{"location":"api/#granad.orbitals.OrbitalList.get_polarizability_rpa","text":"Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas ( Array ) \u2013 Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate ( float , default: 1 / 10 ) \u2013 The relaxation time parameter. polarization ( Array ) \u2013 Polarization directions or modes. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interaction in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext ( Optional [ Array ] , default: None ) \u2013 External potential influences, if any. args ( Optional , default: None ) \u2013 numeric representation of an orbital list, as obtained by get_args Returns: \u2013 jax.Array: The calculated polarizabilities at the specified frequencies. Source code in src/granad/orbitals.py 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 def get_polarizability_rpa ( self , omegas , polarization , coulomb_strength = 1.0 , relaxation_rate = 1 / 10 , hungry = 0 , phi_ext = None , args = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. args (Optional): numeric representation of an orbital list, as obtained by `get_args` Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" if args is None : args = self . get_args ( relaxation_rate = relaxation_rate , coulomb_strength = coulomb_strength , propagator = None ) alpha = _numerics . rpa_polarizability_function ( args , polarization , hungry , phi_ext ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] )","title":"get_polarizability_rpa"},{"location":"api/#granad.orbitals.OrbitalList.get_susceptibility_rpa","text":"Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas ( Array ) \u2013 The frequencies at which to compute susceptibility. relaxation_rate ( float , default: 1 / 10 ) \u2013 The relaxation time affecting susceptibility calculations. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interactions considered in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. args ( Optional , default: None ) \u2013 numeric representation of an orbital list, as obtained by get_args Returns: \u2013 jax.Array: The susceptibility values at the given frequencies. Source code in src/granad/orbitals.py 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 def get_susceptibility_rpa ( self , omegas , relaxation_rate = 1 / 10 , coulomb_strength = 1.0 , hungry = 0 , args = None , ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. args (Optional): numeric representation of an orbital list, as obtained by `get_args` Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" if args is None : args = self . get_args ( relaxation_rate = relaxation_rate , coulomb_strength = coulomb_strength , propagator = None ) sus = _numerics . rpa_polarizability_function ( args , hungry ) return jax . lax . map ( sus , omegas )","title":"get_susceptibility_rpa"},{"location":"api/#granad.orbitals.OrbitalList.master_equation","text":"Simulates the time evolution of the density matrix, computing observables, density matrices or extracting custom information. Parameters: end_time ( float ) \u2013 The final time for the simulation. start_time ( float , default: 0.0 ) \u2013 The starting time for the simulation. Defaults to 0.0. dt ( float , default: 0.0001 ) \u2013 The time step size for the simulation. Defaults to 1e-4. grid ( Union [ int , Array ] , default: 100 ) \u2013 Determines the output times for the simulation results. If an integer, results are saved every 'grid'-th time step. If an array, results are saved at the specified times. max_mem_gb ( float , default: 0.5 ) \u2013 Maximum memory in gigabytes allowed for each batch of intermediate density matrices. initial_density_matrix ( Optional [ Array ] , default: None ) \u2013 The initial state of the density matrix. If not provided, self.initial_density_matrix is used. coulomb_strength ( float , default: 1.0 ) \u2013 Scaling factor for the Coulomb interaction matrix. illumination ( Callable , default: None ) \u2013 Function describing the time-dependent external illumination applied to the system. relaxation_rate ( Union [ float , Array , Callable ] , default: None ) \u2013 Specifies the relaxation dynamics. A float indicates a uniform decoherence time, an array provides state-specific rates. compute_at ( Optional [ Array ] , default: None ) \u2013 The orbitals indexed by this array will experience induced fields. expectation_values ( Optional [ list [ Array ]] , default: None ) \u2013 Expectation values to compute during the simulation. density_matrix ( Optional [ list [ str ]] , default: None ) \u2013 Tags for additional density matrix computations. \"full\", \"occ_x\", \"occ_e\". May be deprecated. computation ( Optional [ Callable ] ) \u2013 Additional computation to be performed at each step. use_rwa ( bool , default: False ) \u2013 Whether to use the rotating wave approximation. Defaults to False. solver \u2013 The numerical solver instance to use for integrating the differential equations. stepsize_controller \u2013 Controller for adjusting the solver's step size based on error tolerance. hamiltonian ( dict , default: None ) \u2013 dict of functions representing terms in the hamiltonian. functions must have signature t, r, args->jax.Array . keys don't matter. dissipator ( dict , default: None ) \u2013 : dict of functions representing terms in the dissipator. functions must have signature t, r, args->jax.Array . keys don't matter. postprocesses ( dict , default: None ) \u2013 (bool): dict of functions representing information to extract from the simulation. functions must have signature r, args->jax.Array . keys don't matter. rhs_args \u2013 arguments passed to hamiltonian, dissipator, postprocesses during the simulation. namedtuple. Returns: \u2013 ResultTD Source code in src/granad/orbitals.py 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 @recomputes def master_equation ( self , * , end_time : float , start_time : float = 0.0 , dt : float = 1e-4 , grid : Union [ int , jax . Array ] = 100 , max_mem_gb : float = 0.5 , initial_density_matrix : Optional [ jax . Array ] = None , coulomb_strength : float = 1.0 , illumination : Callable = None , relaxation_rate : float = None , compute_at : Optional [ jax . Array ] = None , expectation_values : Optional [ list [ jax . Array ]] = None , density_matrix : Optional [ list [ str ]] = None , use_rwa : bool = False , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), hamiltonian : dict = None , dissipator : dict = None , postprocesses : dict = None , rhs_args = None , ): \"\"\" Simulates the time evolution of the density matrix, computing observables, density matrices or extracting custom information. Args: end_time (float): The final time for the simulation. start_time (float): The starting time for the simulation. Defaults to 0.0. dt (float): The time step size for the simulation. Defaults to 1e-4. grid (Union[int, jax.Array]): Determines the output times for the simulation results. If an integer, results are saved every 'grid'-th time step. If an array, results are saved at the specified times. max_mem_gb (float): Maximum memory in gigabytes allowed for each batch of intermediate density matrices. initial_density_matrix (Optional[jax.Array]): The initial state of the density matrix. If not provided, `self.initial_density_matrix` is used. coulomb_strength (float): Scaling factor for the Coulomb interaction matrix. illumination (Callable): Function describing the time-dependent external illumination applied to the system. relaxation_rate (Union[float, jax.Array, Callable]): Specifies the relaxation dynamics. A float indicates a uniform decoherence time, an array provides state-specific rates. compute_at (Optional[jax.Array]): The orbitals indexed by this array will experience induced fields. expectation_values (Optional[list[jax.Array]]): Expectation values to compute during the simulation. density_matrix (Optional[list[str]]): Tags for additional density matrix computations. \"full\", \"occ_x\", \"occ_e\". May be deprecated. computation (Optional[Callable]): Additional computation to be performed at each step. use_rwa (bool): Whether to use the rotating wave approximation. Defaults to False. solver: The numerical solver instance to use for integrating the differential equations. stepsize_controller: Controller for adjusting the solver's step size based on error tolerance. hamiltonian: dict of functions representing terms in the hamiltonian. functions must have signature `t, r, args->jax.Array`. keys don't matter. dissipator:: dict of functions representing terms in the dissipator. functions must have signature `t, r, args->jax.Array`. keys don't matter. postprocesses: (bool): dict of functions representing information to extract from the simulation. functions must have signature `r, args->jax.Array`. keys don't matter. rhs_args: arguments passed to hamiltonian, dissipator, postprocesses during the simulation. namedtuple. Returns: ResultTD \"\"\" # arguments to evolution function if rhs_args is None : rhs_args = self . get_args ( relaxation_rate , coulomb_strength , _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_at ) ) if illumination is None : illumination = lambda t : jnp . array ( [ 0 j , 0 j , 0 j ] ) # each of these functions is applied to a density matrix batch postprocesses = self . get_postprocesses ( expectation_values , density_matrix ) if postprocesses is None else postprocesses # hermitian rhs hamiltonian = self . get_hamiltonian ( illumination , use_rwa , compute_at is not None ) if hamiltonian is None else hamiltonian # non hermitian rhs dissipator = self . get_dissipator ( relaxation_rate , None ) if dissipator is None else dissipator # set reasonable default initial_density_matrix = initial_density_matrix if initial_density_matrix is not None else rhs_args . initial_density_matrix return self . _integrate_master_equation ( list ( hamiltonian . values ()), list ( dissipator . values ()), list ( postprocesses . values ()), rhs_args , illumination , solver , stepsize_controller , initial_density_matrix , start_time , end_time , grid , max_mem_gb , dt )","title":"master_equation"},{"location":"api/#granad.orbitals.OrbitalList.set_coulomb_element","text":"Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb1 \u2013 Identifier for orbital(s) for the first element. orb2 \u2013 Identifier for orbital(s) for the second element. val ( complex ) \u2013 The complex value to set for the Coulomb interaction element. Source code in src/granad/orbitals.py 512 513 514 515 516 517 518 519 520 521 def set_coulomb_element ( self , orb1 , orb2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb1: Identifier for orbital(s) for the first element. orb2: Identifier for orbital(s) for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), self . _ensure_complex ( val ), self . couplings . coulomb )","title":"set_coulomb_element"},{"location":"api/#granad.orbitals.OrbitalList.set_coulomb_groups","text":"Sets the Coulomb coupling between two groups of orbitals. Parameters: orb1 \u2013 Identifier for orbital(s) for the first group. orb2 \u2013 Identifier for orbital(s) for the second group. func ( callable ) \u2013 Function that defines the Coulomb interaction. Note The function func should be complex-valued. Source code in src/granad/orbitals.py 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def set_coulomb_groups ( self , orb1 , orb2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb1: Identifier for orbital(s) for the first group. orb2: Identifier for orbital(s) for the second group. func (callable): Function that defines the Coulomb interaction. Note: The function `func` should be complex-valued. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , _watchdog . GroupId ), self . filter_orbs ( orb2 , _watchdog . GroupId ), self . _ensure_complex ( func ), self . couplings . coulomb )","title":"set_coulomb_groups"},{"location":"api/#granad.orbitals.OrbitalList.set_dipole_element","text":"Sets a dipole transition for specified orbital or index pairs. Parameters: orb1 \u2013 Identifier for orbital(s) for the first part of the transition. orb2 \u2013 Identifier for orbital(s) for the second part of the transition. arr ( Array ) \u2013 The 3-element array containing dipole transition elements. Source code in src/granad/orbitals.py 457 458 459 460 461 462 463 464 465 466 467 @mutates def set_dipole_element ( self , orb1 , orb2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb1: Identifier for orbital(s) for the first part of the transition. orb2: Identifier for orbital(s) for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), jnp . array ( arr ) . astype ( complex ), self . couplings . dipole_transitions )","title":"set_dipole_element"},{"location":"api/#granad.orbitals.OrbitalList.set_excitation","text":"Sets up an excitation process from one state to another with specified electrons. Parameters: from_state ( int, list, or jax.Array ) \u2013 The initial state index or indices. to_state ( int, list, or jax.Array ) \u2013 The final state index or indices. excited_electrons ( int, list, or jax.Array ) \u2013 The indices of electrons to be excited. Note The states and electron indices may be specified as scalars, lists, or arrays. Source code in src/granad/orbitals.py 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Note: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): return jnp . array ( maybe_int ) raise TypeError self . params . excitation = [ maybe_int_to_arr ( from_state ), maybe_int_to_arr ( to_state ), maybe_int_to_arr ( excited_electrons )]","title":"set_excitation"},{"location":"api/#granad.orbitals.OrbitalList.set_hamiltonian_element","text":"Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb1 \u2013 Identifier for orbital(s) for the first element. orb2 \u2013 Identifier for orbital(s) for the second element. val ( complex ) \u2013 The complex value to set for the Hamiltonian element. Source code in src/granad/orbitals.py 501 502 503 504 505 506 507 508 509 510 def set_hamiltonian_element ( self , orb1 , orb2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb1: Identifier for orbital(s) for the first element. orb2: Identifier for orbital(s) for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , Orbital ), self . filter_orbs ( orb2 , Orbital ), self . _ensure_complex ( val ), self . couplings . hamiltonian )","title":"set_hamiltonian_element"},{"location":"api/#granad.orbitals.OrbitalList.set_hamiltonian_groups","text":"Sets the hamiltonian coupling between two groups of orbitals. Parameters: orb1 \u2013 Identifier for orbital(s) for the first group. orb2 \u2013 Identifier for orbital(s) for the second group. func ( callable ) \u2013 Function that defines the hamiltonian interaction. Note The function func should be complex-valued. Source code in src/granad/orbitals.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 def set_hamiltonian_groups ( self , orb1 , orb2 , func ): \"\"\" Sets the hamiltonian coupling between two groups of orbitals. Parameters: orb1: Identifier for orbital(s) for the first group. orb2: Identifier for orbital(s) for the second group. func (callable): Function that defines the hamiltonian interaction. Note: The function `func` should be complex-valued. \"\"\" self . _set_coupling ( self . filter_orbs ( orb1 , _watchdog . GroupId ), self . filter_orbs ( orb2 , _watchdog . GroupId ), self . _ensure_complex ( func ), self . couplings . hamiltonian )","title":"set_hamiltonian_groups"},{"location":"api/#granad.orbitals.OrbitalList.set_position","text":"Sets the position of all orbitals with a specific tag. Parameters: position ( list or Array ) \u2013 The vector at which to move the orbitals orb_id \u2013 Identifier for the orbital(s) to shift. Note This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 @mutates def set_position ( self , position , orb_id = None ): \"\"\" Sets the position of all orbitals with a specific tag. Parameters: position (list or jax.Array): The vector at which to move the orbitals orb_id: Identifier for the orbital(s) to shift. Note: This operation mutates the positions of the matched orbitals. \"\"\" filtered_orbs = self . filter_orbs ( orb_id , Orbital ) if orb_id is not None else self for orb in filtered_orbs : orb . position = position","title":"set_position"},{"location":"api/#granad.orbitals.OrbitalList.set_self_consistent","text":"Configures the list for self-consistent field calculations. Parameters: sc_params ( dict ) \u2013 Parameters for self-consistency. Source code in src/granad/orbitals.py 689 690 691 692 693 694 695 696 697 698 @mutates def set_self_consistent ( self , ** kwargs ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" default = { \"accuracy\" : 1e-6 , \"mix\" : 0.3 , \"iterations\" : 500 , \"coulomb_strength\" : 1.0 } self . params . self_consistency_params = default | kwargs","title":"set_self_consistent"},{"location":"api/#granad.orbitals.OrbitalList.shift_by_vector","text":"Shifts all orbitals with a specific tag by a given vector. Parameters: translation_vector ( list or Array ) \u2013 The vector by which to translate the orbital positions. orb_id \u2013 Identifier for the orbital(s) to shift. Note This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 @mutates def shift_by_vector ( self , translation_vector , orb_id = None ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: translation_vector (list or jax.Array): The vector by which to translate the orbital positions. orb_id: Identifier for the orbital(s) to shift. Note: This operation mutates the positions of the matched orbitals. \"\"\" filtered_orbs = self . filter_orbs ( orb_id , Orbital ) if orb_id is not None else self for orb in filtered_orbs : orb . position += jnp . array ( translation_vector )","title":"shift_by_vector"},{"location":"api/#granad.orbitals.OrbitalList.transform_to_energy_basis","text":"Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the energy basis. Source code in src/granad/orbitals.py 893 894 895 896 897 898 899 900 901 902 903 904 def transform_to_energy_basis ( self , observable ): \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T )","title":"transform_to_energy_basis"},{"location":"api/#granad.orbitals.OrbitalList.transform_to_site_basis","text":"Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the site basis. Source code in src/granad/orbitals.py 881 882 883 884 885 886 887 888 889 890 891 def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors )","title":"transform_to_site_basis"},{"location":"api/#granad.orbitals.Params","text":"Stores parameters characterizing a given structure. Attributes: excitation ( Array ) \u2013 from state, to state, excited electrons eps ( float ) \u2013 Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5. beta ( float ) \u2013 Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to jax.numpy.inf by default, implying zero temperature. self_consistency_params ( dict ) \u2013 A dictionary to hold additional parameters required for self-consistency calculations within the simulation. Defaults to an empty dictionary. spin_degeneracy ( float ) \u2013 Factor to account for the degeneracy of spin states in the simulation. Typically set to 2, considering spin up and spin down. electrons ( Optional [ int ] ) \u2013 The total number of electrons in the structure. If not provided, it is assumed that the system's electron number needs to be calculated or is managed elsewhere. Note This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state of OrbitalList. Source code in src/granad/orbitals.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @dataclass class Params : \"\"\" Stores parameters characterizing a given structure. Attributes: excitation (jax.Array): from state, to state, excited electrons eps (float): Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5. beta (float): Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to `jax.numpy.inf` by default, implying zero temperature. self_consistency_params (dict): A dictionary to hold additional parameters required for self-consistency calculations within the simulation. Defaults to an empty dictionary. spin_degeneracy (float): Factor to account for the degeneracy of spin states in the simulation. Typically set to 2, considering spin up and spin down. electrons (Optional[int]): The total number of electrons in the structure. If not provided, it is assumed that the system's electron number needs to be calculated or is managed elsewhere. Note: This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state of OrbitalList. \"\"\" electrons : int excitation : list [ jax . Array ] = field ( default_factory = lambda : [ jnp . array ([ 0 ]), jnp . array ([ 0 ]), jnp . array ([ 0 ])]) eps : float = 1e-5 beta : float = jnp . inf self_consistency_params : dict = field ( default_factory = dict ) spin_degeneracy : float = 2.0 def __add__ ( self , other ): if isinstance ( other , Params ): return Params ( self . electrons + other . electrons ) raise ValueError","title":"Params"},{"location":"api/#granad.orbitals.TDResult","text":"A data class for storing the results of time-dependent simulations. Attributes: td_illumination ( Array ) \u2013 An array containing the time-dependent illumination function applied to the system, typically representing an external electromagnetic field. time_axis ( Array ) \u2013 An array representing the time points at which the simulation was evaluated. final_density_matrix ( Array ) \u2013 The resulting density matrix at the end of the simulation, representing the state of the system. output ( list [ Array ] ) \u2013 A list of arrays containing various output data from the simulation, such as observables over time. Source code in src/granad/orbitals.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 @dataclass class TDResult : \"\"\" A data class for storing the results of time-dependent simulations. Attributes: td_illumination (jax.Array): An array containing the time-dependent illumination function applied to the system, typically representing an external electromagnetic field. time_axis (jax.Array): An array representing the time points at which the simulation was evaluated. final_density_matrix (jax.Array): The resulting density matrix at the end of the simulation, representing the state of the system. output (list[jax.Array]): A list of arrays containing various output data from the simulation, such as observables over time. \"\"\" td_illumination : jax . Array time_axis : jax . Array final_density_matrix : jax . Array output : list [ jax . Array ] def ft_output ( self , omega_max , omega_min ): \"\"\" Computes the Fourier transform of each element in the output data across a specified frequency range. Args: omega_max (float): The maximum frequency bound for the Fourier transform. omega_min (float): The minimum frequency bound for the Fourier transform. Returns: list[jax.Array]: A list of Fourier transformed arrays corresponding to each element in the `output` attribute, evaluated over the specified frequency range. Note: This method applies a Fourier transform to each array in the `output` list to analyze the frequency components between `omega_min` and `omega_max`. \"\"\" ft = lambda o : _numerics . get_fourier_transform ( self . time_axis , o , omega_max , omega_min , False ) return [ ft ( o ) for o in self . output ] def ft_illumination ( self , omega_max , omega_min , return_omega_axis = True ): \"\"\" Calculates the Fourier transform of the time-dependent illumination function over a specified frequency range, with an option to return the frequency axis. Args: omega_max (float): The maximum frequency limit for the Fourier transform. omega_min (float): The minimum frequency limit for the Fourier transform. return_omega_axis (bool): If True, the function also returns the frequency axis along with the Fourier transformed illumination function. Defaults to True. Returns: jax.Array, optional[jax.Array]: The Fourier transformed illumination function. If `return_omega_axis` is True, a tuple containing the Fourier transformed data and the corresponding frequency axis is returned. Otherwise, only the Fourier transformed data is returned. \"\"\" return _numerics . get_fourier_transform ( self . time_axis , self . td_illumination , omega_max , omega_min , return_omega_axis ) def save ( self , name ): jnp . savez ( f \" { name } .npz\" , ** asdict ( self ) ) @classmethod def load ( cls , name ): with jnp . load ( f ' { name } .npz' ) as data : return cls ( ** data )","title":"TDResult"},{"location":"api/#granad.orbitals.TDResult.ft_illumination","text":"Calculates the Fourier transform of the time-dependent illumination function over a specified frequency range, with an option to return the frequency axis. Parameters: omega_max ( float ) \u2013 The maximum frequency limit for the Fourier transform. omega_min ( float ) \u2013 The minimum frequency limit for the Fourier transform. return_omega_axis ( bool , default: True ) \u2013 If True, the function also returns the frequency axis along with the Fourier transformed illumination function. Defaults to True. Returns: \u2013 jax.Array, optional[jax.Array]: The Fourier transformed illumination function. If return_omega_axis is True, a tuple containing the Fourier transformed data and the corresponding frequency axis is returned. Otherwise, only the Fourier transformed data is returned. Source code in src/granad/orbitals.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def ft_illumination ( self , omega_max , omega_min , return_omega_axis = True ): \"\"\" Calculates the Fourier transform of the time-dependent illumination function over a specified frequency range, with an option to return the frequency axis. Args: omega_max (float): The maximum frequency limit for the Fourier transform. omega_min (float): The minimum frequency limit for the Fourier transform. return_omega_axis (bool): If True, the function also returns the frequency axis along with the Fourier transformed illumination function. Defaults to True. Returns: jax.Array, optional[jax.Array]: The Fourier transformed illumination function. If `return_omega_axis` is True, a tuple containing the Fourier transformed data and the corresponding frequency axis is returned. Otherwise, only the Fourier transformed data is returned. \"\"\" return _numerics . get_fourier_transform ( self . time_axis , self . td_illumination , omega_max , omega_min , return_omega_axis )","title":"ft_illumination"},{"location":"api/#granad.orbitals.TDResult.ft_output","text":"Computes the Fourier transform of each element in the output data across a specified frequency range. Parameters: omega_max ( float ) \u2013 The maximum frequency bound for the Fourier transform. omega_min ( float ) \u2013 The minimum frequency bound for the Fourier transform. Returns: \u2013 list[jax.Array]: A list of Fourier transformed arrays corresponding to each element in the output attribute, evaluated over the specified frequency range. Note This method applies a Fourier transform to each array in the output list to analyze the frequency components between omega_min and omega_max . Source code in src/granad/orbitals.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def ft_output ( self , omega_max , omega_min ): \"\"\" Computes the Fourier transform of each element in the output data across a specified frequency range. Args: omega_max (float): The maximum frequency bound for the Fourier transform. omega_min (float): The minimum frequency bound for the Fourier transform. Returns: list[jax.Array]: A list of Fourier transformed arrays corresponding to each element in the `output` attribute, evaluated over the specified frequency range. Note: This method applies a Fourier transform to each array in the `output` list to analyze the frequency components between `omega_min` and `omega_max`. \"\"\" ft = lambda o : _numerics . get_fourier_transform ( self . time_axis , o , omega_max , omega_min , False ) return [ ft ( o ) for o in self . output ]","title":"ft_output"},{"location":"api/#granad.fields.Pulse","text":"Function for computing temporally located time-harmonics electric fields. The pulse is implemented as a temporal Gaussian. Parameters: amplitudes ( list [ float ] ) \u2013 electric field amplitudes in xyz-components frequency ( float ) \u2013 frequency of the electric field peak ( float ) \u2013 time where the pulse reaches its peak fwhm ( float ) \u2013 full width at half maximum Returns: \u2013 Function that computes the electric field Source code in src/granad/fields.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def Pulse ( amplitudes : list [ float ], frequency : float , peak : float , fwhm : float , ): \"\"\"Function for computing temporally located time-harmonics electric fields. The pulse is implemented as a temporal Gaussian. Args: amplitudes: electric field amplitudes in xyz-components frequency: frequency of the electric field peak: time where the pulse reaches its peak fwhm: full width at half maximum Returns: Function that computes the electric field \"\"\" static_part = jnp . array ( amplitudes ) sigma = fwhm / ( 2.0 * jnp . sqrt ( jnp . log ( 2 ))) return lambda t : ( static_part * jnp . exp ( - 1 j * jnp . pi / 2 + 1 j * frequency * ( t - peak )) * jnp . exp ( - (( t - peak ) ** 2 ) / sigma ** 2 ) )","title":"Pulse"},{"location":"api/#granad.fields.Ramp","text":"Function for computing ramping up time-harmonic electric fields. Parameters: amplitudes ( list [ float ] ) \u2013 electric field amplitudes in xyz-components frequency ( float ) \u2013 frequency ramp_duration ( float ) \u2013 specifies how long does the electric field ramps up time_ramp ( float ) \u2013 specifies time at which the field starts to ramp up Returns: \u2013 Function that computes the electric field as a functon of time Source code in src/granad/fields.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def Ramp ( amplitudes : list [ float ], frequency : float , ramp_duration : float , time_ramp : float , ): \"\"\"Function for computing ramping up time-harmonic electric fields. Args: amplitudes: electric field amplitudes in xyz-components frequency: frequency ramp_duration: specifies how long does the electric field ramps up time_ramp: specifies time at which the field starts to ramp up Returns: Function that computes the electric field as a functon of time \"\"\" static_part = jnp . array ( amplitudes ) p = 0.99 ramp_constant = 2 * jnp . log ( p / ( 1 - p )) / ramp_duration return lambda t : ( static_part * jnp . exp ( 1 j * frequency * t ) / ( 1 + 1.0 * jnp . exp ( - ramp_constant * ( t - time_ramp ))) )","title":"Ramp"},{"location":"api/#granad.fields.Wave","text":"Function for computing time-harmonic electric fields. Parameters: amplitudes ( list [ float ] ) \u2013 electric field amplitudes in xyz-components frequency ( float ) \u2013 frequency Returns: \u2013 Function that computes the electric field as a functon of time Source code in src/granad/fields.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def Wave ( amplitudes : list [ float ], frequency : float , ): \"\"\"Function for computing time-harmonic electric fields. Args: amplitudes: electric field amplitudes in xyz-components frequency: frequency Returns: Function that computes the electric field as a functon of time \"\"\" static_part = jnp . array ( amplitudes ) return lambda t : ( jnp . exp ( 1 j * frequency * t ) * static_part )","title":"Wave"},{"location":"api/#granad.materials.Material","text":"Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name ( str ) \u2013 The name of the material. species ( dict ) \u2013 Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals ( defaultdict [ list ] ) \u2013 A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions ( defaultdict [ dict ] ) \u2013 Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hamiltonian', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Note The Material class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hamiltonian and Coulomb interactions among these orbitals. graphene = ( Material ( \"graphene\" ) . lattice_constant ( 2.46 ) . lattice_basis ([ [ 1 , 0 , 0 ], [ - 0.5 , jnp . sqrt ( 3 ) / 2 , 0 ] ]) . add_orbital_species ( \"pz\" , l = 1 , atom = 'C' ) . add_orbital ( position = ( 0 , 0 ), tag = \"sublattice_1\" , species = \"pz\" ) . add_orbital ( position = ( - 1 / 3 , - 2 / 3 ), tag = \"sublattice_2\" , species = \"pz\" ) . add_interaction ( \"hamiltonian\" , participants = ( \"pz\" , \"pz\" ), parameters = [ 0.0 , 2.66 ], ) . add_interaction ( \"coulomb\" , participants = ( \"pz\" , \"pz\" ), parameters = [ 16.522 , 8.64 , 5.333 ], expression = lambda r : 1 / r + 0 j ) ) Source code in src/granad/materials.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 class Material : \"\"\" Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name (str): The name of the material. species (dict): Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals (defaultdict[list]): A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions (defaultdict[dict]): Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hamiltonian', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Note: The `Material` class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hamiltonian and Coulomb interactions among these orbitals. ```python graphene = ( Material(\"graphene\") .lattice_constant(2.46) .lattice_basis([ [1, 0, 0], [-0.5, jnp.sqrt(3)/2, 0] ]) .add_orbital_species(\"pz\", l=1, atom='C') .add_orbital(position=(0, 0), tag=\"sublattice_1\", species=\"pz\") .add_orbital(position=(-1/3, -2/3), tag=\"sublattice_2\", species=\"pz\") .add_interaction( \"hamiltonian\", participants=(\"pz\", \"pz\"), parameters=[0.0, 2.66], ) .add_interaction( \"coulomb\", participants=(\"pz\", \"pz\"), parameters=[16.522, 8.64, 5.333], expression=lambda r : 1/r + 0j ) ) ``` \"\"\" def __init__ ( self , name ): self . name = name self . species = {} self . orbitals = defaultdict ( list ) self . interactions = defaultdict ( dict ) self . _species_to_groups = {} self . dim = None def __str__ ( self ): description = f \"Material: { self . name } \\n \" if self . lattice_constant : description += f \" Lattice Constant: { self . lattice_constant } \u00c5 \\n \" if self . lattice_basis : description += f \" Lattice Basis: \\n { self . _lattice_basis } \\n \" if self . species : description += \" Orbital Species: \\n \" for species_name , attributes in self . species . items (): description += f \" { species_name } characterized by (n,l,m,s, atom name) = { attributes } \\n \" if self . orbitals : description += \" Orbitals: \\n \" for spec , orbs in self . orbitals . items (): for orb in orbs : description += f \" Position: { orb [ 'position' ] } , Tag: { orb [ 'tag' ] } , Species: { spec } \\n \" if self . interactions : description += \" Interactions: \\n \" for type_ , interaction in self . interactions . items (): for participants , coupling in interaction . items (): description += f \"\"\" Type: { type_ } , Participants: { participants } : NN Couplings: { ', ' . join ( map ( str , coupling [ 0 ])) } \"\"\" # Check if there's a docstring on the function if coupling [ 1 ] . __doc__ is not None : function_description = coupling [ 1 ] . __doc__ else : function_description = \"No description available for this function.\" description += f \"Other neighbors: { function_description } \\n \" return description def lattice_constant ( self , value ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . lattice_constant = value return self def lattice_basis ( self , values , periodic = None ): \"\"\" Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values (list of list of float): A list of vectors representing the lattice basis. periodic (list of int, optional): Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material: Returns self to enable method chaining. \"\"\" self . _lattice_basis = jnp . array ( values ) total = set ( range ( len ( self . _lattice_basis ))) periodic = set ( periodic ) if periodic is not None else total self . periodic = list ( periodic ) self . finite = list ( total - periodic ) self . dim = len ( self . periodic ) return self @_finalize def cut_flake ( self ): \"\"\" Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. \"\"\" pass def add_orbital ( self , position , species , tag = '' ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . orbitals [ species ] . append ({ 'position' : position , 'tag' : tag }) return self def add_orbital_species ( self , name , n = 0 , l = 0 , m = 0 , s = 0 , atom = '' ): \"\"\" Adds a species definition for orbitals in the material. Parameters: name (str): The name of the orbital species. n (int): Principal quantum number. l (int): Orbital angular momentum quantum number. m (int): Magnetic quantum number. s (int): Spin quantum number. atom (str, optional): Name of the atom the orbital belongs to. Returns: Material: Returns self to enable method chaining. \"\"\" self . species [ name ] = ( n , l , m , s , atom ) return self def add_interaction ( self , interaction_type , participants , parameters = None , expression = zero_coupling ): \"\"\" Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type (str): The type of interaction (e.g., 'hamiltonian', 'Coulomb'). participants (tuple): A tuple identifying the participants in the interaction. parameters (dict): Parameters relevant to the interaction. expression (function): A function defining the mathematical form of the interaction. Returns: Material: Returns self to enable method chaining. \"\"\" self . interactions [ interaction_type ][ participants ] = ( parameters if parameters is not None else [], expression ) return self def _get_positions_in_uc ( self , species = None ): if species is None : return jnp . array ( [ x [ \"position\" ] for orb in list ( self . orbitals . values ()) for x in orb ] ) return jnp . array ( [ orb_group [ 'position' ] for s in species for orb_group in self . orbitals [ s ] ] ) def _get_positions_in_lattice ( self , uc_positions , grid ): shift = jnp . array ( uc_positions ) @ self . _lattice_basis return self . lattice_constant * ( grid @ self . _lattice_basis + shift [:, None , :] ) . reshape ( shift . shape [ 0 ] * grid . shape [ 0 ], 3 ) def _get_grid ( self , ns ): grid = [( 1 ,) for i in range ( len ( self . finite ) + len ( self . periodic )) ] for i , p in enumerate ( self . periodic ): grid [ p ] = range ( * ns [ i ]) return jnp . array ( list ( product ( * ( x for x in grid ) ) ) ) def _keep_matching_positions ( self , positions , candidates ): idxs = ( jnp . round ( jnp . linalg . norm ( positions - candidates [:, None ], axis =- 1 ), 4 ) == 0 ) . nonzero ()[ 0 ] return candidates [ idxs ] def _couplings_to_function ( self , couplings , outside_fun , species ): if len ( couplings ) == 0 : return outside_fun couplings = jnp . array ( couplings ) . astype ( complex ) grid = self . _get_grid ( [ ( 0 , len ( couplings )) for i in range ( self . dim ) ] ) pos_uc_1 = self . _get_positions_in_uc ( ( species [ 0 ],) ) pos_uc_2 = self . _get_positions_in_uc ( ( species [ 1 ],) ) positions_1 = self . _get_positions_in_lattice ( pos_uc_1 , grid ) positions_2 = self . _get_positions_in_lattice ( pos_uc_2 , grid ) distances = jnp . unique ( jnp . round ( jnp . linalg . norm ( positions_1 - positions_2 [:, None , :], axis = 2 ), 5 ) )[: len ( couplings )] def inner ( d ): return jax . lax . cond ( jnp . min ( jnp . abs ( d - distances )) < 1e-5 , lambda x : couplings [ jnp . argmin ( jnp . abs ( x - distances ))], outside_fun , d , ) return inner def _set_couplings ( self , setter_func , interaction_type ): interaction_dict = self . interactions [ interaction_type ] for ( species_1 , species_2 ), couplings in interaction_dict . items (): distance_func = self . _couplings_to_function ( * couplings , ( species_1 , species_2 ) ) setter_func ( self . _species_to_groups [ species_1 ], self . _species_to_groups [ species_2 ], distance_func ) def _get_orbital_list ( self , allowed_positions , grid ): raw_list , layer_index = [], 0 for species , orb_group in self . orbitals . items (): for orb_uc in orb_group : uc_positions = jnp . array ( [ orb_uc [ 'position' ]] ) rs_positions = self . _get_positions_in_lattice ( uc_positions , grid ) final_positions = self . _keep_matching_positions ( allowed_positions , rs_positions ) for position in final_positions : orb = Orbital ( position = position , layer_index = layer_index , tag = orb_uc [ 'tag' ], group_id = self . _species_to_groups [ species ], energy_level = self . species [ species ][ 0 ], angular_momentum = self . species [ species ][ 1 ], angular_momentum_z = self . species [ species ][ 2 ], spin = self . species [ species ][ 3 ], atom_name = self . species [ species ][ 4 ] ) layer_index += 1 raw_list . append ( orb ) orbital_list = OrbitalList ( raw_list ) self . _set_couplings ( orbital_list . set_hamiltonian_groups , \"hamiltonian\" ) self . _set_couplings ( orbital_list . set_coulomb_groups , \"coulomb\" ) return orbital_list","title":"Material"},{"location":"api/#granad.materials.Material.add_interaction","text":"Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type ( str ) \u2013 The type of interaction (e.g., 'hamiltonian', 'Coulomb'). participants ( tuple ) \u2013 A tuple identifying the participants in the interaction. parameters ( dict , default: None ) \u2013 Parameters relevant to the interaction. expression ( function , default: zero_coupling ) \u2013 A function defining the mathematical form of the interaction. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def add_interaction ( self , interaction_type , participants , parameters = None , expression = zero_coupling ): \"\"\" Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type (str): The type of interaction (e.g., 'hamiltonian', 'Coulomb'). participants (tuple): A tuple identifying the participants in the interaction. parameters (dict): Parameters relevant to the interaction. expression (function): A function defining the mathematical form of the interaction. Returns: Material: Returns self to enable method chaining. \"\"\" self . interactions [ interaction_type ][ participants ] = ( parameters if parameters is not None else [], expression ) return self","title":"add_interaction"},{"location":"api/#granad.materials.Material.add_orbital","text":"Sets the lattice constant for the material. Parameters: value ( float ) \u2013 The lattice constant value. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 354 355 356 357 358 359 360 361 362 363 364 365 def add_orbital ( self , position , species , tag = '' ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . orbitals [ species ] . append ({ 'position' : position , 'tag' : tag }) return self","title":"add_orbital"},{"location":"api/#granad.materials.Material.add_orbital_species","text":"Adds a species definition for orbitals in the material. Parameters: name ( str ) \u2013 The name of the orbital species. n ( int , default: 0 ) \u2013 Principal quantum number. l ( int , default: 0 ) \u2013 Orbital angular momentum quantum number. m ( int , default: 0 ) \u2013 Magnetic quantum number. s ( int , default: 0 ) \u2013 Spin quantum number. atom ( str , default: '' ) \u2013 Name of the atom the orbital belongs to. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 def add_orbital_species ( self , name , n = 0 , l = 0 , m = 0 , s = 0 , atom = '' ): \"\"\" Adds a species definition for orbitals in the material. Parameters: name (str): The name of the orbital species. n (int): Principal quantum number. l (int): Orbital angular momentum quantum number. m (int): Magnetic quantum number. s (int): Spin quantum number. atom (str, optional): Name of the atom the orbital belongs to. Returns: Material: Returns self to enable method chaining. \"\"\" self . species [ name ] = ( n , l , m , s , atom ) return self","title":"add_orbital_species"},{"location":"api/#granad.materials.Material.cut_flake","text":"Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. Source code in src/granad/materials.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 @_finalize def cut_flake ( self ): \"\"\" Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. \"\"\" pass","title":"cut_flake"},{"location":"api/#granad.materials.Material.lattice_basis","text":"Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values ( list of list of float ) \u2013 A list of vectors representing the lattice basis. periodic ( list of int , default: None ) \u2013 Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def lattice_basis ( self , values , periodic = None ): \"\"\" Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values (list of list of float): A list of vectors representing the lattice basis. periodic (list of int, optional): Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material: Returns self to enable method chaining. \"\"\" self . _lattice_basis = jnp . array ( values ) total = set ( range ( len ( self . _lattice_basis ))) periodic = set ( periodic ) if periodic is not None else total self . periodic = list ( periodic ) self . finite = list ( total - periodic ) self . dim = len ( self . periodic ) return self","title":"lattice_basis"},{"location":"api/#granad.materials.Material.lattice_constant","text":"Sets the lattice constant for the material. Parameters: value ( float ) \u2013 The lattice constant value. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 302 303 304 305 306 307 308 309 310 311 312 313 def lattice_constant ( self , value ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . lattice_constant = value return self","title":"lattice_constant"},{"location":"api/#granad.materials.MaterialCatalog","text":"A class to manage and access built-in material properties within a simulation or modeling framework. This class provides a central repository for predefined materials, allowing for easy retrieval and description of their properties. Attributes: _materials ( dict ) \u2013 A private dictionary that maps material names to their respective data objects. This dictionary is pre-populated with several example materials such as graphene and MoS2. Methods: Name Description get Retrieves the data object associated with the given material name. describe Prints a description or the data object of the specified material. available Prints a list of all available materials stored in the catalog. Source code in src/granad/materials.py 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 class MaterialCatalog : \"\"\" A class to manage and access built-in material properties within a simulation or modeling framework. This class provides a central repository for predefined materials, allowing for easy retrieval and description of their properties. Attributes: _materials (dict): A private dictionary that maps material names to their respective data objects. This dictionary is pre-populated with several example materials such as graphene and MoS2. Methods: get(material): Retrieves the data object associated with the given material name. describe(material): Prints a description or the data object of the specified material. available(): Prints a list of all available materials stored in the catalog. \"\"\" _materials = { \"graphene\" : _graphene , \"ssh\" : _ssh , \"metal_1d\" : _metal_1d , \"MoS2\" : _MoS2 , \"hBN\" : _hBN } @staticmethod def get ( material : str ): \"\"\" Retrieves the material data object for the specified material. Args: material (str): The name of the material to retrieve. Returns: The data object associated with the specified material. Example: ```python graphene_data = MaterialCatalog.get('graphene') ``` \"\"\" return MaterialCatalog . _materials [ material ] @staticmethod def describe ( material : str ): \"\"\" Prints a description or the raw data of the specified material from the catalog. Args: material (str): The name of the material to describe. Example: ```python MaterialCatalog.describe('graphene') ``` \"\"\" print ( MaterialCatalog . _materials [ material ]) @staticmethod def available (): \"\"\" Prints a list of all materials available in the catalog. Example: ```python MaterialCatalog.available() ``` \"\"\" available_materials = \" \\n \" . join ( MaterialCatalog . _materials . keys ()) print ( f \"Available materials: \\n { available_materials } \" )","title":"MaterialCatalog"},{"location":"api/#granad.materials.MaterialCatalog.available","text":"Prints a list of all materials available in the catalog. Example MaterialCatalog . available () Source code in src/granad/materials.py 699 700 701 702 703 704 705 706 707 708 709 710 @staticmethod def available (): \"\"\" Prints a list of all materials available in the catalog. Example: ```python MaterialCatalog.available() ``` \"\"\" available_materials = \" \\n \" . join ( MaterialCatalog . _materials . keys ()) print ( f \"Available materials: \\n { available_materials } \" )","title":"available"},{"location":"api/#granad.materials.MaterialCatalog.describe","text":"Prints a description or the raw data of the specified material from the catalog. Parameters: material ( str ) \u2013 The name of the material to describe. Example MaterialCatalog . describe ( 'graphene' ) Source code in src/granad/materials.py 684 685 686 687 688 689 690 691 692 693 694 695 696 697 @staticmethod def describe ( material : str ): \"\"\" Prints a description or the raw data of the specified material from the catalog. Args: material (str): The name of the material to describe. Example: ```python MaterialCatalog.describe('graphene') ``` \"\"\" print ( MaterialCatalog . _materials [ material ])","title":"describe"},{"location":"api/#granad.materials.MaterialCatalog.get","text":"Retrieves the material data object for the specified material. Parameters: material ( str ) \u2013 The name of the material to retrieve. Returns: \u2013 The data object associated with the specified material. Example graphene_data = MaterialCatalog . get ( 'graphene' ) Source code in src/granad/materials.py 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 @staticmethod def get ( material : str ): \"\"\" Retrieves the material data object for the specified material. Args: material (str): The name of the material to retrieve. Returns: The data object associated with the specified material. Example: ```python graphene_data = MaterialCatalog.get('graphene') ``` \"\"\" return MaterialCatalog . _materials [ material ]","title":"get"},{"location":"api/#granad.materials.cut_flake_1d","text":"Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. unit_cells ( int ) \u2013 The number of unit cells to include in the flake. plot ( bool , default: False ) \u2013 If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list \u2013 A list of orbitals positioned within the specified range of the material's lattice. Note The function utilizes internal methods of the Material class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. Source code in src/granad/materials.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def cut_flake_1d ( material , unit_cells , plot = False ): \"\"\" Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material (Material): The material instance from which to cut the flake. unit_cells (int): The number of unit cells to include in the flake. plot (bool, optional): If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list: A list of orbitals positioned within the specified range of the material's lattice. Note: The function utilizes internal methods of the `Material` class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. \"\"\" orbital_positions_uc = material . _get_positions_in_uc () grid = material . _get_grid ( [( 0 , unit_cells )] ) orbital_positions = material . _get_positions_in_lattice ( orbital_positions_uc , grid ) if plot : _display_lattice_cut ( orbital_positions , orbital_positions ) orbital_positions = jnp . unique ( orbital_positions , axis = 0 ) return material . _get_orbital_list ( orbital_positions , grid )","title":"cut_flake_1d"},{"location":"api/#granad.materials.cut_flake_2d","text":"Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. polygon ( array - like ) \u2013 An array of coordinates defining the vertices of the polygon within which to cut the flake. plot ( bool , default: False ) \u2013 If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number ( int , default: 2 ) \u2013 The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list \u2013 A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Note The function assumes the underlying lattice to be in the xy-plane. Source code in src/granad/materials.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def cut_flake_2d ( material , polygon , plot = False , minimum_neighbor_number : int = 2 ): \"\"\" Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material (Material): The material instance from which to cut the flake. polygon (array-like): An array of coordinates defining the vertices of the polygon within which to cut the flake. plot (bool, optional): If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number (int, optional): The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list: A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Note: The function assumes the underlying lattice to be in the xy-plane. \"\"\" def _prune_neighbors ( positions , minimum_neighbor_number , remaining_old = jnp . inf ): \"\"\" Recursively prunes positions to ensure each position has a sufficient number of neighboring positions based on a minimum distance calculated from the unique set of distances between positions. Parameters: positions (array-like): Array of positions to prune. minimum_neighbor_number (int): Minimum required number of neighbors for a position to be retained. remaining_old (int): The count of positions remaining from the previous iteration; used to detect convergence. Returns: array-like: Array of positions that meet the neighbor count criterion. \"\"\" if minimum_neighbor_number <= 0 : return positions distances = jnp . round ( jnp . linalg . norm ( positions [:, material . periodic ] - positions [:, None , material . periodic ], axis =- 1 ), 4 ) minimum = jnp . unique ( distances )[ 1 ] mask = ( distances <= minimum ) . sum ( axis = 0 ) > minimum_neighbor_number remaining = mask . sum () if remaining_old == remaining : return positions [ mask ] else : return _prune_neighbors ( positions [ mask ], minimum_neighbor_number , remaining ) # to cover the plane, we solve the linear equation P = L C, where P are the polygon vertices, L is the lattice basis and C are the coefficients L = material . _lattice_basis [ material . periodic ,: 2 ] * material . lattice_constant coeffs = jnp . linalg . inv ( L . T ) @ polygon . T # we just take the largest extent of the shape u1 , u2 = jnp . ceil ( coeffs ) . max ( axis = 1 ) l1 , l2 = jnp . floor ( coeffs ) . min ( axis = 1 ) grid = material . _get_grid ( [ ( int ( l1 ), int ( u1 )), ( int ( l2 ), int ( u2 )) ] ) # get atom positions in the unit cell in fractional coordinates orbital_positions = material . _get_positions_in_uc () unit_cell_fractional_atom_positions = jnp . unique ( jnp . round ( orbital_positions , 6 ), axis = 0 ) initial_atom_positions = material . _get_positions_in_lattice ( unit_cell_fractional_atom_positions , grid ) polygon_path = Path ( polygon ) flags = polygon_path . contains_points ( initial_atom_positions [:, : 2 ]) # get atom positions where every atom has at least minimum_neighbor_number neighbors final_atom_positions = _prune_neighbors ( initial_atom_positions [ flags ], minimum_neighbor_number ) if plot == True : _display_lattice_cut ( initial_atom_positions , final_atom_positions , polygon ) return material . _get_orbital_list ( final_atom_positions , grid )","title":"cut_flake_2d"},{"location":"api/#granad.materials.cut_flake_generic","text":"Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. grid_range ( list of tuples ) \u2013 Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list \u2013 A list of orbitals within the specified grid range, uniquely positioned. Note The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. Source code in src/granad/materials.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def cut_flake_generic ( material , grid_range ): \"\"\" Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material (Material): The material instance from which to cut the flake. grid_range (list of tuples): Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list: A list of orbitals within the specified grid range, uniquely positioned. Note: The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. \"\"\" orbital_positions_uc = material . _get_positions_in_uc () grid = material . _get_grid ( grid_range ) orbital_positions = material . _get_positions_in_lattice ( orbital_positions_uc , grid ) orbital_positions = jnp . unique ( orbital_positions , axis = 0 ) return material . _get_orbital_list ( orbital_positions , grid )","title":"cut_flake_generic"},{"location":"api/#granad.materials.ohno_potential","text":"Generates a callable that represents a regularized Coulomb-like potential. The potential function is parameterized to provide flexibility in adjusting the starting value and an offset, which can be used to avoid singularities at zero distance. Parameters: offset ( float , default: 0 ) \u2013 The offset added to the distance to prevent division by zero and to regularize the potential at short distances. Defaults to 0. start ( float , default: 14.399 ) \u2013 The initial strength or scaling factor of the potential. Defaults to 14.399. Returns: \u2013 Callable[[float], complex]: A function that takes a distance 'd' and returns the computed Coulomb-like potential as a complex number. Note potential = ohno_potential () print ( potential ( 1 )) # Output: (14.399 + 0j) if default parameters used Source code in src/granad/materials.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def ohno_potential ( offset = 0 , start = 14.399 ): \"\"\" Generates a callable that represents a regularized Coulomb-like potential. The potential function is parameterized to provide flexibility in adjusting the starting value and an offset, which can be used to avoid singularities at zero distance. Args: offset (float): The offset added to the distance to prevent division by zero and to regularize the potential at short distances. Defaults to 0. start (float): The initial strength or scaling factor of the potential. Defaults to 14.399. Returns: Callable[[float], complex]: A function that takes a distance 'd' and returns the computed Coulomb-like potential as a complex number. Note: ```python potential = ohno_potential() print(potential(1)) # Output: (14.399 + 0j) if default parameters used ``` \"\"\" def inner ( d ): \"\"\"Coupling with a (regularized) Coulomb-like potential\"\"\" return start / ( d + offset ) + 0 j return inner","title":"ohno_potential"},{"location":"api/#granad.materials.zero_coupling","text":"Returns a zero coupling constant as a complex number. Parameters: d ( float ) \u2013 A parameter (typically representing distance or some other factor) that is ignored by the function, as the output is always zero. Returns: complex \u2013 Returns 0.0 as a complex number (0.0j). Source code in src/granad/materials.py 15 16 17 18 19 20 21 22 23 24 25 def zero_coupling ( d ): \"\"\" Returns a zero coupling constant as a complex number. Args: d (float): A parameter (typically representing distance or some other factor) that is ignored by the function, as the output is always zero. Returns: complex: Returns 0.0 as a complex number (0.0j). \"\"\" return 0.0 j","title":"zero_coupling"},{"location":"api/#granad.shapes.Circle","text":"Generates the vertices of a polygon that approximates a circle, given the radius and the number of vertices. The circle approximation is created by calculating points along the circumference using the radius provided. The number of vertices specifies how many sides the polygon will have, thus controlling the granularity of the approximation. By default, an octagon is generated. Parameters: radius ( float ) \u2013 The radius of the circle to approximate, in arbitrary units. n_vertices ( int , default: 8 ) \u2013 The number of vertices (or sides) of the approximating polygon. Default is 8. Returns: \u2013 jax.numpy.ndarray: An array of shape (n_vertices+1, 2), representing the vertices of the polygon, including the first vertex repeated at the end to close the shape. Note The accuracy of the circle approximation improves with an increase in the number of vertices. For a smoother circle, increase the number of vertices. # Create an approximate circle with a radius of 20 units and default vertices circle_octagon = Circle ( 20 ) # Create an approximate circle with a radius of 15 units using 12 vertices circle_dodecagon = Circle ( 15 , 12 ) Source code in src/granad/shapes.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def Circle ( radius , n_vertices = 8 ): \"\"\" Generates the vertices of a polygon that approximates a circle, given the radius and the number of vertices. The circle approximation is created by calculating points along the circumference using the radius provided. The number of vertices specifies how many sides the polygon will have, thus controlling the granularity of the approximation. By default, an octagon is generated. Parameters: radius (float): The radius of the circle to approximate, in arbitrary units. n_vertices (int): The number of vertices (or sides) of the approximating polygon. Default is 8. Returns: jax.numpy.ndarray: An array of shape (n_vertices+1, 2), representing the vertices of the polygon, including the first vertex repeated at the end to close the shape. Note: The accuracy of the circle approximation improves with an increase in the number of vertices. For a smoother circle, increase the number of vertices. ```python # Create an approximate circle with a radius of 20 units and default vertices circle_octagon = Circle(20) # Create an approximate circle with a radius of 15 units using 12 vertices circle_dodecagon = Circle(15, 12) ``` \"\"\" circle = jnp . array ([ ( radius * jnp . cos ( 2 * jnp . pi * i / n_vertices ), radius * jnp . sin ( 2 * jnp . pi * i / n_vertices )) for i in range ( n_vertices ) ]) return jnp . vstack ([ circle , circle [ 0 ]])","title":"Circle"},{"location":"api/#granad.shapes.Hexagon","text":"Generates the vertices of a regular hexagon given the side length. The hexagon is oriented such that one vertex points upwards and the function is designed to be used with the @_edge_type decorator for positional adjustments and rotations. Parameters: length ( float ) \u2013 The length of each side of the hexagon, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (7, 2), representing the vertices of the hexagon, including the starting vertex repeated at the end for drawing closed shapes. Note # Hexagon with side length of 1.0 angstrom hexagon = Hexagon ( 1.0 ) Source code in src/granad/shapes.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @_edge_type def Hexagon ( length ): \"\"\" Generates the vertices of a regular hexagon given the side length. The hexagon is oriented such that one vertex points upwards and the function is designed to be used with the @_edge_type decorator for positional adjustments and rotations. Parameters: length (float): The length of each side of the hexagon, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (7, 2), representing the vertices of the hexagon, including the starting vertex repeated at the end for drawing closed shapes. Note: ```python # Hexagon with side length of 1.0 angstrom hexagon = Hexagon(1.0) ``` \"\"\" n = 6 s = 1 angle = 2 * jnp . pi / n vertices = length * jnp . array ( [ ( s * jnp . cos ( i * angle ), s * jnp . sin ( i * angle )) for i in [ x for x in range ( n )] + [ 0 ] ] ) return vertices","title":"Hexagon"},{"location":"api/#granad.shapes.Rectangle","text":"Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x ( float ) \u2013 The length of the rectangle along the x-axis, specified in angstroms. length_y ( float ) \u2013 The length of the rectangle along the y-axis, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Note # Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle ( 2.0 , 1.0 ) Source code in src/granad/shapes.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @_edge_type def Rectangle ( length_x , length_y ): \"\"\" Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x (float): The length of the rectangle along the x-axis, specified in angstroms. length_y (float): The length of the rectangle along the y-axis, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Note: ```python # Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle(2.0, 1.0) ``` \"\"\" vertices = jnp . array ( [ ( - 1 * length_x , - 0.5 * length_y ), ( 1 * length_x , - 0.5 * length_y ), ( 1 * length_x , 0.5 * length_y ), ( - 1 * length_x , 0.5 * length_y ), ( - 1 * length_x , - 0.5 * length_y ), ] ) return vertices","title":"Rectangle"},{"location":"api/#granad.shapes.Rhomboid","text":"Generates the vertices of a rhomboid given the base length and height. The rhomboid is initially oriented with the base along the x-axis, and one angle being 30 degrees, designed to be adjusted for position and orientation using the @_edge_type decorator. Parameters: base ( float ) \u2013 The length of the base of the rhomboid, specified in angstroms. height ( float ) \u2013 The vertical height of the rhomboid, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rhomboid, starting and ending at the same vertex to complete the shape. Note # Rhomboid with base 2.0 angstroms and height 1.0 angstrom rhomboid = Rhomboid ( 2.0 , 1.0 ) Source code in src/granad/shapes.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 @_edge_type def Rhomboid ( base , height ): \"\"\" Generates the vertices of a rhomboid given the base length and height. The rhomboid is initially oriented with the base along the x-axis, and one angle being 30 degrees, designed to be adjusted for position and orientation using the @_edge_type decorator. Parameters: base (float): The length of the base of the rhomboid, specified in angstroms. height (float): The vertical height of the rhomboid, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rhomboid, starting and ending at the same vertex to complete the shape. Note: ```python # Rhomboid with base 2.0 angstroms and height 1.0 angstrom rhomboid = Rhomboid(2.0, 1.0) ``` \"\"\" angle = jnp . radians ( 30 ) vertices = jnp . array ( [ ( 0 , 0 ), ( base , 0 ), ( base + height * jnp . sin ( angle ), height * jnp . cos ( angle )), ( height * jnp . sin ( angle ), height * jnp . cos ( angle )), ( 0 , 0 ), ] ) return vertices","title":"Rhomboid"},{"location":"api/#granad.shapes.Triangle","text":"Generates the vertices of an equilateral triangle given the side length. The triangle is oriented such that one vertex points upwards and the base is horizontal. This function is designed to be used with the @_edge_type decorator, which adds functionality to shift the triangle's position or rotate it based on additional 'shift' and 'armchair' parameters passed to the function. Parameters: side_length ( float ) \u2013 The length of each side of the triangle, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (4, 2), representing the vertices of the triangle, including the starting vertex repeated at the end to facilitate drawing closed shapes. Note # Create a triangle with side length of 1.0 angstrom, no shift or rotation triangle = Triangle ( 1.0 ) # Create a triangle with side length of 1.0 angstrom, shifted by [1, 1] units triangle_shifted = Triangle ( 1.0 , shift = [ 1 , 1 ]) # Create a triangle with side length of 1.0 angstrom, rotated by 90 degrees (armchair orientation) triangle_rotated = Triangle ( 1.0 , armchair = True ) Source code in src/granad/shapes.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @_edge_type def Triangle ( side_length ): \"\"\" Generates the vertices of an equilateral triangle given the side length. The triangle is oriented such that one vertex points upwards and the base is horizontal. This function is designed to be used with the @_edge_type decorator, which adds functionality to shift the triangle's position or rotate it based on additional 'shift' and 'armchair' parameters passed to the function. Parameters: side_length (float): The length of each side of the triangle, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (4, 2), representing the vertices of the triangle, including the starting vertex repeated at the end to facilitate drawing closed shapes. Note: ```python # Create a triangle with side length of 1.0 angstrom, no shift or rotation triangle = Triangle(1.0) # Create a triangle with side length of 1.0 angstrom, shifted by [1, 1] units triangle_shifted = Triangle(1.0, shift=[1, 1]) # Create a triangle with side length of 1.0 angstrom, rotated by 90 degrees (armchair orientation) triangle_rotated = Triangle(1.0, armchair=True) ``` \"\"\" vertices = side_length * jnp . array ( [ ( 0 , jnp . sqrt ( 3 ) / 3 ), ( - 0.5 , - jnp . sqrt ( 3 ) / 6 ), ( 0.5 , - jnp . sqrt ( 3 ) / 6 ), ( 0 , jnp . sqrt ( 3 ) / 3 ), ] ) return vertices","title":"Triangle"},{"location":"api/#granad.potentials.BareHamiltonian","text":"Represents the unperturbed single-particle tight-binding mean field Hamiltonian, denoted as \\(= h^{(0)}\\) . Returns: Function \u2013 Provides the bare Hamiltonian matrix, representing the unperturbed state of the system. Source code in src/granad/potentials.py 152 153 154 155 156 157 158 def BareHamiltonian (): \"\"\"Represents the unperturbed single-particle tight-binding mean field Hamiltonian, denoted as $= h^{(0)}$. Returns: Function: Provides the bare Hamiltonian matrix, representing the unperturbed state of the system. \"\"\" return lambda t , r , args : args . hamiltonian","title":"BareHamiltonian"},{"location":"api/#granad.potentials.Coulomb","text":"Calculates the induced Coulomb potential based on deviations from a stationary density matrix, represented as \\(\\sim \\lambda C(\\rho-\\rho_0)\\) . Here, \\(\\lambda\\) is a scaling factor. Returns: Function \u2013 Computes the Coulomb interaction scaled by deviations from the stationary state. Source code in src/granad/potentials.py 144 145 146 147 148 149 150 def Coulomb (): \"\"\"Calculates the induced Coulomb potential based on deviations from a stationary density matrix, represented as $\\sim \\lambda C(\\\\rho-\\\\rho_0)$. Here, $\\lambda$ is a scaling factor. Returns: Function: Computes the Coulomb interaction scaled by deviations from the stationary state. \"\"\" return lambda t , r , args : jnp . diag ( args . coulomb_scaled @ ( r - args . stationary_density_matrix ) . diagonal () * args . electrons )","title":"Coulomb"},{"location":"api/#granad.potentials.Diamagnetic","text":"Diamagnetic Coulomb gauge coupling to an external vector potential represented as \\(\\sim A^2\\) . Parameters: vector_potential ( callable ) \u2013 Function that returns the vector potential at a given time. Returns: Function \u2013 Computes the square of the vector potential, representing diamagnetic interactions. Source code in src/granad/potentials.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def Diamagnetic ( vector_potential ): \"\"\"Diamagnetic Coulomb gauge coupling to an external vector potential represented as $\\sim A^2$. Args: vector_potential (callable): Function that returns the vector potential at a given time. Returns: Function: Computes the square of the vector potential, representing diamagnetic interactions. \"\"\" def inner ( t , r , args ): # ~ A^2 q = m = 1 return jnp . diag ( q ** 2 / m * 0.5 * jnp . sum ( vector_potential ( t ) ** 2 , axis = 1 )) return inner","title":"Diamagnetic"},{"location":"api/#granad.potentials.DipoleGauge","text":"Dipole gauge coupling to an external electric field, represented as \\(E \\cdot \\hat{P}\\) . The dipole / polarization operator is defined by \\(P^{c}_{ij} = <i|\\hat{r}_c|j>\\) , where \\(i,j\\) correspond to localized (TB) orbitals, such that \\(\\hat{r}^c|i> = r^c{i}|i>\\) in absence of dipole transitions. Parameters: illumination ( callable ) \u2013 Function that returns the electric field at a given time. use_rwa ( bool , default: False ) \u2013 If True, uses the rotating wave approximation which simplifies the calculations by considering only resonant terms. intra_only ( bool , default: False ) \u2013 If True, subtracts the diagonal of the potential matrix, focusing only on the interactions between different elements. Returns: Function \u2013 Computes the electric potential based on the given illumination and options for RWA and intramolecular interactions. Source code in src/granad/potentials.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def DipoleGauge ( illumination , use_rwa = False , intra_only = False ): \"\"\"Dipole gauge coupling to an external electric field, represented as $E \\cdot \\hat{P}$. The dipole / polarization operator is defined by $P^{c}_{ij} = <i|\\hat{r}_c|j>$, where $i,j$ correspond to localized (TB) orbitals, such that $\\hat{r}^c|i> = r^c{i}|i>$ in absence of dipole transitions. Args: illumination (callable): Function that returns the electric field at a given time. use_rwa (bool): If True, uses the rotating wave approximation which simplifies the calculations by considering only resonant terms. intra_only (bool): If True, subtracts the diagonal of the potential matrix, focusing only on the interactions between different elements. Returns: Function: Computes the electric potential based on the given illumination and options for RWA and intramolecular interactions. \"\"\" def electric_potential ( t , r , args ): return jnp . einsum ( einsum_string , args . dipole_operator , illumination ( t ) . real ) def electric_potential_rwa ( t , r , args ): # the missing real part is crucial here! the RWA (for real dipole moments) makes the fields complex and divides by 2 total_field_potential = jnp . einsum ( einsum_string , args . dipole_operator , illumination ( t )) # Get the indices for the lower triangle, excluding the diagonal lower_indices = jnp . tril_indices ( total_field_potential . shape [ 0 ], - 1 ) # Replace elements in the lower triangle with their complex conjugates tmp = total_field_potential . at [ lower_indices ] . set ( jnp . conj ( total_field_potential [ lower_indices ]) ) # make hermitian again return tmp - 1 j * jnp . diag ( tmp . diagonal () . imag ) # TODO: redundant evaluation maybe_diag = lambda f : f if intra_only == True : maybe_diag = lambda f : lambda t , r , args : f ( t , r , args ) - jnp . diag ( f ( t , r , args ) . diagonal () ) einsum_string = 'Kij,K->ij' if illumination ( 0. ) . shape == ( 3 ,) else 'Kij,iK->ij' if use_rwa == True : return maybe_diag ( electric_potential_rwa ) return maybe_diag ( electric_potential )","title":"DipoleGauge"},{"location":"api/#granad.potentials.DipolePulse","text":"Function to compute the potential due to a pulsed dipole. The potential can optionally include a 'kick' which is an instantaneous spike at a specific time. Parameters: dipole_moment \u2013 Vector representing the dipole moment in xyz-components. source_location \u2013 Location of the source of the dipole in xyz-coordinates. omega \u2013 Angular frequency of the oscillation. sigma \u2013 Standard deviation of the pulse's temporal Gaussian profile. t0 \u2013 Time at which the pulse is centered (default is 0.0). kick \u2013 If True, adds an instantaneous spike to the pulse at time t0 (default is False). Returns: \u2013 Function that computes the dipole potential at a given time and location, with adjustments for distance and orientation relative to the dipole. Note Recommended only with solver=diffrax.Dopri8. Source code in src/granad/potentials.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def DipolePulse ( dipole_moment , source_location , omega , sigma , t0 = 0.0 , kick = False ): \"\"\"Function to compute the potential due to a pulsed dipole. The potential can optionally include a 'kick' which is an instantaneous spike at a specific time. Args: dipole_moment: Vector representing the dipole moment in xyz-components. source_location: Location of the source of the dipole in xyz-coordinates. omega: Angular frequency of the oscillation. sigma: Standard deviation of the pulse's temporal Gaussian profile. t0: Time at which the pulse is centered (default is 0.0). kick: If True, adds an instantaneous spike to the pulse at time t0 (default is False). Returns: Function that computes the dipole potential at a given time and location, with adjustments for distance and orientation relative to the dipole. Note: Recommended only with solver=diffrax.Dopri8. \"\"\" loc = jnp . array ( source_location )[:, None ] dip = jnp . array ( dipole_moment ) f = lambda t : jnp . cos ( omega * t ) * jnp . exp ( - ( t - t0 ) ** 2 / sigma ** 2 ) if kick == True : f = lambda t : jnp . abs ( t - t0 ) < 1e-10 def pot ( t , r , args ): distances = args . dipole_operator . diagonal ( axis1 =- 1 , axis2 =- 2 ) - loc r_term = ( dip @ distances ) / jnp . linalg . norm ( distances , axis = 0 ) return jnp . diag ( jnp . nan_to_num ( r_term ) * f ( t ) ) return pot","title":"DipolePulse"},{"location":"api/#granad.potentials.Induced","text":"Calculates the induced potential, which propagates the coulomb effect of induced charges in the system according to \\(\\sim \\sum_r q_r/|r-r'|\\) . Returns: Function \u2013 Computes the induced potential at a given time and location based on charge propagation. Source code in src/granad/potentials.py 103 104 105 106 107 108 109 110 111 112 def Induced (): \"\"\"Calculates the induced potential, which propagates the coulomb effect of induced charges in the system according to $\\sim \\sum_r q_r/|r-r'|$. Returns: Function: Computes the induced potential at a given time and location based on charge propagation. \"\"\" def inner ( t , r , args ): field = jnp . einsum ( \"ijK,j->iK\" , args . propagator , - args . electrons * r . diagonal ()) return jnp . einsum ( \"Kij,iK->ij\" , args . dipole_operator , field . real ) return inner","title":"Induced"},{"location":"api/#granad.potentials.Paramagnetic","text":"Paramagnetic Coulomb gauge coupling to an external vector potential represented as \\(\\sim A \\hat{v}\\) . Parameters: vector_potential ( callable ) \u2013 Function that returns the vector potential at a given time. Returns: Function \u2013 Computes the interaction of the vector potential with the velocity operator. Source code in src/granad/potentials.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def Paramagnetic ( vector_potential ): \"\"\"Paramagnetic Coulomb gauge coupling to an external vector potential represented as $\\sim A \\hat{v}$. Args: vector_potential (callable): Function that returns the vector potential at a given time. Returns: Function: Computes the interaction of the vector potential with the velocity operator. \"\"\" def inner ( t , r , args ): # ~ A p q = 1 return - q * jnp . einsum ( \"Kij, iK -> ij\" , args . velocity_operator , vector_potential ( t )) return inner","title":"Paramagnetic"},{"location":"api/#granad.potentials.WavePulse","text":"Function to compute the wave potential using amplitude modulation. This function creates a pulse with temporal Gaussian characteristics and can include an optional 'kick' which introduces an instantaneous amplitude peak. Parameters: amplitudes \u2013 List of amplitudes for the wave components in xyz-directions. omega \u2013 Angular frequency of the wave oscillation. sigma \u2013 Standard deviation of the Gaussian pulse in time. t0 \u2013 Central time around which the pulse peaks (default is 0.0). kick \u2013 If set to True, an instantaneous spike is added to the pulse at time t0 instead of the Gaussian modulated cosine wave (default is False). Returns: \u2013 Function that computes the potential at a given time and location, incorporating the wave characteristics and specified modulations. Note This function, when not kicked, computes the same term as Pulse . Source code in src/granad/potentials.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def WavePulse ( amplitudes , omega , sigma , t0 = 0.0 , kick = False ): \"\"\"Function to compute the wave potential using amplitude modulation. This function creates a pulse with temporal Gaussian characteristics and can include an optional 'kick' which introduces an instantaneous amplitude peak. Args: amplitudes: List of amplitudes for the wave components in xyz-directions. omega: Angular frequency of the wave oscillation. sigma: Standard deviation of the Gaussian pulse in time. t0: Central time around which the pulse peaks (default is 0.0). kick: If set to True, an instantaneous spike is added to the pulse at time `t0` instead of the Gaussian modulated cosine wave (default is False). Returns: Function that computes the potential at a given time and location, incorporating the wave characteristics and specified modulations. Note: This function, when not kicked, computes the same term as `Pulse`. \"\"\" amplitudes = jnp . array ( amplitudes ) f = lambda t : amplitudes * jnp . cos ( omega * t ) * jnp . exp ( - ( t - t0 ) ** 2 / sigma ** 2 ) if kick == True : f = lambda t : amplitudes * ( jnp . abs ( t - t0 ) < 1e-10 ) def pot ( t , r , args ): return jnp . einsum ( 'Kij,K->ij' , args . dipole_operator , f ( t )) return pot","title":"WavePulse"},{"location":"units/","text":"Units GRANAD uses the following unit conventions Quantity Unit Energy eV Distance \u00c5ngstr\u00f6m Time \\(0.659 \\cdot 10^{-15}\\) s Charge \\(1.6 \\cdot 10^{-19}\\) C Electric field strength \\(10^{10}\\) V/m","title":"Units"},{"location":"units/#units","text":"GRANAD uses the following unit conventions Quantity Unit Energy eV Distance \u00c5ngstr\u00f6m Time \\(0.659 \\cdot 10^{-15}\\) s Charge \\(1.6 \\cdot 10^{-19}\\) C Electric field strength \\(10^{10}\\) V/m","title":"Units"},{"location":"tutorials/a_getting_started/","text":"Getting started We introduce the basics of GRANAD and do a quick simulation. Introduction GRANAD lets you simulate structures from a few orbitals up to finite bulks. The process of specifying a structure is designed to be easy and interactive: You can add, shift, combine and manipulate parts of your structure at varying levels of detail involving large groups of orbitals or just single orbitals. To this end, GRANAD offers three fundamental datatypes: Orbitals are the fundamental building block of a structure. OrbitalLists represent a concrete structure. In essence, you can handle these as normal Python lists with additional information regarding Orbital coupling. Materials are a stand-in for infinite bulks. You can cut finite pieces from these bulks, which are again just lists of orbitals. We will use each of them below to set up a small graphene nanoantenna coupling to an external field. Once this is done, we will use GRANAD's main feature and simulate the induced dynamics in the nanoantenna directly in time domain. Orbitals At its core, GRANAD is all about orbitals. Here we create an orbital and print its properties to understand its structure. from granad import Orbital my_first_orbital = Orbital ( tag = \"a tag contains arbitrary information\" , ) print ( my_first_orbital ) {'position': Array([0., 0., 0.], dtype=float64), 'layer_index': None, 'tag': 'a tag contains arbitrary information', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': GroupId(id=1)} The group_id, unsurprisingly, groups orbitals. It shouldn't concern us too much now. From the output above, we see that orbitals are placed at the origin by default. We can change this by passing an explicit position. my_second_orbital = Orbital ( position = ( 1 , 1 , 1 ), tag = \"a new, shifted orbital\" , ) print ( my_second_orbital ) {'position': Array([1., 1., 1.], dtype=float64), 'layer_index': None, 'tag': 'a new, shifted orbital', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': GroupId(id=2)} This is all there is to know about orbitals! Materials Materials are stuff you can cut orbitals from. You can define one yourself or import a prebuilt one. We will use the latter option. from granad import MaterialCatalog MaterialCatalog . available () Available materials: graphene ssh metal_1d MoS2 hBN Let's inspect a material. MaterialCatalog . describe ( \"graphene\" ) Material: graphene Lattice Constant: 2.46 \u00c5 Lattice Basis: [[ 1. 0. 0. ] [-0.5 0.8660254 0. ]] Orbital Species: pz characterized by (n,l,m,s, atom name) = (0, 1, 0, 0, 'C') Orbitals: Position: (0, 0), Tag: sublattice_1, Species: pz Position: (-0.3333333333333333, -0.6666666666666666), Tag: sublattice_2, Species: pz Interactions: Type: hamiltonian, Participants: ('pz', 'pz'): NN Couplings: 0.0, 2.66 Other neighbors: Returns a zero coupling constant as a complex number. Args: d (float): A parameter (typically representing distance or some other factor) that is ignored by the function, as the output is always zero. Returns: complex: Returns 0.0 as a complex number (0.0j). Type: coulomb, Participants: ('pz', 'pz'): NN Couplings: 16.522, 8.64, 5.333 Other neighbors: Coupling with a (regularized) Coulomb-like potential There are parameters regarding the geometry, the type of the involved orbitals (the built-in graphene model contains only a single pz orbital per atom), the position of orbitals in the unit cell and the interactions (currently, GRANAD supports hoppings and Coulomb interactions). Let's pick a concrete material. graphene = MaterialCatalog . get ( \"graphene\" ) OrbitalLists OrbitalLists are the last class you need to know. Unsurprisingly, an OrbitalList is a list of orbitals. You can create one yourself from the two orbitals you created above from granad import OrbitalList my_first_orbital_list = OrbitalList ([ my_first_orbital , my_second_orbital ]) print ( my_first_orbital_list ) List with 2 orbitals, 2 electrons.Excitation: f[Array([0], dtype=int64), Array([0], dtype=int64), Array([0], dtype=int64)] [Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=None, tag='a tag contains arbitrary information', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=1)), Orbital(position=Array([1., 1., 1.], dtype=float64), layer_index=None, tag='a new, shifted orbital', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=2))] Alternatively, you get orbital lists if you cut a flake from a material. You do this by specifying the shape of the flake. You can specify any shape you want, but this is covered in a separate tutorial. For now, we will use a built-in shape: an hexagon with a base length of 10 Angstr\u00f6m. from granad import Triangle import jax.numpy as jnp triangle = Triangle ( 18 ) Now, our shape is ready and we can start cutting. To make sure that we are satisfied with what we get, we plot the flake. By default, GRANAD cuts any \"dangling\" atoms. my_first_flake = graphene . cut_flake ( triangle , plot = True ) print ( my_first_flake ) List with 46 orbitals, 46 electrons.Excitation: f[Array([0], dtype=int64), Array([0], dtype=int64), Array([0], dtype=int64)] [Orbital(position=Array([-4.92 , -4.26084499, 0. ], dtype=float64), layer_index=0, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-6.15 , -2.13042249, 0. ], dtype=float64), layer_index=1, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-2.46 , -4.26084499, 0. ], dtype=float64), layer_index=2, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-3.69 , -2.13042249, 0. ], dtype=float64), layer_index=3, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-4.92, 0. , 0. ], dtype=float64), layer_index=4, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 0. , -4.26084499, 0. ], dtype=float64), layer_index=5, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , -2.13042249, 0. ], dtype=float64), layer_index=6, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-2.46, 0. , 0. ], dtype=float64), layer_index=7, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-3.69 , 2.13042249, 0. ], dtype=float64), layer_index=8, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 2.46 , -4.26084499, 0. ], dtype=float64), layer_index=9, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 1.23 , -2.13042249, 0. ], dtype=float64), layer_index=10, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=11, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , 2.13042249, 0. ], dtype=float64), layer_index=12, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-2.46 , 4.26084499, 0. ], dtype=float64), layer_index=13, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 4.92 , -4.26084499, 0. ], dtype=float64), layer_index=14, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 3.69 , -2.13042249, 0. ], dtype=float64), layer_index=15, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([2.46, 0. , 0. ], dtype=float64), layer_index=16, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([1.23 , 2.13042249, 0. ], dtype=float64), layer_index=17, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([0. , 4.26084499, 0. ], dtype=float64), layer_index=18, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , 6.39126748, 0. ], dtype=float64), layer_index=19, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 6.15 , -2.13042249, 0. ], dtype=float64), layer_index=20, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([4.92, 0. , 0. ], dtype=float64), layer_index=21, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([3.69 , 2.13042249, 0. ], dtype=float64), layer_index=22, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([2.46 , 4.26084499, 0. ], dtype=float64), layer_index=23, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([1.23 , 6.39126748, 0. ], dtype=float64), layer_index=24, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-6.15 , -3.55070416, 0. ], dtype=float64), layer_index=25, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-3.69 , -3.55070416, 0. ], dtype=float64), layer_index=26, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-4.92 , -1.42028166, 0. ], dtype=float64), layer_index=27, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , -3.55070416, 0. ], dtype=float64), layer_index=28, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-2.46 , -1.42028166, 0. ], dtype=float64), layer_index=29, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-3.69 , 0.71014083, 0. ], dtype=float64), layer_index=30, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 1.23 , -3.55070416, 0. ], dtype=float64), layer_index=31, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 0. , -1.42028166, 0. ], dtype=float64), layer_index=32, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , 0.71014083, 0. ], dtype=float64), layer_index=33, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-2.46 , 2.84056332, 0. ], dtype=float64), layer_index=34, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 3.69 , -3.55070416, 0. ], dtype=float64), layer_index=35, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 2.46 , -1.42028166, 0. ], dtype=float64), layer_index=36, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([1.23 , 0.71014083, 0. ], dtype=float64), layer_index=37, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([0. , 2.84056332, 0. ], dtype=float64), layer_index=38, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , 4.97098582, 0. ], dtype=float64), layer_index=39, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 6.15 , -3.55070416, 0. ], dtype=float64), layer_index=40, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 4.92 , -1.42028166, 0. ], dtype=float64), layer_index=41, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([3.69 , 0.71014083, 0. ], dtype=float64), layer_index=42, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([2.46 , 2.84056332, 0. ], dtype=float64), layer_index=43, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([1.23 , 4.97098582, 0. ], dtype=float64), layer_index=44, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([0. , 7.10140831, 0. ], dtype=float64), layer_index=45, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3))] There is an extra option for dealing with graphene-like lattices we can pass to the built-in shape, which is the armchair boolean. It just rotates the shape to get the correct edge type. The optional \"shift\" argument lets you shift the shape in the plane. triangle_ac = Triangle ( 18 , armchair = True ) my_first_flake = graphene . cut_flake ( triangle_ac , plot = True ) For more information on cutting, including different edge types and how to keep dangling atoms, have a look at the corresponding tutorial. A first simulation Physical observables are expectation values of Hermitian operators. GRANAD offers access to the time-resolved density matrix \\(\\rho(t)\\) of a system by integrating a nonlinear master equation. Once the time dependent density matrix is known, dynamical expectation values can be computed. Say you have a Hermitian operator epresented by a matrix \\(A\\) and the solution of the master equation \\(\\rho(t)\\) . The expectation value is then just \\(a(t) = \\text{Tr}[\\rho(t) A]\\) . We will illustrate this at the example of the dipole moment in the small graphene flake we created above. But before we dive into exploring the dynamics of the flake, we first inspect its energies my_first_flake . show_energies () GRANAD offers similar built-in functions to visualize (both static and dynamic) properties of a flake. For more information, please consult the corresponding tutorial. Now that we are ready, we can study the induced dipole moment. In particular, we will: Excite the flake with an electric field. Compute its dipole moment \\(p(t) = \\text{Tr}[\\rho(t) P]\\) The electric field is given as a function mapping the time (a single float) to a vector representing the field components like this field : t -> vec . You can specify custom functions, but GRANAD comes with a few built-ins. We will just use the built-in Pulse. from granad import Pulse my_first_illumination = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) print ( my_first_illumination ( 0.0 ) ) # initial value of the field [2.60905079e-13-1.44036042e-13j 0.00000000e+00+0.00000000e+00j 0.00000000e+00+0.00000000e+00j] Now we come to the actual simulation. For any time-domain simulation, we have to decide on a few additional parameters: Simulation duration: we go from 0 to 40 to make sure everything has equilibrated. Relaxation rate: here, we pick a single number characterizing the rate of energy dissipation across all channels. The operators whose expectation values we want to compute. They are given as a simple list. We want to calculate the induced polarization from the dipole operator. This operator can be represented as a 3xNxN matrix, where N is the number of orbitals and 3 corresponds to Cartesian components x,y,z and we can compute it directly print ( my_first_flake . dipole_operator . shape ) (3, 55, 55) We want to compute its expectation value, so we have to wrap it in a list and pass it to the TD simulation, called master_equation result = my_first_flake . master_equation ( end_time = 40 , # the start is set to 0 by default relaxation_rate = 1 / 10 , illumination = my_first_illumination , expectation_values = [ my_first_flake . dipole_operator ] # you can also omit the list for a single operator, but this is bad practice ) RHS compiled 100.0 % If you want to compute expecation values of more operators, you can simply add them to the list. The result variable is a container for the last density matrix in the simulation (this is important if you want to continue the time evolution). the time axis, which is an array of samples [t_1, t_2, ... t_n]. an \"output\", which is a list of arrays, corresponding to the operators we passed in. Each array contains the time-dependent expectation value like [p_1, p_2, ..., p_n]. We have only specified one operator to compute the expectation value of, such the list only contains one element. print ( len ( result . output )) 1 This list contains an array of shape Tx3. So, if we want the dipole moment at the 10-th timestep in x-direction, we would do dipole_moments = result . output [ 0 ] print ( dipole_moments [ 10 , 0 ]) (3.830435968410484e-13+0j) Now that we understand how a time domain simulation works, we can visualize the result. GRANAD offers a dedicated function for this my_first_flake . show_res ( result , plot_labels = [ \"p_x\" , \"p_y\" , \"p_z\" ], show_illumination = False )","title":"Getting started"},{"location":"tutorials/a_getting_started/#getting-started","text":"We introduce the basics of GRANAD and do a quick simulation.","title":"Getting started"},{"location":"tutorials/a_getting_started/#introduction","text":"GRANAD lets you simulate structures from a few orbitals up to finite bulks. The process of specifying a structure is designed to be easy and interactive: You can add, shift, combine and manipulate parts of your structure at varying levels of detail involving large groups of orbitals or just single orbitals. To this end, GRANAD offers three fundamental datatypes: Orbitals are the fundamental building block of a structure. OrbitalLists represent a concrete structure. In essence, you can handle these as normal Python lists with additional information regarding Orbital coupling. Materials are a stand-in for infinite bulks. You can cut finite pieces from these bulks, which are again just lists of orbitals. We will use each of them below to set up a small graphene nanoantenna coupling to an external field. Once this is done, we will use GRANAD's main feature and simulate the induced dynamics in the nanoantenna directly in time domain.","title":"Introduction"},{"location":"tutorials/a_getting_started/#orbitals","text":"At its core, GRANAD is all about orbitals. Here we create an orbital and print its properties to understand its structure. from granad import Orbital my_first_orbital = Orbital ( tag = \"a tag contains arbitrary information\" , ) print ( my_first_orbital ) {'position': Array([0., 0., 0.], dtype=float64), 'layer_index': None, 'tag': 'a tag contains arbitrary information', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': GroupId(id=1)} The group_id, unsurprisingly, groups orbitals. It shouldn't concern us too much now. From the output above, we see that orbitals are placed at the origin by default. We can change this by passing an explicit position. my_second_orbital = Orbital ( position = ( 1 , 1 , 1 ), tag = \"a new, shifted orbital\" , ) print ( my_second_orbital ) {'position': Array([1., 1., 1.], dtype=float64), 'layer_index': None, 'tag': 'a new, shifted orbital', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': GroupId(id=2)} This is all there is to know about orbitals!","title":"Orbitals"},{"location":"tutorials/a_getting_started/#materials","text":"Materials are stuff you can cut orbitals from. You can define one yourself or import a prebuilt one. We will use the latter option. from granad import MaterialCatalog MaterialCatalog . available () Available materials: graphene ssh metal_1d MoS2 hBN Let's inspect a material. MaterialCatalog . describe ( \"graphene\" ) Material: graphene Lattice Constant: 2.46 \u00c5 Lattice Basis: [[ 1. 0. 0. ] [-0.5 0.8660254 0. ]] Orbital Species: pz characterized by (n,l,m,s, atom name) = (0, 1, 0, 0, 'C') Orbitals: Position: (0, 0), Tag: sublattice_1, Species: pz Position: (-0.3333333333333333, -0.6666666666666666), Tag: sublattice_2, Species: pz Interactions: Type: hamiltonian, Participants: ('pz', 'pz'): NN Couplings: 0.0, 2.66 Other neighbors: Returns a zero coupling constant as a complex number. Args: d (float): A parameter (typically representing distance or some other factor) that is ignored by the function, as the output is always zero. Returns: complex: Returns 0.0 as a complex number (0.0j). Type: coulomb, Participants: ('pz', 'pz'): NN Couplings: 16.522, 8.64, 5.333 Other neighbors: Coupling with a (regularized) Coulomb-like potential There are parameters regarding the geometry, the type of the involved orbitals (the built-in graphene model contains only a single pz orbital per atom), the position of orbitals in the unit cell and the interactions (currently, GRANAD supports hoppings and Coulomb interactions). Let's pick a concrete material. graphene = MaterialCatalog . get ( \"graphene\" )","title":"Materials"},{"location":"tutorials/a_getting_started/#orbitallists","text":"OrbitalLists are the last class you need to know. Unsurprisingly, an OrbitalList is a list of orbitals. You can create one yourself from the two orbitals you created above from granad import OrbitalList my_first_orbital_list = OrbitalList ([ my_first_orbital , my_second_orbital ]) print ( my_first_orbital_list ) List with 2 orbitals, 2 electrons.Excitation: f[Array([0], dtype=int64), Array([0], dtype=int64), Array([0], dtype=int64)] [Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=None, tag='a tag contains arbitrary information', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=1)), Orbital(position=Array([1., 1., 1.], dtype=float64), layer_index=None, tag='a new, shifted orbital', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=2))] Alternatively, you get orbital lists if you cut a flake from a material. You do this by specifying the shape of the flake. You can specify any shape you want, but this is covered in a separate tutorial. For now, we will use a built-in shape: an hexagon with a base length of 10 Angstr\u00f6m. from granad import Triangle import jax.numpy as jnp triangle = Triangle ( 18 ) Now, our shape is ready and we can start cutting. To make sure that we are satisfied with what we get, we plot the flake. By default, GRANAD cuts any \"dangling\" atoms. my_first_flake = graphene . cut_flake ( triangle , plot = True ) print ( my_first_flake ) List with 46 orbitals, 46 electrons.Excitation: f[Array([0], dtype=int64), Array([0], dtype=int64), Array([0], dtype=int64)] [Orbital(position=Array([-4.92 , -4.26084499, 0. ], dtype=float64), layer_index=0, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-6.15 , -2.13042249, 0. ], dtype=float64), layer_index=1, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-2.46 , -4.26084499, 0. ], dtype=float64), layer_index=2, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-3.69 , -2.13042249, 0. ], dtype=float64), layer_index=3, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-4.92, 0. , 0. ], dtype=float64), layer_index=4, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 0. , -4.26084499, 0. ], dtype=float64), layer_index=5, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , -2.13042249, 0. ], dtype=float64), layer_index=6, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-2.46, 0. , 0. ], dtype=float64), layer_index=7, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-3.69 , 2.13042249, 0. ], dtype=float64), layer_index=8, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 2.46 , -4.26084499, 0. ], dtype=float64), layer_index=9, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 1.23 , -2.13042249, 0. ], dtype=float64), layer_index=10, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=11, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , 2.13042249, 0. ], dtype=float64), layer_index=12, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-2.46 , 4.26084499, 0. ], dtype=float64), layer_index=13, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 4.92 , -4.26084499, 0. ], dtype=float64), layer_index=14, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 3.69 , -2.13042249, 0. ], dtype=float64), layer_index=15, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([2.46, 0. , 0. ], dtype=float64), layer_index=16, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([1.23 , 2.13042249, 0. ], dtype=float64), layer_index=17, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([0. , 4.26084499, 0. ], dtype=float64), layer_index=18, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , 6.39126748, 0. ], dtype=float64), layer_index=19, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 6.15 , -2.13042249, 0. ], dtype=float64), layer_index=20, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([4.92, 0. , 0. ], dtype=float64), layer_index=21, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([3.69 , 2.13042249, 0. ], dtype=float64), layer_index=22, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([2.46 , 4.26084499, 0. ], dtype=float64), layer_index=23, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([1.23 , 6.39126748, 0. ], dtype=float64), layer_index=24, tag='sublattice_1', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-6.15 , -3.55070416, 0. ], dtype=float64), layer_index=25, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-3.69 , -3.55070416, 0. ], dtype=float64), layer_index=26, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-4.92 , -1.42028166, 0. ], dtype=float64), layer_index=27, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , -3.55070416, 0. ], dtype=float64), layer_index=28, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-2.46 , -1.42028166, 0. ], dtype=float64), layer_index=29, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-3.69 , 0.71014083, 0. ], dtype=float64), layer_index=30, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 1.23 , -3.55070416, 0. ], dtype=float64), layer_index=31, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 0. , -1.42028166, 0. ], dtype=float64), layer_index=32, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , 0.71014083, 0. ], dtype=float64), layer_index=33, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-2.46 , 2.84056332, 0. ], dtype=float64), layer_index=34, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 3.69 , -3.55070416, 0. ], dtype=float64), layer_index=35, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 2.46 , -1.42028166, 0. ], dtype=float64), layer_index=36, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([1.23 , 0.71014083, 0. ], dtype=float64), layer_index=37, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([0. , 2.84056332, 0. ], dtype=float64), layer_index=38, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([-1.23 , 4.97098582, 0. ], dtype=float64), layer_index=39, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 6.15 , -3.55070416, 0. ], dtype=float64), layer_index=40, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([ 4.92 , -1.42028166, 0. ], dtype=float64), layer_index=41, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([3.69 , 0.71014083, 0. ], dtype=float64), layer_index=42, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([2.46 , 2.84056332, 0. ], dtype=float64), layer_index=43, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([1.23 , 4.97098582, 0. ], dtype=float64), layer_index=44, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3)), Orbital(position=Array([0. , 7.10140831, 0. ], dtype=float64), layer_index=45, tag='sublattice_2', energy_level=0, angular_momentum=1, angular_momentum_z=0, spin=0, atom_name='C', group_id=GroupId(id=3))] There is an extra option for dealing with graphene-like lattices we can pass to the built-in shape, which is the armchair boolean. It just rotates the shape to get the correct edge type. The optional \"shift\" argument lets you shift the shape in the plane. triangle_ac = Triangle ( 18 , armchair = True ) my_first_flake = graphene . cut_flake ( triangle_ac , plot = True ) For more information on cutting, including different edge types and how to keep dangling atoms, have a look at the corresponding tutorial.","title":"OrbitalLists"},{"location":"tutorials/a_getting_started/#a-first-simulation","text":"Physical observables are expectation values of Hermitian operators. GRANAD offers access to the time-resolved density matrix \\(\\rho(t)\\) of a system by integrating a nonlinear master equation. Once the time dependent density matrix is known, dynamical expectation values can be computed. Say you have a Hermitian operator epresented by a matrix \\(A\\) and the solution of the master equation \\(\\rho(t)\\) . The expectation value is then just \\(a(t) = \\text{Tr}[\\rho(t) A]\\) . We will illustrate this at the example of the dipole moment in the small graphene flake we created above. But before we dive into exploring the dynamics of the flake, we first inspect its energies my_first_flake . show_energies () GRANAD offers similar built-in functions to visualize (both static and dynamic) properties of a flake. For more information, please consult the corresponding tutorial. Now that we are ready, we can study the induced dipole moment. In particular, we will: Excite the flake with an electric field. Compute its dipole moment \\(p(t) = \\text{Tr}[\\rho(t) P]\\) The electric field is given as a function mapping the time (a single float) to a vector representing the field components like this field : t -> vec . You can specify custom functions, but GRANAD comes with a few built-ins. We will just use the built-in Pulse. from granad import Pulse my_first_illumination = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) print ( my_first_illumination ( 0.0 ) ) # initial value of the field [2.60905079e-13-1.44036042e-13j 0.00000000e+00+0.00000000e+00j 0.00000000e+00+0.00000000e+00j] Now we come to the actual simulation. For any time-domain simulation, we have to decide on a few additional parameters: Simulation duration: we go from 0 to 40 to make sure everything has equilibrated. Relaxation rate: here, we pick a single number characterizing the rate of energy dissipation across all channels. The operators whose expectation values we want to compute. They are given as a simple list. We want to calculate the induced polarization from the dipole operator. This operator can be represented as a 3xNxN matrix, where N is the number of orbitals and 3 corresponds to Cartesian components x,y,z and we can compute it directly print ( my_first_flake . dipole_operator . shape ) (3, 55, 55) We want to compute its expectation value, so we have to wrap it in a list and pass it to the TD simulation, called master_equation result = my_first_flake . master_equation ( end_time = 40 , # the start is set to 0 by default relaxation_rate = 1 / 10 , illumination = my_first_illumination , expectation_values = [ my_first_flake . dipole_operator ] # you can also omit the list for a single operator, but this is bad practice ) RHS compiled 100.0 % If you want to compute expecation values of more operators, you can simply add them to the list. The result variable is a container for the last density matrix in the simulation (this is important if you want to continue the time evolution). the time axis, which is an array of samples [t_1, t_2, ... t_n]. an \"output\", which is a list of arrays, corresponding to the operators we passed in. Each array contains the time-dependent expectation value like [p_1, p_2, ..., p_n]. We have only specified one operator to compute the expectation value of, such the list only contains one element. print ( len ( result . output )) 1 This list contains an array of shape Tx3. So, if we want the dipole moment at the 10-th timestep in x-direction, we would do dipole_moments = result . output [ 0 ] print ( dipole_moments [ 10 , 0 ]) (3.830435968410484e-13+0j) Now that we understand how a time domain simulation works, we can visualize the result. GRANAD offers a dedicated function for this my_first_flake . show_res ( result , plot_labels = [ \"p_x\" , \"p_y\" , \"p_z\" ], show_illumination = False )","title":"A first simulation"},{"location":"tutorials/b_list_based_simulations/","text":"List-based Simulations Every GRANAD simulation dependens on orbitals and their interactions. Orbitals themselves are quite boring. To make them interact and shift them around, you need to put them into list, which is what this tutorial is about. Orbitals: A Recap As already explained in the \"Getting Started\" Tutorial, Orbitals are the basic building blocks of orbital lists. They are book keeping devices containing quantum numbers, position and a user-defined string. There is not much more to them. Orbital lists We can make orbitals interact by putting them into a list. The class we need for this is called OrbitalList It allows us allow to couple orbitals set simulation parameters compute and plot physical observables (such as energy spectra or TD simulations) Coupling orbitals We already learned in the first tutorial that there are only two ways of making an orbital list: creating it ourselves cutting it from a bulk material In the former case, we have to specify all couplings ourselves. In the latter case, the material has already told the orbitals how to interact. Say we want to specify an isolated atom representing a quantum optical TLS. We need two energy levels: an upper and a lower energy. So its a good idea to use an Orbital for each of them. The orbitals belong to the same atom. To remind us of this, we specify a tag. from granad import Orbital lower_level = Orbital ( tag = \"atom\" ) upper_level = Orbital ( tag = \"atom\" ) We want to use the Orbitals in a simulation. This means that we have to put them into a list from granad import OrbitalList atom = OrbitalList ([ lower_level , upper_level ]) print ( atom ) List with 2 orbitals, 2 electrons.Excitation: f[Array([0], dtype=int64), Array([0], dtype=int64), Array([0], dtype=int64)] [Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=None, tag='atom', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=1)), Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=None, tag='atom', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=2))] We can tell that the total electron number in our system is 2. This is GRANAD's default behavior: each orbital is considered to contribute 1 electron. This can be changed of course atom . set_electrons ( 1 ) print ( atom ) List with 2 orbitals, 1 electrons.Excitation: f[Array([0], dtype=int64), Array([0], dtype=int64), Array([0], dtype=int64)] [Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=None, tag='atom', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=1)), Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=None, tag='atom', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=2))] We can now already compute static quantities of the atom, like its energies. print ( atom . energies ) [0. 0.] This is not very interesting, because we have specified no couplings. By default, GRANAD considers all couplings to be zero unless stated otherwise. So let's change this. GRANAD lets us explicitly set elements of the hamiltonian (and coulomb) matrices by their list indices. We have put the Orbital called lower_level in the 0-th position, so we can assign it an an energy of -0.5. atom . set_hamiltonian_element ( 0 , 0 , - 0.5 ) Similarly, we can assign the energy to the upper level atom . set_hamiltonian_element ( 1 , 1 , 0.5 ) If we now check the energies, we see that they have updated automatically print ( atom . energies ) [-0.5 0.5] So that worked. You might have realized that you didn't have to call any function to get the energies with the updated couplings. This is because GRANAD evaluates lazily: physical quantities that depend on the couplings (like the energies or a coulomb matrix entry) will be computed when they are needed. Aside from using list indices for setting couplings, you can also use the orbitals themselves. This takes some time to get used to, but is quite practical. Let's say for illustration we couple the upper and lower level. You could do it like this atom . set_hamiltonian_element ( 1 , 0 , 0.5 j ) Or like this atom . set_hamiltonian_element ( upper_level , lower_level , 0.1 j ) # changes the same element print ( atom . hamiltonian ) [[-0.5-0.j 0. +0.1j] [ 0. -0.1j 0.5-0.j ]] We see that the matrix entry corresponding to the inter-level coupling is now modified accordingly, with hermiticity of the hamiltonian taken into account properly. Introducing dipole transitions works similarly: We just have to remember to pass in a vector for the transition atom . set_dipole_element ( upper_level , lower_level , [ 0 , 0 , 1 ] ) # transition in z-direction print ( atom . dipole_operator [ 2 ]) [[0.+0.j 1.+0.j] [1.+0.j 0.+0.j]] Let's look at the position of the atom print ( atom . positions ) [[0. 0. 0.] [0. 0. 0.]] It is located at the origin. Let's shift it. We can manipulate the \"position\" attribute of the two orbitals by hand (not recommended) or we can use the tag we just defined, like so atom . shift_by_vector ( [ 0 , 0 , 1 ] ) print ( atom . positions ) [[0. 0. 1.] [0. 0. 1.]] Every orbital we have annotated by this tag will be shifted. Obviously, shifting a single point is not so interesting, so let's do something more complicated. Consider a slightly more involved geometric example, i.e. stacking two graphene flakes. We chose simple rectangles from granad import MaterialCatalog , Rectangle flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ), plot = True ) By default, graphene flakes are created in the xy - plane. They contain pz Orbitals which are grouped together by an id. You can directly apply shifts to groups of orbitals. We want to shift the entire flake flake . shift_by_vector ( [ 0 , 0 , 1 ] ) print ( flake . positions ) [[-7.38 -4.26084499 1. ] [-8.61 -2.13042249 1. ] [-9.84 0. 1. ] [-4.92 -4.26084499 1. ] [-6.15 -2.13042249 1. ] [-7.38 0. 1. ] [-8.61 2.13042249 1. ] [-2.46 -4.26084499 1. ] [-3.69 -2.13042249 1. ] [-4.92 0. 1. ] [-6.15 2.13042249 1. ] [ 0. -4.26084499 1. ] [-1.23 -2.13042249 1. ] [-2.46 0. 1. ] [-3.69 2.13042249 1. ] [ 2.46 -4.26084499 1. ] [ 1.23 -2.13042249 1. ] [ 0. 0. 1. ] [-1.23 2.13042249 1. ] [ 4.92 -4.26084499 1. ] [ 3.69 -2.13042249 1. ] [ 2.46 0. 1. ] [ 1.23 2.13042249 1. ] [ 7.38 -4.26084499 1. ] [ 6.15 -2.13042249 1. ] [ 4.92 0. 1. ] [ 3.69 2.13042249 1. ] [ 8.61 -2.13042249 1. ] [ 7.38 0. 1. ] [ 6.15 2.13042249 1. ] [ 9.84 0. 1. ] [ 8.61 2.13042249 1. ] [-8.61 -3.55070416 1. ] [-9.84 -1.42028166 1. ] [-6.15 -3.55070416 1. ] [-7.38 -1.42028166 1. ] [-8.61 0.71014083 1. ] [-3.69 -3.55070416 1. ] [-4.92 -1.42028166 1. ] [-6.15 0.71014083 1. ] [-7.38 2.84056332 1. ] [-1.23 -3.55070416 1. ] [-2.46 -1.42028166 1. ] [-3.69 0.71014083 1. ] [-4.92 2.84056332 1. ] [ 1.23 -3.55070416 1. ] [ 0. -1.42028166 1. ] [-1.23 0.71014083 1. ] [-2.46 2.84056332 1. ] [ 3.69 -3.55070416 1. ] [ 2.46 -1.42028166 1. ] [ 1.23 0.71014083 1. ] [ 0. 2.84056332 1. ] [ 6.15 -3.55070416 1. ] [ 4.92 -1.42028166 1. ] [ 3.69 0.71014083 1. ] [ 2.46 2.84056332 1. ] [ 8.61 -3.55070416 1. ] [ 7.38 -1.42028166 1. ] [ 6.15 0.71014083 1. ] [ 4.92 2.84056332 1. ] [ 9.84 -1.42028166 1. ] [ 8.61 0.71014083 1. ] [ 7.38 2.84056332 1. ]] Now we have shifted the entire flake. But we actually wanted a stack, so we need a new flake at the bottom. second_flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) How do we combine the flakes? Well, both are lists, so we can just add them stack = flake + second_flake stack . show_3d () This is the first step. Now, we need to set couplings. For simplicity, we will couple nearest neighbors in different layers by setting their hopping rate in the Hamiltonian to 2.0. Interlayer nearest neighbors are separated by a distance of 1 Angstr\u00f6m. To achieve this, we could loop over all orbitals in the lower flake. get their nearest neighbor in the upper flake. call stack.set_hamiltonian_element to set the coupling to 1.0. This is very cumbersome, so we take a more flexible approach: specifying the coupling by a distance-dependent function. We want a function that is 2.0 for a distance of 1.0 and 0.0 else. One way to express this is a narrow gaussian around 1.0. import jax.numpy as jnp def interlayer_hopping ( distance ): return 2.0 * jnp . exp ( - 100 * ( distance - 1.0 ) ** 2 ) To set the coupling, we do stack . set_hamiltonian_groups ( flake , second_flake , interlayer_hopping ) We can perform a slightly more interesting simulation by looping over a bunch of nearest-neighbor couplings and study the impact on the energy landscape. To this end, we rewrite the coupling function: TODO: explain more def interlayer_hopping_factory ( coupling ): def interlayer_hopping ( distance ): return coupling * jnp . exp ( - 100 * ( distance - 1.0 ) ** 2 ) return interlayer_hopping We now loop and plot import matplotlib.pyplot as plt n_orbs = len ( stack ) for coupling in [ 0 , 1.0 , 1.5 , 2.0 , 3.0 ]: interlayer_hopping = interlayer_hopping_factory ( coupling ) stack . set_hamiltonian_groups ( flake , second_flake , interlayer_hopping ) plt . plot ( stack . energies , 'o' , label = coupling ) plt . title ( \"Energy landscape dependent on interlayer cc-hopping\" ) plt . legend () plt . show () Admittedly, this way of specifying couplings gets some time to get used to, but it is really flexible. To recap: we have learned that there are three different ways to address orbitals in a list, corresponding to varying levels of granularity: Single Orbitals may be accessed by their list index or directly. User-grouped Orbitals may be accessed by their tag. Auto-grouped Orbitals may be accessed by their group_id. Based on this information, you can manipulate orbitals, e.g. shift them around. Pitfalls Deleting and modifying state is dangerous. atom = OrbitalList ( [ Orbital (), Orbital ()] ) atom . set_electrons ( 1 ) del atom [ 0 ] # ALWAYS removes 1 electron print ( atom . electrons ) # you have an empty atom 0 For this reason, the deletion (and append) operation may change or be removed entirely.","title":"List-based Simulations"},{"location":"tutorials/b_list_based_simulations/#list-based-simulations","text":"Every GRANAD simulation dependens on orbitals and their interactions. Orbitals themselves are quite boring. To make them interact and shift them around, you need to put them into list, which is what this tutorial is about.","title":"List-based Simulations"},{"location":"tutorials/b_list_based_simulations/#orbitals-a-recap","text":"As already explained in the \"Getting Started\" Tutorial, Orbitals are the basic building blocks of orbital lists. They are book keeping devices containing quantum numbers, position and a user-defined string. There is not much more to them.","title":"Orbitals: A Recap"},{"location":"tutorials/b_list_based_simulations/#orbital-lists","text":"We can make orbitals interact by putting them into a list. The class we need for this is called OrbitalList It allows us allow to couple orbitals set simulation parameters compute and plot physical observables (such as energy spectra or TD simulations)","title":"Orbital lists"},{"location":"tutorials/b_list_based_simulations/#coupling-orbitals","text":"We already learned in the first tutorial that there are only two ways of making an orbital list: creating it ourselves cutting it from a bulk material In the former case, we have to specify all couplings ourselves. In the latter case, the material has already told the orbitals how to interact. Say we want to specify an isolated atom representing a quantum optical TLS. We need two energy levels: an upper and a lower energy. So its a good idea to use an Orbital for each of them. The orbitals belong to the same atom. To remind us of this, we specify a tag. from granad import Orbital lower_level = Orbital ( tag = \"atom\" ) upper_level = Orbital ( tag = \"atom\" ) We want to use the Orbitals in a simulation. This means that we have to put them into a list from granad import OrbitalList atom = OrbitalList ([ lower_level , upper_level ]) print ( atom ) List with 2 orbitals, 2 electrons.Excitation: f[Array([0], dtype=int64), Array([0], dtype=int64), Array([0], dtype=int64)] [Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=None, tag='atom', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=1)), Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=None, tag='atom', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=2))] We can tell that the total electron number in our system is 2. This is GRANAD's default behavior: each orbital is considered to contribute 1 electron. This can be changed of course atom . set_electrons ( 1 ) print ( atom ) List with 2 orbitals, 1 electrons.Excitation: f[Array([0], dtype=int64), Array([0], dtype=int64), Array([0], dtype=int64)] [Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=None, tag='atom', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=1)), Orbital(position=Array([0., 0., 0.], dtype=float64), layer_index=None, tag='atom', energy_level=None, angular_momentum=None, angular_momentum_z=None, spin=None, atom_name=None, group_id=GroupId(id=2))] We can now already compute static quantities of the atom, like its energies. print ( atom . energies ) [0. 0.] This is not very interesting, because we have specified no couplings. By default, GRANAD considers all couplings to be zero unless stated otherwise. So let's change this. GRANAD lets us explicitly set elements of the hamiltonian (and coulomb) matrices by their list indices. We have put the Orbital called lower_level in the 0-th position, so we can assign it an an energy of -0.5. atom . set_hamiltonian_element ( 0 , 0 , - 0.5 ) Similarly, we can assign the energy to the upper level atom . set_hamiltonian_element ( 1 , 1 , 0.5 ) If we now check the energies, we see that they have updated automatically print ( atom . energies ) [-0.5 0.5] So that worked. You might have realized that you didn't have to call any function to get the energies with the updated couplings. This is because GRANAD evaluates lazily: physical quantities that depend on the couplings (like the energies or a coulomb matrix entry) will be computed when they are needed. Aside from using list indices for setting couplings, you can also use the orbitals themselves. This takes some time to get used to, but is quite practical. Let's say for illustration we couple the upper and lower level. You could do it like this atom . set_hamiltonian_element ( 1 , 0 , 0.5 j ) Or like this atom . set_hamiltonian_element ( upper_level , lower_level , 0.1 j ) # changes the same element print ( atom . hamiltonian ) [[-0.5-0.j 0. +0.1j] [ 0. -0.1j 0.5-0.j ]] We see that the matrix entry corresponding to the inter-level coupling is now modified accordingly, with hermiticity of the hamiltonian taken into account properly. Introducing dipole transitions works similarly: We just have to remember to pass in a vector for the transition atom . set_dipole_element ( upper_level , lower_level , [ 0 , 0 , 1 ] ) # transition in z-direction print ( atom . dipole_operator [ 2 ]) [[0.+0.j 1.+0.j] [1.+0.j 0.+0.j]] Let's look at the position of the atom print ( atom . positions ) [[0. 0. 0.] [0. 0. 0.]] It is located at the origin. Let's shift it. We can manipulate the \"position\" attribute of the two orbitals by hand (not recommended) or we can use the tag we just defined, like so atom . shift_by_vector ( [ 0 , 0 , 1 ] ) print ( atom . positions ) [[0. 0. 1.] [0. 0. 1.]] Every orbital we have annotated by this tag will be shifted. Obviously, shifting a single point is not so interesting, so let's do something more complicated. Consider a slightly more involved geometric example, i.e. stacking two graphene flakes. We chose simple rectangles from granad import MaterialCatalog , Rectangle flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ), plot = True ) By default, graphene flakes are created in the xy - plane. They contain pz Orbitals which are grouped together by an id. You can directly apply shifts to groups of orbitals. We want to shift the entire flake flake . shift_by_vector ( [ 0 , 0 , 1 ] ) print ( flake . positions ) [[-7.38 -4.26084499 1. ] [-8.61 -2.13042249 1. ] [-9.84 0. 1. ] [-4.92 -4.26084499 1. ] [-6.15 -2.13042249 1. ] [-7.38 0. 1. ] [-8.61 2.13042249 1. ] [-2.46 -4.26084499 1. ] [-3.69 -2.13042249 1. ] [-4.92 0. 1. ] [-6.15 2.13042249 1. ] [ 0. -4.26084499 1. ] [-1.23 -2.13042249 1. ] [-2.46 0. 1. ] [-3.69 2.13042249 1. ] [ 2.46 -4.26084499 1. ] [ 1.23 -2.13042249 1. ] [ 0. 0. 1. ] [-1.23 2.13042249 1. ] [ 4.92 -4.26084499 1. ] [ 3.69 -2.13042249 1. ] [ 2.46 0. 1. ] [ 1.23 2.13042249 1. ] [ 7.38 -4.26084499 1. ] [ 6.15 -2.13042249 1. ] [ 4.92 0. 1. ] [ 3.69 2.13042249 1. ] [ 8.61 -2.13042249 1. ] [ 7.38 0. 1. ] [ 6.15 2.13042249 1. ] [ 9.84 0. 1. ] [ 8.61 2.13042249 1. ] [-8.61 -3.55070416 1. ] [-9.84 -1.42028166 1. ] [-6.15 -3.55070416 1. ] [-7.38 -1.42028166 1. ] [-8.61 0.71014083 1. ] [-3.69 -3.55070416 1. ] [-4.92 -1.42028166 1. ] [-6.15 0.71014083 1. ] [-7.38 2.84056332 1. ] [-1.23 -3.55070416 1. ] [-2.46 -1.42028166 1. ] [-3.69 0.71014083 1. ] [-4.92 2.84056332 1. ] [ 1.23 -3.55070416 1. ] [ 0. -1.42028166 1. ] [-1.23 0.71014083 1. ] [-2.46 2.84056332 1. ] [ 3.69 -3.55070416 1. ] [ 2.46 -1.42028166 1. ] [ 1.23 0.71014083 1. ] [ 0. 2.84056332 1. ] [ 6.15 -3.55070416 1. ] [ 4.92 -1.42028166 1. ] [ 3.69 0.71014083 1. ] [ 2.46 2.84056332 1. ] [ 8.61 -3.55070416 1. ] [ 7.38 -1.42028166 1. ] [ 6.15 0.71014083 1. ] [ 4.92 2.84056332 1. ] [ 9.84 -1.42028166 1. ] [ 8.61 0.71014083 1. ] [ 7.38 2.84056332 1. ]] Now we have shifted the entire flake. But we actually wanted a stack, so we need a new flake at the bottom. second_flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) How do we combine the flakes? Well, both are lists, so we can just add them stack = flake + second_flake stack . show_3d () This is the first step. Now, we need to set couplings. For simplicity, we will couple nearest neighbors in different layers by setting their hopping rate in the Hamiltonian to 2.0. Interlayer nearest neighbors are separated by a distance of 1 Angstr\u00f6m. To achieve this, we could loop over all orbitals in the lower flake. get their nearest neighbor in the upper flake. call stack.set_hamiltonian_element to set the coupling to 1.0. This is very cumbersome, so we take a more flexible approach: specifying the coupling by a distance-dependent function. We want a function that is 2.0 for a distance of 1.0 and 0.0 else. One way to express this is a narrow gaussian around 1.0. import jax.numpy as jnp def interlayer_hopping ( distance ): return 2.0 * jnp . exp ( - 100 * ( distance - 1.0 ) ** 2 ) To set the coupling, we do stack . set_hamiltonian_groups ( flake , second_flake , interlayer_hopping ) We can perform a slightly more interesting simulation by looping over a bunch of nearest-neighbor couplings and study the impact on the energy landscape. To this end, we rewrite the coupling function: TODO: explain more def interlayer_hopping_factory ( coupling ): def interlayer_hopping ( distance ): return coupling * jnp . exp ( - 100 * ( distance - 1.0 ) ** 2 ) return interlayer_hopping We now loop and plot import matplotlib.pyplot as plt n_orbs = len ( stack ) for coupling in [ 0 , 1.0 , 1.5 , 2.0 , 3.0 ]: interlayer_hopping = interlayer_hopping_factory ( coupling ) stack . set_hamiltonian_groups ( flake , second_flake , interlayer_hopping ) plt . plot ( stack . energies , 'o' , label = coupling ) plt . title ( \"Energy landscape dependent on interlayer cc-hopping\" ) plt . legend () plt . show () Admittedly, this way of specifying couplings gets some time to get used to, but it is really flexible. To recap: we have learned that there are three different ways to address orbitals in a list, corresponding to varying levels of granularity: Single Orbitals may be accessed by their list index or directly. User-grouped Orbitals may be accessed by their tag. Auto-grouped Orbitals may be accessed by their group_id. Based on this information, you can manipulate orbitals, e.g. shift them around.","title":"Coupling orbitals"},{"location":"tutorials/b_list_based_simulations/#pitfalls","text":"Deleting and modifying state is dangerous. atom = OrbitalList ( [ Orbital (), Orbital ()] ) atom . set_electrons ( 1 ) del atom [ 0 ] # ALWAYS removes 1 electron print ( atom . electrons ) # you have an empty atom 0 For this reason, the deletion (and append) operation may change or be removed entirely.","title":"Pitfalls"},{"location":"tutorials/c_plotting/","text":"Plotting We take a look at built-in plotting functions. A typical simulation requires visualizing: geometry simulation results space-dependent arrays (such as eigenstates, charges, ...) All public plotting functions are associated with a list of orbitals. Geometry Geometries can be visualized in 2D or 3D. from granad import MaterialCatalog , Rectangle flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) flake . show_2d () If we have a stack flake_shifted = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) flake_shifted . shift_by_vector ( [ 0 , 0 , 1 ] ) stack = flake + flake_shifted stack . show_3d () Simulation output There is a dedicated function for showing TD simulation results. Let's illustrate this by tracking the current from granad import Pulse pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) result = flake . master_equation ( illumination = pulse , expectation_values = [ flake . velocity_operator ], end_time = 40 , relaxation_rate = 1 / 10 , grid = 100 , ) plot_labels = [ 'j_x' , 'j_y' , 'j_z' ] flake . show_res ( result , plot_labels = plot_labels ) RHS compiled 100.0 % We can also plot in frequency domain by specifying the omega limits flake . show_res ( result , omega_max = 5 , omega_min = 0 , plot_labels = plot_labels ) Space-dependent arrays The functions show_2d and show_3d are a bit more versatile than initially indicated. If we supply a \"display\" argument, we can plot an arbitrary array on the grid spanned by the orbitals and filter it by orbital tags. Let's demonstrate this by visualizing the lowest energy one particle state of the flake flake . show_2d ( display = flake . eigenvectors [:, 0 ] ) If you want a normalized plot of the absolute values, do flake . show_2d ( display = flake . eigenvectors [:, 0 ], scale = True ) Additionally, if you supply the keyword argument name = \"MY-PLOT-NAME.pdf\" to any plotting function, the plot will not be displayed, but instead saved to disk in the directory you invoked Python.","title":"Plotting"},{"location":"tutorials/c_plotting/#plotting","text":"We take a look at built-in plotting functions. A typical simulation requires visualizing: geometry simulation results space-dependent arrays (such as eigenstates, charges, ...) All public plotting functions are associated with a list of orbitals.","title":"Plotting"},{"location":"tutorials/c_plotting/#geometry","text":"Geometries can be visualized in 2D or 3D. from granad import MaterialCatalog , Rectangle flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) flake . show_2d () If we have a stack flake_shifted = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) flake_shifted . shift_by_vector ( [ 0 , 0 , 1 ] ) stack = flake + flake_shifted stack . show_3d ()","title":"Geometry"},{"location":"tutorials/c_plotting/#simulation-output","text":"There is a dedicated function for showing TD simulation results. Let's illustrate this by tracking the current from granad import Pulse pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) result = flake . master_equation ( illumination = pulse , expectation_values = [ flake . velocity_operator ], end_time = 40 , relaxation_rate = 1 / 10 , grid = 100 , ) plot_labels = [ 'j_x' , 'j_y' , 'j_z' ] flake . show_res ( result , plot_labels = plot_labels ) RHS compiled 100.0 % We can also plot in frequency domain by specifying the omega limits flake . show_res ( result , omega_max = 5 , omega_min = 0 , plot_labels = plot_labels )","title":"Simulation output"},{"location":"tutorials/c_plotting/#space-dependent-arrays","text":"The functions show_2d and show_3d are a bit more versatile than initially indicated. If we supply a \"display\" argument, we can plot an arbitrary array on the grid spanned by the orbitals and filter it by orbital tags. Let's demonstrate this by visualizing the lowest energy one particle state of the flake flake . show_2d ( display = flake . eigenvectors [:, 0 ] ) If you want a normalized plot of the absolute values, do flake . show_2d ( display = flake . eigenvectors [:, 0 ], scale = True ) Additionally, if you supply the keyword argument name = \"MY-PLOT-NAME.pdf\" to any plotting function, the plot will not be displayed, but instead saved to disk in the directory you invoked Python.","title":"Space-dependent arrays"},{"location":"tutorials/d_basis_handling/","text":"Basis Handling We talk about how to switch between site and energy basis. Default basis By default, GRANAD uses the site basis. You can explicitly force a quantity to be given in energy basis by appending \"_e\" to it. import jax.numpy as jnp from granad import MaterialCatalog chain = MaterialCatalog . get ( \"metal_1d\" ) flake = chain . cut_flake ( unit_cells = 10 ) site_occupations = flake . initial_density_matrix . diagonal () # site basis energy_occupations = flake . initial_density_matrix_e . diagonal () # energy basis Additionally, should you be unsure, the site basis is always given by appending \"_x\". print ( jnp . all ( flake . initial_density_matrix_x == flake . initial_density_matrix )) True There is also a built-in function for basis transformation print ( jnp . all ( flake . transform_to_energy_basis ( flake . hamiltonian ) == flake . hamiltonian_e )) True This is usually only useful when transforming arrays of density matrices, because they are just returned from an orbital list and don't belong to its attributes, so you can't simply append _e. Displaying transition dipole moments import matplotlib.pyplot as plt plt . matshow ( flake . dipole_operator_e [ 0 ] . real ) plt . show ()","title":"Basis Handling"},{"location":"tutorials/d_basis_handling/#basis-handling","text":"We talk about how to switch between site and energy basis.","title":"Basis Handling"},{"location":"tutorials/d_basis_handling/#default-basis","text":"By default, GRANAD uses the site basis. You can explicitly force a quantity to be given in energy basis by appending \"_e\" to it. import jax.numpy as jnp from granad import MaterialCatalog chain = MaterialCatalog . get ( \"metal_1d\" ) flake = chain . cut_flake ( unit_cells = 10 ) site_occupations = flake . initial_density_matrix . diagonal () # site basis energy_occupations = flake . initial_density_matrix_e . diagonal () # energy basis Additionally, should you be unsure, the site basis is always given by appending \"_x\". print ( jnp . all ( flake . initial_density_matrix_x == flake . initial_density_matrix )) True There is also a built-in function for basis transformation print ( jnp . all ( flake . transform_to_energy_basis ( flake . hamiltonian ) == flake . hamiltonian_e )) True This is usually only useful when transforming arrays of density matrices, because they are just returned from an orbital list and don't belong to its attributes, so you can't simply append _e. Displaying transition dipole moments import matplotlib.pyplot as plt plt . matshow ( flake . dipole_operator_e [ 0 ] . real ) plt . show ()","title":"Default basis"},{"location":"tutorials/e_electric_fields/","text":"Electric Fields We present how to handle electric fields The built-in electric fields are just callables, dependent on time. import jax import jax.numpy as jnp import matplotlib.pyplot as plt from granad import Wave help ( Wave ) Help on function Wave in module granad.fields: Wave(amplitudes: list[float], frequency: float) Function for computing time-harmonic electric fields. Args: amplitudes: electric field amplitudes in xyz-components frequency: frequency Returns: Function that computes the electric field as a functon of time So, calling \"Wave\" gives back a function we can evaluate at single points in time wave = Wave ( [ 1 , 0 , 0 ], 1 ) print ( wave ( 0 )) [1.+0.j 0.+0.j 0.+0.j] A quick way to visualize them is to plot their real and imaginary part. JAX offers the vmap function that vectorizes the application. time = jnp . linspace ( 0 , 2 * 2 * jnp . pi , 100 ) e_field = jax . vmap ( wave ) ( time ) print ( e_field . shape ) (100, 3) plt . plot ( time , e_field . real ) plt . plot ( time , e_field . imag , '--' ) plt . show ()","title":"Electric Fields"},{"location":"tutorials/e_electric_fields/#electric-fields","text":"We present how to handle electric fields The built-in electric fields are just callables, dependent on time. import jax import jax.numpy as jnp import matplotlib.pyplot as plt from granad import Wave help ( Wave ) Help on function Wave in module granad.fields: Wave(amplitudes: list[float], frequency: float) Function for computing time-harmonic electric fields. Args: amplitudes: electric field amplitudes in xyz-components frequency: frequency Returns: Function that computes the electric field as a functon of time So, calling \"Wave\" gives back a function we can evaluate at single points in time wave = Wave ( [ 1 , 0 , 0 ], 1 ) print ( wave ( 0 )) [1.+0.j 0.+0.j 0.+0.j] A quick way to visualize them is to plot their real and imaginary part. JAX offers the vmap function that vectorizes the application. time = jnp . linspace ( 0 , 2 * 2 * jnp . pi , 100 ) e_field = jax . vmap ( wave ) ( time ) print ( e_field . shape ) (100, 3) plt . plot ( time , e_field . real ) plt . plot ( time , e_field . imag , '--' ) plt . show ()","title":"Electric Fields"},{"location":"tutorials/f_cutting/","text":"Cutting Cutting Any material defines a cutting function, but they differ by dimensionality. To see why, let's inspect from granad import MaterialCatalog ssh = MaterialCatalog . get ( \"ssh\" ) help ( ssh . cut_flake ) Help on method cut_flake in module granad.materials: cut_flake() method of granad.materials.Material instance Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. So, the cut_flake method is automatically determined. Let's look at the 1D case from granad.materials import cut_flake_1d help ( cut_flake_1d ) Help on function cut_flake_1d in module granad.materials: cut_flake_1d(material, unit_cells, plot=False) Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material (Material): The material instance from which to cut the flake. unit_cells (int): The number of unit cells to include in the flake. plot (bool, optional): If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list: A list of orbitals positioned within the specified range of the material's lattice. Note: The function utilizes internal methods of the `Material` class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. So we just need to specify the number of unit cells. flake = ssh . cut_flake ( unit_cells = 40 , plot = False ) You may notice this is the configuration with edge states in the band gap flake . show_energies () If you don't want this, just delete the edges by removing the first and the last orbital in the list del flake [ 0 ] del flake [ - 1 ] flake . show_2d () flake . show_energies () That's pretty much all about cutting in 1D. Let's cover 2D. from granad.materials import cut_flake_2d help ( cut_flake_2d ) Help on function cut_flake_2d in module granad.materials: cut_flake_2d(material, polygon, plot=False, minimum_neighbor_number: int = 2) Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material (Material): The material instance from which to cut the flake. polygon (array-like): An array of coordinates defining the vertices of the polygon within which to cut the flake. plot (bool, optional): If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number (int, optional): The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list: A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Note: The function assumes the underlying lattice to be in the xy-plane. This is more complex. We can give an arbitrary polygon to the cutting function, so let's do this by approximating a potato (this is an internal joke in Carsten's group). import jax.numpy as jnp potato = 10 * jnp . array ( [ ( 3 , 1 ), # Bottom center (widest point) ( 2 , 2 ), # Lower left bulge ( 1 , 3 ), # Mid left indent ( 2 , 4 ), # Upper left bulge ( 3 , 5 ), # Top center ( 4 , 4 ), # Upper right bulge ( 5 , 3 ), # Mid right indent ( 4 , 2 ), # Lower right bulge ( 3 , 1 ) # Connect back to the bottom center ]) Now, we cut a flake graphene = MaterialCatalog . get ( \"graphene\" ) flake = graphene . cut_flake ( potato , plot = True ) Shapes Built-in shapes are a bit more boring: they are just functions returning a set of vertices. All parameters you pass to them are in Angstr\u00f6m. from granad import Rectangle help ( Rectangle ) Help on function Rectangle in module granad.shapes: Rectangle(length_x, length_y) Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x (float): The length of the rectangle along the x-axis, specified in angstroms. length_y (float): The length of the rectangle along the y-axis, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Note: ```python # Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle(2.0, 1.0) ``` Bearded configurations Cutting removes \"dangling\" atoms by default. Dangling atoms are defined by their neighbor number: if they have only one neighbor, they are removed. If you want to deactivate this to keep \"bearded\" configurations, do flake = graphene . cut_flake ( Rectangle ( 10 , 10 ), plot = True , minimum_neighbor_number = 0 ) Layers If you have a naturally layered structure, eg MoS2, and you cut by keeping every atom with < 2 neighbors, you get from granad import MaterialCatalog , Rectangle mos2 = MaterialCatalog . get ( \"MoS2\" ) flake = mos2 . cut_flake ( Rectangle ( 10 , 10 ), plot = True ) So there seem to be dangling atoms. The reason is that in \"3d\", we need to remove < 3 neighbors from granad import MaterialCatalog , Rectangle mos2 = MaterialCatalog . get ( \"MoS2\" ) flake = mos2 . cut_flake ( Rectangle ( 10 , 10 ), plot = True , minimum_neighbor_number = 3 )","title":"Cutting"},{"location":"tutorials/f_cutting/#cutting","text":"","title":"Cutting"},{"location":"tutorials/f_cutting/#cutting_1","text":"Any material defines a cutting function, but they differ by dimensionality. To see why, let's inspect from granad import MaterialCatalog ssh = MaterialCatalog . get ( \"ssh\" ) help ( ssh . cut_flake ) Help on method cut_flake in module granad.materials: cut_flake() method of granad.materials.Material instance Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. So, the cut_flake method is automatically determined. Let's look at the 1D case from granad.materials import cut_flake_1d help ( cut_flake_1d ) Help on function cut_flake_1d in module granad.materials: cut_flake_1d(material, unit_cells, plot=False) Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material (Material): The material instance from which to cut the flake. unit_cells (int): The number of unit cells to include in the flake. plot (bool, optional): If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list: A list of orbitals positioned within the specified range of the material's lattice. Note: The function utilizes internal methods of the `Material` class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. So we just need to specify the number of unit cells. flake = ssh . cut_flake ( unit_cells = 40 , plot = False ) You may notice this is the configuration with edge states in the band gap flake . show_energies () If you don't want this, just delete the edges by removing the first and the last orbital in the list del flake [ 0 ] del flake [ - 1 ] flake . show_2d () flake . show_energies () That's pretty much all about cutting in 1D. Let's cover 2D. from granad.materials import cut_flake_2d help ( cut_flake_2d ) Help on function cut_flake_2d in module granad.materials: cut_flake_2d(material, polygon, plot=False, minimum_neighbor_number: int = 2) Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material (Material): The material instance from which to cut the flake. polygon (array-like): An array of coordinates defining the vertices of the polygon within which to cut the flake. plot (bool, optional): If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number (int, optional): The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list: A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Note: The function assumes the underlying lattice to be in the xy-plane. This is more complex. We can give an arbitrary polygon to the cutting function, so let's do this by approximating a potato (this is an internal joke in Carsten's group). import jax.numpy as jnp potato = 10 * jnp . array ( [ ( 3 , 1 ), # Bottom center (widest point) ( 2 , 2 ), # Lower left bulge ( 1 , 3 ), # Mid left indent ( 2 , 4 ), # Upper left bulge ( 3 , 5 ), # Top center ( 4 , 4 ), # Upper right bulge ( 5 , 3 ), # Mid right indent ( 4 , 2 ), # Lower right bulge ( 3 , 1 ) # Connect back to the bottom center ]) Now, we cut a flake graphene = MaterialCatalog . get ( \"graphene\" ) flake = graphene . cut_flake ( potato , plot = True )","title":"Cutting"},{"location":"tutorials/f_cutting/#shapes","text":"Built-in shapes are a bit more boring: they are just functions returning a set of vertices. All parameters you pass to them are in Angstr\u00f6m. from granad import Rectangle help ( Rectangle ) Help on function Rectangle in module granad.shapes: Rectangle(length_x, length_y) Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x (float): The length of the rectangle along the x-axis, specified in angstroms. length_y (float): The length of the rectangle along the y-axis, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Note: ```python # Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle(2.0, 1.0) ```","title":"Shapes"},{"location":"tutorials/f_cutting/#bearded-configurations","text":"Cutting removes \"dangling\" atoms by default. Dangling atoms are defined by their neighbor number: if they have only one neighbor, they are removed. If you want to deactivate this to keep \"bearded\" configurations, do flake = graphene . cut_flake ( Rectangle ( 10 , 10 ), plot = True , minimum_neighbor_number = 0 )","title":"Bearded configurations"},{"location":"tutorials/f_cutting/#layers","text":"If you have a naturally layered structure, eg MoS2, and you cut by keeping every atom with < 2 neighbors, you get from granad import MaterialCatalog , Rectangle mos2 = MaterialCatalog . get ( \"MoS2\" ) flake = mos2 . cut_flake ( Rectangle ( 10 , 10 ), plot = True ) So there seem to be dangling atoms. The reason is that in \"3d\", we need to remove < 3 neighbors from granad import MaterialCatalog , Rectangle mos2 = MaterialCatalog . get ( \"MoS2\" ) flake = mos2 . cut_flake ( Rectangle ( 10 , 10 ), plot = True , minimum_neighbor_number = 3 )","title":"Layers"},{"location":"tutorials/g_td_sim/","text":"Time-Domain simulations Observables You can compute multiple observables in one run from granad import MaterialCatalog , Hexagon , Pulse flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Hexagon ( 10 ) ) pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) operators = [ flake . dipole_operator , flake . velocity_operator ] result = flake . master_equation ( relaxation_rate = 1 / 10 , illumination = pulse , expectation_values = operators , end_time = 40 , ) RHS compiled 49.992928864375614 % 100.0 % The result object stores this info. Operators are concatenated in the order you passed them in. print ( len ( result . output )) print ( result . output [ 0 ] . shape ) 1 (7072, 6) The induced dipole moment at timestep 10 is given by print ( result . output [ 0 ][ 10 ,: 3 ]) [5.19272438e-13+0.j 7.16792153e-14+0.j 0.00000000e+00+0.j] Induced current at timestep 10 print ( result . output [ 0 ][ 10 , 3 :]) [ 1.41707761e-11-5.33512817e-15j -4.31137844e-15+8.93268929e-15j 0.00000000e+00+0.00000000e+00j] We can access the Fourier transform as omega_min , omega_max = 0 , 5 omegas , pulse_omega = result . ft_illumination ( omega_min = omega_min , omega_max = omega_max ) output_omega = result . ft_output ( omega_min = omega_min , omega_max = omega_max )[ 0 ] So we can quickly check the continuity equation import matplotlib.pyplot as plt p = - ( omegas * output_omega [:, 0 ]) . imag j = output_omega [:, 3 ] . real plt . plot ( omegas , p , label = r '$- \\text {Im} [\\omega p_x]$' ) plt . plot ( omegas , j , '--' , label = r '$\\text {Re} [j_x]$' ) plt . legend () plt . show () The field is also accessible print ( result . td_illumination . shape ) (7072, 3) WARNING: The following behavior might change and the density_matrix argument may be removed Density matrices If we want to only get density matrices, we can simply omit the operator list. The result object then contains a one-element list. result = flake . master_equation ( relaxation_rate = 1 / 10 , illumination = pulse , end_time = 40 , density_matrix = [ \"full\" ], ) density_matrix = result . output [ 0 ] print ( density_matrix . shape ) RHS compiled 49.992928864375614 % 100.0 % (7072, 94, 94) We can convert them to energy basis density_matrix_e = flake . transform_to_energy_basis ( density_matrix ) print ( density_matrix_e . shape ) (7072, 94, 94) Occupations We can extract only site occupations result = flake . master_equation ( relaxation_rate = 1 / 10 , illumination = pulse , density_matrix = [ \"occ_x\" ], end_time = 40 , ) occ_x = result . output [ 0 ] print ( occ_x . shape ) RHS compiled 49.992928864375614 % 100.0 % (7072, 94) We can extract only energy occupations DANGER : this introduces additional cubic complexity flake . set_excitation ( flake . homo , flake . homo + 1 , 1 ) flake . show_energies () result = flake . master_equation ( relaxation_rate = 1 / 10 , density_matrix = [ \"occ_e\" ], end_time = 40 , ) flake . show_res ( result , plot_only = [ flake . homo , flake . homo + 1 ], plot_labels = [ \"homo\" , \"lumo\" ], show_illumination = False ) RHS compiled 49.992928864375614 % 100.0 % Combinations We can also extract multiple things at the same time result = flake . master_equation ( relaxation_rate = 1 / 10 , density_matrix = [ \"full\" , \"occ_x\" ], expectation_values = [ flake . dipole_operator ], end_time = 40 , illumination = pulse , ) RHS compiled 49.992928864375614 % 100.0 % The output will now contain three arrays: induced dipole moments, site occupations and full density matrices print ( len ( result . output )) print ( result . output [ 0 ] . shape ) # by default, operators come first print ( result . output [ 1 ] . shape ) # we specified [\"full\", \"occ_x\"] => full density matrices print ( result . output [ 2 ] . shape ) # we specified [\"full\", \"occ_x\"] => site occupations 3 (7072, 3) (7072, 94, 94) (7072, 94) Custom computations TBD Automatic Convergence Check TBD Parameters TBD","title":"Time-Domain simulations"},{"location":"tutorials/g_td_sim/#time-domain-simulations","text":"","title":"Time-Domain simulations"},{"location":"tutorials/g_td_sim/#observables","text":"You can compute multiple observables in one run from granad import MaterialCatalog , Hexagon , Pulse flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Hexagon ( 10 ) ) pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) operators = [ flake . dipole_operator , flake . velocity_operator ] result = flake . master_equation ( relaxation_rate = 1 / 10 , illumination = pulse , expectation_values = operators , end_time = 40 , ) RHS compiled 49.992928864375614 % 100.0 % The result object stores this info. Operators are concatenated in the order you passed them in. print ( len ( result . output )) print ( result . output [ 0 ] . shape ) 1 (7072, 6) The induced dipole moment at timestep 10 is given by print ( result . output [ 0 ][ 10 ,: 3 ]) [5.19272438e-13+0.j 7.16792153e-14+0.j 0.00000000e+00+0.j] Induced current at timestep 10 print ( result . output [ 0 ][ 10 , 3 :]) [ 1.41707761e-11-5.33512817e-15j -4.31137844e-15+8.93268929e-15j 0.00000000e+00+0.00000000e+00j] We can access the Fourier transform as omega_min , omega_max = 0 , 5 omegas , pulse_omega = result . ft_illumination ( omega_min = omega_min , omega_max = omega_max ) output_omega = result . ft_output ( omega_min = omega_min , omega_max = omega_max )[ 0 ] So we can quickly check the continuity equation import matplotlib.pyplot as plt p = - ( omegas * output_omega [:, 0 ]) . imag j = output_omega [:, 3 ] . real plt . plot ( omegas , p , label = r '$- \\text {Im} [\\omega p_x]$' ) plt . plot ( omegas , j , '--' , label = r '$\\text {Re} [j_x]$' ) plt . legend () plt . show () The field is also accessible print ( result . td_illumination . shape ) (7072, 3) WARNING: The following behavior might change and the density_matrix argument may be removed","title":"Observables"},{"location":"tutorials/g_td_sim/#density-matrices","text":"If we want to only get density matrices, we can simply omit the operator list. The result object then contains a one-element list. result = flake . master_equation ( relaxation_rate = 1 / 10 , illumination = pulse , end_time = 40 , density_matrix = [ \"full\" ], ) density_matrix = result . output [ 0 ] print ( density_matrix . shape ) RHS compiled 49.992928864375614 % 100.0 % (7072, 94, 94) We can convert them to energy basis density_matrix_e = flake . transform_to_energy_basis ( density_matrix ) print ( density_matrix_e . shape ) (7072, 94, 94)","title":"Density matrices"},{"location":"tutorials/g_td_sim/#occupations","text":"We can extract only site occupations result = flake . master_equation ( relaxation_rate = 1 / 10 , illumination = pulse , density_matrix = [ \"occ_x\" ], end_time = 40 , ) occ_x = result . output [ 0 ] print ( occ_x . shape ) RHS compiled 49.992928864375614 % 100.0 % (7072, 94) We can extract only energy occupations DANGER : this introduces additional cubic complexity flake . set_excitation ( flake . homo , flake . homo + 1 , 1 ) flake . show_energies () result = flake . master_equation ( relaxation_rate = 1 / 10 , density_matrix = [ \"occ_e\" ], end_time = 40 , ) flake . show_res ( result , plot_only = [ flake . homo , flake . homo + 1 ], plot_labels = [ \"homo\" , \"lumo\" ], show_illumination = False ) RHS compiled 49.992928864375614 % 100.0 %","title":"Occupations"},{"location":"tutorials/g_td_sim/#combinations","text":"We can also extract multiple things at the same time result = flake . master_equation ( relaxation_rate = 1 / 10 , density_matrix = [ \"full\" , \"occ_x\" ], expectation_values = [ flake . dipole_operator ], end_time = 40 , illumination = pulse , ) RHS compiled 49.992928864375614 % 100.0 % The output will now contain three arrays: induced dipole moments, site occupations and full density matrices print ( len ( result . output )) print ( result . output [ 0 ] . shape ) # by default, operators come first print ( result . output [ 1 ] . shape ) # we specified [\"full\", \"occ_x\"] => full density matrices print ( result . output [ 2 ] . shape ) # we specified [\"full\", \"occ_x\"] => site occupations 3 (7072, 3) (7072, 94, 94) (7072, 94)","title":"Combinations"},{"location":"tutorials/g_td_sim/#custom-computations","text":"TBD","title":"Custom computations"},{"location":"tutorials/g_td_sim/#automatic-convergence-check","text":"TBD","title":"Automatic Convergence Check"},{"location":"tutorials/g_td_sim/#parameters","text":"TBD","title":"Parameters"},{"location":"tutorials/h_rabi_oscillations/","text":"Rabi Oscillations We study Rabi oscillations as in the paper Revising quantum optical phenomena in adatoms coupled to graphene nanoantennas . NOTE: It is a good idea to get familiar with orbital lists by consulting the tutorial first. Building a two-level system We set up an isolated adatom. from granad import Orbital , OrbitalList lower_level = Orbital () upper_level = Orbital () adatom = OrbitalList ( [ lower_level , upper_level ] ) adatom . set_hamiltonian_element ( lower_level , lower_level , - 0.5 ) adatom . set_hamiltonian_element ( upper_level , upper_level , 0.5 ) adatom . set_dipole_element ( lower_level , upper_level , [ 0 , 7.5 / 2 , 0 ] ) adatom . set_electrons ( 1 ) We study undamped time evolution under harmonic illumination from granad import Wave wave = Wave ( amplitudes = [ 0 , 0.05 , 0 ], frequency = 1 ) result = adatom . master_equation ( end_time = 50 , grid = 10 , illumination = wave , use_rwa = True , coulomb_strength = 0.0 , density_matrix = [ \"occ_e\" ], ) adatom . show_res ( result , plot_only = [ adatom . homo , adatom . homo + 1 ], plot_labels = [ \"homo\" , \"lumo\" ], show_illumination = False ) RHS compiled 100.0 % Coupling to a Flake We combine the TLS with a graphene flake in the top position above an atom. import jax.numpy as jnp from granad import MaterialCatalog , Triangle graphene = MaterialCatalog . get ( \"graphene\" ) flake = graphene . cut_flake ( Triangle ( 10 , armchair = True , shift = [ 10 , 10 ]), plot = False ) flake_with_adatom = flake + adatom pz_orbital = flake_with_adatom [ 8 ] top = pz_orbital . position + jnp . array ([ 0 , 0 , 1 ]) flake_with_adatom . set_position ( top , adatom ) flake_with_adatom . show_3d ( show_index = True ) We set the couplings and inspect the resulting energy levels flake_with_adatom . set_hamiltonian_element ( pz_orbital , adatom , 3.5 ) flake_with_adatom . show_energies () Identify the energy gap homo = flake_with_adatom . homo delta_e = flake_with_adatom . energies [ homo + 1 ] - flake_with_adatom . energies [ homo ] Now, the time evolution of the composite system wave = Wave ( amplitudes = [ 0 , 0.05 , 0 ], frequency = delta_e ) result = flake_with_adatom . master_equation ( grid = 10 , end_time = 50 , illumination = wave , use_rwa = True , coulomb_strength = 0.0 , density_matrix = [ \"occ_e\" ], ) flake_with_adatom . show_res ( result , plot_only = [ homo , homo + 1 ], plot_labels = [ \"homo\" , \"lumo\" ], show_illumination = False ) RHS compiled 100.0 %","title":"Rabi Oscillations"},{"location":"tutorials/h_rabi_oscillations/#rabi-oscillations","text":"We study Rabi oscillations as in the paper Revising quantum optical phenomena in adatoms coupled to graphene nanoantennas . NOTE: It is a good idea to get familiar with orbital lists by consulting the tutorial first.","title":"Rabi Oscillations"},{"location":"tutorials/h_rabi_oscillations/#building-a-two-level-system","text":"We set up an isolated adatom. from granad import Orbital , OrbitalList lower_level = Orbital () upper_level = Orbital () adatom = OrbitalList ( [ lower_level , upper_level ] ) adatom . set_hamiltonian_element ( lower_level , lower_level , - 0.5 ) adatom . set_hamiltonian_element ( upper_level , upper_level , 0.5 ) adatom . set_dipole_element ( lower_level , upper_level , [ 0 , 7.5 / 2 , 0 ] ) adatom . set_electrons ( 1 ) We study undamped time evolution under harmonic illumination from granad import Wave wave = Wave ( amplitudes = [ 0 , 0.05 , 0 ], frequency = 1 ) result = adatom . master_equation ( end_time = 50 , grid = 10 , illumination = wave , use_rwa = True , coulomb_strength = 0.0 , density_matrix = [ \"occ_e\" ], ) adatom . show_res ( result , plot_only = [ adatom . homo , adatom . homo + 1 ], plot_labels = [ \"homo\" , \"lumo\" ], show_illumination = False ) RHS compiled 100.0 %","title":"Building a two-level system"},{"location":"tutorials/h_rabi_oscillations/#coupling-to-a-flake","text":"We combine the TLS with a graphene flake in the top position above an atom. import jax.numpy as jnp from granad import MaterialCatalog , Triangle graphene = MaterialCatalog . get ( \"graphene\" ) flake = graphene . cut_flake ( Triangle ( 10 , armchair = True , shift = [ 10 , 10 ]), plot = False ) flake_with_adatom = flake + adatom pz_orbital = flake_with_adatom [ 8 ] top = pz_orbital . position + jnp . array ([ 0 , 0 , 1 ]) flake_with_adatom . set_position ( top , adatom ) flake_with_adatom . show_3d ( show_index = True ) We set the couplings and inspect the resulting energy levels flake_with_adatom . set_hamiltonian_element ( pz_orbital , adatom , 3.5 ) flake_with_adatom . show_energies () Identify the energy gap homo = flake_with_adatom . homo delta_e = flake_with_adatom . energies [ homo + 1 ] - flake_with_adatom . energies [ homo ] Now, the time evolution of the composite system wave = Wave ( amplitudes = [ 0 , 0.05 , 0 ], frequency = delta_e ) result = flake_with_adatom . master_equation ( grid = 10 , end_time = 50 , illumination = wave , use_rwa = True , coulomb_strength = 0.0 , density_matrix = [ \"occ_e\" ], ) flake_with_adatom . show_res ( result , plot_only = [ homo , homo + 1 ], plot_labels = [ \"homo\" , \"lumo\" ], show_illumination = False ) RHS compiled 100.0 %","title":"Coupling to a Flake"},{"location":"tutorials/i_linear_response/","text":"Linear response We will calculate the optical absorption in the RPA and compare it to TD simulations with a weak external field. RPA First, we set up the RPA simulation. We will consider a small triangle such that the required simulation time stays in the seconds range. import jax.numpy as jnp from granad import MaterialCatalog , Triangle # get material graphene = MaterialCatalog . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ), plot = True ) # frequencies omegas_rpa = jnp . linspace ( 0 , 6 , 40 ) We obtain the polarizability for an external \\(x\\) polarized field and from its imaginary part the absorption. polarizability = flake . get_polarizability_rpa ( omegas_rpa , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 ) absorption_rpa = jnp . abs ( polarizability . imag * 4 * jnp . pi * omegas_rpa ) TD For the TD simulations, we specify a spectrally broad external illumination (i.e. a narrow pulse in time domain) to capture the system's response over a large frequency range. from granad import Pulse pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) We then compute the TD dipole moment and Fourier transform it. result = flake . master_equation ( expectation_values = [ flake . dipole_operator ], end_time = 40 , relaxation_rate = 1 / 10 , illumination = pulse , ) RHS compiled 100.0 % The polarizability is given by \\(p / E\\) (we only take the \\(x\\) - component). omega_max = omegas_rpa . max () omega_min = omegas_rpa . min () p_omega = result . ft_output ( omega_max , omega_min )[ 0 ] omegas_td , pulse_omega = result . ft_illumination ( omega_max , omega_min ) absorption_td = jnp . abs ( - omegas_td * jnp . imag ( p_omega [:, 0 ] / pulse_omega [:, 0 ] ) ) We can now compare the two results. import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas_rpa , absorption_rpa / jnp . max ( absorption_rpa ), 'o' , linewidth = 2 , label = 'RPA' ) plt . plot ( omegas_td , absorption_td / jnp . max ( absorption_td ), linewidth = 2 , ls = '--' , label = 'TD' ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . legend () plt . grid ( True ) plt . show ()","title":"Linear response"},{"location":"tutorials/i_linear_response/#linear-response","text":"We will calculate the optical absorption in the RPA and compare it to TD simulations with a weak external field.","title":"Linear response"},{"location":"tutorials/i_linear_response/#rpa","text":"First, we set up the RPA simulation. We will consider a small triangle such that the required simulation time stays in the seconds range. import jax.numpy as jnp from granad import MaterialCatalog , Triangle # get material graphene = MaterialCatalog . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ), plot = True ) # frequencies omegas_rpa = jnp . linspace ( 0 , 6 , 40 ) We obtain the polarizability for an external \\(x\\) polarized field and from its imaginary part the absorption. polarizability = flake . get_polarizability_rpa ( omegas_rpa , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 ) absorption_rpa = jnp . abs ( polarizability . imag * 4 * jnp . pi * omegas_rpa )","title":"RPA"},{"location":"tutorials/i_linear_response/#td","text":"For the TD simulations, we specify a spectrally broad external illumination (i.e. a narrow pulse in time domain) to capture the system's response over a large frequency range. from granad import Pulse pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) We then compute the TD dipole moment and Fourier transform it. result = flake . master_equation ( expectation_values = [ flake . dipole_operator ], end_time = 40 , relaxation_rate = 1 / 10 , illumination = pulse , ) RHS compiled 100.0 % The polarizability is given by \\(p / E\\) (we only take the \\(x\\) - component). omega_max = omegas_rpa . max () omega_min = omegas_rpa . min () p_omega = result . ft_output ( omega_max , omega_min )[ 0 ] omegas_td , pulse_omega = result . ft_illumination ( omega_max , omega_min ) absorption_td = jnp . abs ( - omegas_td * jnp . imag ( p_omega [:, 0 ] / pulse_omega [:, 0 ] ) ) We can now compare the two results. import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas_rpa , absorption_rpa / jnp . max ( absorption_rpa ), 'o' , linewidth = 2 , label = 'RPA' ) plt . plot ( omegas_td , absorption_td / jnp . max ( absorption_td ), linewidth = 2 , ls = '--' , label = 'TD' ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . legend () plt . grid ( True ) plt . show ()","title":"TD"},{"location":"tutorials/j_defining_materials/","text":"Defining Materials We talk about how to modify built-in materials and define custom ones. Defining a custom material Let's first look at the Material class itself from granad import MaterialCatalog , Material , Hexagon print ( Material . __doc__ ) Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name (str): The name of the material. species (dict): Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals (defaultdict[list]): A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions (defaultdict[dict]): Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hamiltonian', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Note: The `Material` class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hamiltonian and Coulomb interactions among these orbitals. ```python graphene = ( Material(\"graphene\") .lattice_constant(2.46) .lattice_basis([ [1, 0, 0], [-0.5, jnp.sqrt(3)/2, 0] ]) .add_orbital_species(\"pz\", l=1, atom='C') .add_orbital(position=(0, 0), tag=\"sublattice_1\", species=\"pz\") .add_orbital(position=(-1/3, -2/3), tag=\"sublattice_2\", species=\"pz\") .add_interaction( \"hamiltonian\", participants=(\"pz\", \"pz\"), parameters=[0.0, 2.66], ) .add_interaction( \"coulomb\", participants=(\"pz\", \"pz\"), parameters=[16.522, 8.64, 5.333], expression=lambda r : 1/r + 0j ) ) ``` So, the Material class essentially defines a small language we can use to specify a material. The Hubbard model would look like this t = 1. # nearest-neighbor hopping U = 0.1 # onsite coulomb repulsion hubbard = ( Material ( \"Hubbard\" ) . lattice_constant ( 1.0 ) . lattice_basis ([ [ 1 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , 0 , 1 ] ]) . add_orbital_species ( \"up\" , s = - 1 ) . add_orbital_species ( \"down\" , s = 1 ) . add_orbital ( position = ( 0 , 0 , 0 ), species = \"up\" ) . add_orbital ( position = ( 0 , 0 , 0 ), species = \"down\" ) . add_interaction ( \"hamiltonian\" , participants = ( \"up\" , \"up\" ), parameters = [ 0.0 , t ], ) . add_interaction ( \"hamiltonian\" , participants = ( \"down\" , \"down\" ), parameters = [ 0.0 , t ], ) . add_interaction ( \"coulomb\" , participants = ( \"up\" , \"down\" ), parameters = [ U ] ) ) To see how cutting finite flakes from this 3D material works, let's inspect help ( hubbard . cut_flake ) Help on method cut_flake in module granad.materials: cut_flake() method of granad.materials.Material instance Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. So, the cut_flake method is automatically determined. We have specified a 3D material, so let's look at the function that is applied from granad.materials import cut_flake_generic help ( cut_flake_generic ) Help on function cut_flake_generic in module granad.materials: cut_flake_generic(material, grid_range) Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material (Material): The material instance from which to cut the flake. grid_range (list of tuples): Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list: A list of orbitals within the specified grid range, uniquely positioned. Note: The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. Let's see this in action flake = hubbard . cut_flake ( [( 0 , 3 ), ( 0 , 3 ), ( 0 , 3 )] ) # 3*3*3 = 27 unit cells, 3 in every direction, each hosting spin up and spin down atom flake . show_3d () No artists with labels found to put in legend. Note that artists whose label start with an underscore are ignored when legend() is called with no argument. Modifying existing materials You can just copy the material you want to modify and change/override its attributes. As an example, we will turn our ordinary graphene model into a variant of the Haldane model by introducing complex nnn hoppings from copy import deepcopy graphene = MaterialCatalog . get ( \"graphene\" ) graphene_haldane = deepcopy ( graphene ) graphene_haldane . add_interaction ( \"hamiltonian\" , participants = ( 'pz' , 'pz' ), parameters = [ 0 , 1.0 , 1 j * 0.1 ]) print ( graphene_haldane ) Material: graphene Lattice Constant: 2.46 \u00c5 Lattice Basis: [[ 1. 0. 0. ] [-0.5 0.8660254 0. ]] Orbital Species: pz characterized by (n,l,m,s, atom name) = (0, 1, 0, 0, 'C') Orbitals: Position: (0, 0), Tag: sublattice_1, Species: pz Position: (-0.3333333333333333, -0.6666666666666666), Tag: sublattice_2, Species: pz Interactions: Type: hamiltonian, Participants: ('pz', 'pz'): NN Couplings: 0, 1.0, 0.1j Other neighbors: Returns a zero coupling constant as a complex number. Args: d (float): A parameter (typically representing distance or some other factor) that is ignored by the function, as the output is always zero. Returns: complex: Returns 0.0 as a complex number (0.0j). Type: coulomb, Participants: ('pz', 'pz'): NN Couplings: 16.522, 8.64, 5.333 Other neighbors: Coupling with a (regularized) Coulomb-like potential The Haldane model breaks inversion symmetry explicity by a staggered onsite potential. There is no (nice) way to achieve this with a few modifications from the normal graphene model, so we simply use the versatile properties of the orbital list datatype when we cut finite flakes hexagon = Hexagon ( 30 , armchair = False ) flake_topological = graphene_haldane . cut_flake ( hexagon , plot = True ) delta = 0.3 for orb_1 in [ orb for orb in flake_topological if orb . tag == 'sublattice_1' ]: flake_topological . set_hamiltonian_element ( orb_1 , orb_1 , delta ) We now display the edge state import jax.numpy as jnp idx = jnp . argwhere ( jnp . abs ( flake_topological . energies ) < 1e-2 )[ 0 ] . item () flake_topological . show_2d ( display = flake_topological . eigenvectors [:, idx ], scale = True ) Handling non-periodic dimensions Say you want to have a custom ssh chain with 2 atoms in the unit cell, but displace one of the atoms in y-direction. You do this by including a second basis vector in y-direction and give the atom you want to displace a non-vanishing y-coordinate. To not get a 2D lattice, you have to specify explicitly which direction(s) you want to be periodically repeated. _ssh_modified = ( Material ( \"ssh\" ) . lattice_constant ( 2.46 ) . lattice_basis ([ [ 1 , 0 , 0 ], [ 0 , 1 , 0 ], ], periodic = [ 0 ]) # THIS IS THE LINE . add_orbital_species ( \"pz\" , l = 1 , atom = 'C' ) . add_orbital ( position = ( 0 , 0 ), tag = \"sublattice_1\" , species = \"pz\" ) . add_orbital ( position = ( 0.8 , 0.1 ), tag = \"sublattice_2\" , species = \"pz\" ) . add_interaction ( \"hamiltonian\" , participants = ( \"pz\" , \"pz\" ), parameters = [ 0.0 , 1 + 0.2 , 1 - 0.2 ], ) . add_interaction ( \"coulomb\" , participants = ( \"pz\" , \"pz\" ), parameters = [ 16.522 , 8.64 , 5.333 ], expression = lambda d : 14.399 / d + 0 j ) ) flake = _ssh_modified . cut_flake ( unit_cells = 10 ) flake . show_2d () flake . show_energies ()","title":"Defining Materials"},{"location":"tutorials/j_defining_materials/#defining-materials","text":"We talk about how to modify built-in materials and define custom ones.","title":"Defining Materials"},{"location":"tutorials/j_defining_materials/#defining-a-custom-material","text":"Let's first look at the Material class itself from granad import MaterialCatalog , Material , Hexagon print ( Material . __doc__ ) Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name (str): The name of the material. species (dict): Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals (defaultdict[list]): A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions (defaultdict[dict]): Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hamiltonian', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Note: The `Material` class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hamiltonian and Coulomb interactions among these orbitals. ```python graphene = ( Material(\"graphene\") .lattice_constant(2.46) .lattice_basis([ [1, 0, 0], [-0.5, jnp.sqrt(3)/2, 0] ]) .add_orbital_species(\"pz\", l=1, atom='C') .add_orbital(position=(0, 0), tag=\"sublattice_1\", species=\"pz\") .add_orbital(position=(-1/3, -2/3), tag=\"sublattice_2\", species=\"pz\") .add_interaction( \"hamiltonian\", participants=(\"pz\", \"pz\"), parameters=[0.0, 2.66], ) .add_interaction( \"coulomb\", participants=(\"pz\", \"pz\"), parameters=[16.522, 8.64, 5.333], expression=lambda r : 1/r + 0j ) ) ``` So, the Material class essentially defines a small language we can use to specify a material. The Hubbard model would look like this t = 1. # nearest-neighbor hopping U = 0.1 # onsite coulomb repulsion hubbard = ( Material ( \"Hubbard\" ) . lattice_constant ( 1.0 ) . lattice_basis ([ [ 1 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , 0 , 1 ] ]) . add_orbital_species ( \"up\" , s = - 1 ) . add_orbital_species ( \"down\" , s = 1 ) . add_orbital ( position = ( 0 , 0 , 0 ), species = \"up\" ) . add_orbital ( position = ( 0 , 0 , 0 ), species = \"down\" ) . add_interaction ( \"hamiltonian\" , participants = ( \"up\" , \"up\" ), parameters = [ 0.0 , t ], ) . add_interaction ( \"hamiltonian\" , participants = ( \"down\" , \"down\" ), parameters = [ 0.0 , t ], ) . add_interaction ( \"coulomb\" , participants = ( \"up\" , \"down\" ), parameters = [ U ] ) ) To see how cutting finite flakes from this 3D material works, let's inspect help ( hubbard . cut_flake ) Help on method cut_flake in module granad.materials: cut_flake() method of granad.materials.Material instance Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. So, the cut_flake method is automatically determined. We have specified a 3D material, so let's look at the function that is applied from granad.materials import cut_flake_generic help ( cut_flake_generic ) Help on function cut_flake_generic in module granad.materials: cut_flake_generic(material, grid_range) Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material (Material): The material instance from which to cut the flake. grid_range (list of tuples): Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list: A list of orbitals within the specified grid range, uniquely positioned. Note: The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. Let's see this in action flake = hubbard . cut_flake ( [( 0 , 3 ), ( 0 , 3 ), ( 0 , 3 )] ) # 3*3*3 = 27 unit cells, 3 in every direction, each hosting spin up and spin down atom flake . show_3d () No artists with labels found to put in legend. Note that artists whose label start with an underscore are ignored when legend() is called with no argument.","title":"Defining a custom material"},{"location":"tutorials/j_defining_materials/#modifying-existing-materials","text":"You can just copy the material you want to modify and change/override its attributes. As an example, we will turn our ordinary graphene model into a variant of the Haldane model by introducing complex nnn hoppings from copy import deepcopy graphene = MaterialCatalog . get ( \"graphene\" ) graphene_haldane = deepcopy ( graphene ) graphene_haldane . add_interaction ( \"hamiltonian\" , participants = ( 'pz' , 'pz' ), parameters = [ 0 , 1.0 , 1 j * 0.1 ]) print ( graphene_haldane ) Material: graphene Lattice Constant: 2.46 \u00c5 Lattice Basis: [[ 1. 0. 0. ] [-0.5 0.8660254 0. ]] Orbital Species: pz characterized by (n,l,m,s, atom name) = (0, 1, 0, 0, 'C') Orbitals: Position: (0, 0), Tag: sublattice_1, Species: pz Position: (-0.3333333333333333, -0.6666666666666666), Tag: sublattice_2, Species: pz Interactions: Type: hamiltonian, Participants: ('pz', 'pz'): NN Couplings: 0, 1.0, 0.1j Other neighbors: Returns a zero coupling constant as a complex number. Args: d (float): A parameter (typically representing distance or some other factor) that is ignored by the function, as the output is always zero. Returns: complex: Returns 0.0 as a complex number (0.0j). Type: coulomb, Participants: ('pz', 'pz'): NN Couplings: 16.522, 8.64, 5.333 Other neighbors: Coupling with a (regularized) Coulomb-like potential The Haldane model breaks inversion symmetry explicity by a staggered onsite potential. There is no (nice) way to achieve this with a few modifications from the normal graphene model, so we simply use the versatile properties of the orbital list datatype when we cut finite flakes hexagon = Hexagon ( 30 , armchair = False ) flake_topological = graphene_haldane . cut_flake ( hexagon , plot = True ) delta = 0.3 for orb_1 in [ orb for orb in flake_topological if orb . tag == 'sublattice_1' ]: flake_topological . set_hamiltonian_element ( orb_1 , orb_1 , delta ) We now display the edge state import jax.numpy as jnp idx = jnp . argwhere ( jnp . abs ( flake_topological . energies ) < 1e-2 )[ 0 ] . item () flake_topological . show_2d ( display = flake_topological . eigenvectors [:, idx ], scale = True )","title":"Modifying existing materials"},{"location":"tutorials/j_defining_materials/#handling-non-periodic-dimensions","text":"Say you want to have a custom ssh chain with 2 atoms in the unit cell, but displace one of the atoms in y-direction. You do this by including a second basis vector in y-direction and give the atom you want to displace a non-vanishing y-coordinate. To not get a 2D lattice, you have to specify explicitly which direction(s) you want to be periodically repeated. _ssh_modified = ( Material ( \"ssh\" ) . lattice_constant ( 2.46 ) . lattice_basis ([ [ 1 , 0 , 0 ], [ 0 , 1 , 0 ], ], periodic = [ 0 ]) # THIS IS THE LINE . add_orbital_species ( \"pz\" , l = 1 , atom = 'C' ) . add_orbital ( position = ( 0 , 0 ), tag = \"sublattice_1\" , species = \"pz\" ) . add_orbital ( position = ( 0.8 , 0.1 ), tag = \"sublattice_2\" , species = \"pz\" ) . add_interaction ( \"hamiltonian\" , participants = ( \"pz\" , \"pz\" ), parameters = [ 0.0 , 1 + 0.2 , 1 - 0.2 ], ) . add_interaction ( \"coulomb\" , participants = ( \"pz\" , \"pz\" ), parameters = [ 16.522 , 8.64 , 5.333 ], expression = lambda d : 14.399 / d + 0 j ) ) flake = _ssh_modified . cut_flake ( unit_cells = 10 ) flake . show_2d () flake . show_energies ()","title":"Handling non-periodic dimensions"},{"location":"tutorials/k_potentials/","text":"Potentials GRANAD lets you specify coupling to external light using (an arbitrary combination of) electromagnetic potentials. You do this by modifying GRANAD's internal representation of the Hamiltonian, which is just a dictionary. Background Consider GRANAD's master equation \\[\\dot{\\rho}(t) = -i [H[t,\\rho(t)], \\rho] + \\mathcal{D}[t, \\rho]\\] By default, GRANAD simulates the following dipole-gauge expression for the Hamiltonian including an external electric field \\(\\vec{E}\\) \\[H[t,\\rho(t)] = h^{0} + \\vec{E} \\vec{P} + C(\\rho(t) - \\rho^{0})\\] where \\(h^{0}\\) is the unperturbed or bare Hamiltonian constructed from localized orbitals. \\(\\vec{P}\\) is the polarization operator depending on space \\(\\vec{r}\\) and transition dipole moments \\(\\vec{d}\\) , leading to an interatomic potential \\(\\vec{E}\\vec{r}\\) and an intra-atomic potential \\(\\vec{E} \\vec{d}\\) . \\(\\rho^{0}\\) is the stationary density matrix of the system's ground state, and \\(C\\) is the Coulomb matrix (a subset of ERIs). You can modify GRANAD's internal representation of the Hamiltonian to include your own potential terms. Here, you have two options: Define potentials completely on your own. Use built-in potentials. The first solution is more flexible, but a bit more complicated, so we will focus on the built-in potentials in this tutorial. Built-in Potentials First, we set up our small triangle. from granad import MaterialCatalog , Triangle flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Triangle ( 15 ), plot = True ) If we call flake.master_equation , the flake will turn the arguments we passed in (e.g., the illumination) into a representation of the Hamiltonian. By default, this representation corresponds to the dipole-gauge model discussed above. This representation will be passed to \"lower-level\" simulation functions. These functions will turn it into arrays and integrate it. We can directly look at this representation. hamiltonian_model = flake . get_hamiltonian () print ( hamiltonian_model ) {'bare_hamiltonian': <function BareHamiltonian.<locals>.<lambda> at 0x7f2d8cd1ea20>, 'coulomb': <function Coulomb.<locals>.<lambda> at 0x7f2d8cd1ec00>} We see that it is just a dictionary. The keys are strings, the values are functions. Each function is a term in the Hamiltonian. You can tell which one by looking at the keys again print ( hamiltonian_model . keys ()) dict_keys(['bare_hamiltonian', 'coulomb']) So, as we said, we have a bare hamiltonian, and an induced coulomb interaction. But where is the dipole gauge coupling? Remember that we did not pass in any external illumination, so GRANAD assumes there is none. Let's change this quickly from granad import Wave wave = Wave ( amplitudes = [ 1.0 , 0. , 0. ], frequency = 1.0 ) hamiltonian_model_external_illu = flake . get_hamiltonian ( illumination = wave ) print ( hamiltonian_model_external_illu . keys ()) dict_keys(['bare_hamiltonian', 'coulomb', 'potential']) We add our own potentials to the Hamiltonian by adding entries to the dictionary, like hamiltonian_model[\"my_potential\"] = my_potential . The name for the potential does not matter; it's just nicer for us to look at than function pointers. In choosing my_potential , you have several options, documented in the API. For demonstration, we will model a dipole pulse from granad import potentials dip_pulse = potentials . DipolePulse ( dipole_moment = [ 1. , 0. , 0. ], source_location = [ 0. , 0. , 1. ], omega = 3 , sigma = 1 , t0 = 3 ) We can visualize its impact at any time t. The potential is a function and returns a diagonal matrix, so we can do the following (the arguments to this function will be explained in the tutorial on custom master equations, for now we just live with them). import jax.numpy as jnp time = 1.0 flake . show_2d ( display = jnp . abs ( dip_pulse ( time , 0 , # this argument will be explained in another tutorial, you can always pass in 0 flake . get_args () # this argument will be explained in another tutorial, you can always copy this ) . diagonal ()) ) We can now include it in the Hamiltonian hamiltonian_model [ \"dipole_pulse\" ] = dip_pulse To simulate this Hamiltonian instead of the default one, we have to pass it explicitly to the TD simulation function import diffrax result = flake . master_equation ( end_time = 40.0 , hamiltonian = hamiltonian_model , expectation_values = [ flake . dipole_operator ], relaxation_rate = 1 / 10 , solver = diffrax . Dopri8 () # high accuracy explicit solver to avoid oscillating tails ) flake . show_res ( result ) RHS compiled 100.0 % You can simulate any number of dipoles (or terms) by just adding more keys to the dictionary. Just name them differently, e.g., \"dipole_1\", \"dipole_2\", to make sure they don't get overwritten. DANGER: We did not need the illumination argument and so the result object contains no information on it. It is populated with zeroes by default print ( result . td_illumination ) [[0.+0.j 0.+0.j 0.+0.j] [0.+0.j 0.+0.j 0.+0.j] [0.+0.j 0.+0.j 0.+0.j] ... [0.+0.j 0.+0.j 0.+0.j] [0.+0.j 0.+0.j 0.+0.j] [0.+0.j 0.+0.j 0.+0.j]] You can still supply an illumination function, which will be used as the attribute.","title":"Potentials"},{"location":"tutorials/k_potentials/#potentials","text":"GRANAD lets you specify coupling to external light using (an arbitrary combination of) electromagnetic potentials. You do this by modifying GRANAD's internal representation of the Hamiltonian, which is just a dictionary.","title":"Potentials"},{"location":"tutorials/k_potentials/#background","text":"Consider GRANAD's master equation \\[\\dot{\\rho}(t) = -i [H[t,\\rho(t)], \\rho] + \\mathcal{D}[t, \\rho]\\] By default, GRANAD simulates the following dipole-gauge expression for the Hamiltonian including an external electric field \\(\\vec{E}\\) \\[H[t,\\rho(t)] = h^{0} + \\vec{E} \\vec{P} + C(\\rho(t) - \\rho^{0})\\] where \\(h^{0}\\) is the unperturbed or bare Hamiltonian constructed from localized orbitals. \\(\\vec{P}\\) is the polarization operator depending on space \\(\\vec{r}\\) and transition dipole moments \\(\\vec{d}\\) , leading to an interatomic potential \\(\\vec{E}\\vec{r}\\) and an intra-atomic potential \\(\\vec{E} \\vec{d}\\) . \\(\\rho^{0}\\) is the stationary density matrix of the system's ground state, and \\(C\\) is the Coulomb matrix (a subset of ERIs). You can modify GRANAD's internal representation of the Hamiltonian to include your own potential terms. Here, you have two options: Define potentials completely on your own. Use built-in potentials. The first solution is more flexible, but a bit more complicated, so we will focus on the built-in potentials in this tutorial.","title":"Background"},{"location":"tutorials/k_potentials/#built-in-potentials","text":"First, we set up our small triangle. from granad import MaterialCatalog , Triangle flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Triangle ( 15 ), plot = True ) If we call flake.master_equation , the flake will turn the arguments we passed in (e.g., the illumination) into a representation of the Hamiltonian. By default, this representation corresponds to the dipole-gauge model discussed above. This representation will be passed to \"lower-level\" simulation functions. These functions will turn it into arrays and integrate it. We can directly look at this representation. hamiltonian_model = flake . get_hamiltonian () print ( hamiltonian_model ) {'bare_hamiltonian': <function BareHamiltonian.<locals>.<lambda> at 0x7f2d8cd1ea20>, 'coulomb': <function Coulomb.<locals>.<lambda> at 0x7f2d8cd1ec00>} We see that it is just a dictionary. The keys are strings, the values are functions. Each function is a term in the Hamiltonian. You can tell which one by looking at the keys again print ( hamiltonian_model . keys ()) dict_keys(['bare_hamiltonian', 'coulomb']) So, as we said, we have a bare hamiltonian, and an induced coulomb interaction. But where is the dipole gauge coupling? Remember that we did not pass in any external illumination, so GRANAD assumes there is none. Let's change this quickly from granad import Wave wave = Wave ( amplitudes = [ 1.0 , 0. , 0. ], frequency = 1.0 ) hamiltonian_model_external_illu = flake . get_hamiltonian ( illumination = wave ) print ( hamiltonian_model_external_illu . keys ()) dict_keys(['bare_hamiltonian', 'coulomb', 'potential']) We add our own potentials to the Hamiltonian by adding entries to the dictionary, like hamiltonian_model[\"my_potential\"] = my_potential . The name for the potential does not matter; it's just nicer for us to look at than function pointers. In choosing my_potential , you have several options, documented in the API. For demonstration, we will model a dipole pulse from granad import potentials dip_pulse = potentials . DipolePulse ( dipole_moment = [ 1. , 0. , 0. ], source_location = [ 0. , 0. , 1. ], omega = 3 , sigma = 1 , t0 = 3 ) We can visualize its impact at any time t. The potential is a function and returns a diagonal matrix, so we can do the following (the arguments to this function will be explained in the tutorial on custom master equations, for now we just live with them). import jax.numpy as jnp time = 1.0 flake . show_2d ( display = jnp . abs ( dip_pulse ( time , 0 , # this argument will be explained in another tutorial, you can always pass in 0 flake . get_args () # this argument will be explained in another tutorial, you can always copy this ) . diagonal ()) ) We can now include it in the Hamiltonian hamiltonian_model [ \"dipole_pulse\" ] = dip_pulse To simulate this Hamiltonian instead of the default one, we have to pass it explicitly to the TD simulation function import diffrax result = flake . master_equation ( end_time = 40.0 , hamiltonian = hamiltonian_model , expectation_values = [ flake . dipole_operator ], relaxation_rate = 1 / 10 , solver = diffrax . Dopri8 () # high accuracy explicit solver to avoid oscillating tails ) flake . show_res ( result ) RHS compiled 100.0 % You can simulate any number of dipoles (or terms) by just adding more keys to the dictionary. Just name them differently, e.g., \"dipole_1\", \"dipole_2\", to make sure they don't get overwritten. DANGER: We did not need the illumination argument and so the result object contains no information on it. It is populated with zeroes by default print ( result . td_illumination ) [[0.+0.j 0.+0.j 0.+0.j] [0.+0.j 0.+0.j 0.+0.j] [0.+0.j 0.+0.j 0.+0.j] ... [0.+0.j 0.+0.j 0.+0.j] [0.+0.j 0.+0.j 0.+0.j] [0.+0.j 0.+0.j 0.+0.j]] You can still supply an illumination function, which will be used as the attribute.","title":"Built-in Potentials"},{"location":"tutorials/l_master/","text":"Custom Time Evolution GRANAD lets you customize the Master Equation you simulate and extract any information from it. Note : Please consult the tutorial on potentials first. Note : While a bit more complicated, this tutorial can help you make your simulations not only more versatile, but also increase their efficiency. Note : This is still rough. In the future, I might package the functions into a \"Term\" object or sth like that, but this will be purely cosmetic. The underlying functions won't change. Hamiltonian When calling the integration for the master equation, you can give an optional argument, hamiltonian . As already discussed, this argument represents a Hamiltonian as a dictionary of functions. Up to now, we just wanted to use custom potentials, so we simply added them to the dictionary. Let's look more closely at what is going on by considering a flake under CW illumination. from granad import MaterialCatalog , Triangle , Wave flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Triangle ( 15 ) ) wave = Wave ( amplitudes = [ 1.0 , 0. , 0. ], frequency = 1.0 ) hamiltonian_model = flake . get_hamiltonian ( illumination = wave ) print ( hamiltonian_model . keys ()) dict_keys(['bare_hamiltonian', 'coulomb', 'potential']) As discussed, the default Hamiltonian just has three terms: a bare hamiltonian. an induced coulomb interaction. an external potential. Each of these terms is represented by a function. Every function accepts the following three arguments: time the density matrix at this time an argument object args . It contains all required \"static\" information, like relaxation rates, energies or operators (remember we use the Schr\u00f6dinger picture, so, e.g. the dipole operator does not depend on time). Every function maps these arguments to a complex matrix. Before running a simulation, the functions in the dictionary get turned into a list func_list . The matrix representation of the Hamiltonian is then given by applying and adding these functions, like so H[time] = sum( f(times[time], density_matrix[time], args) for f in func_list ) . Argument Objects What does the args object contain, exactly? We can create this object ourselves. It is just a named tuple (like a C struct) and we can inspect its contents by looking at its fields args = flake . get_args () print ( args . _fields ) ('hamiltonian', 'energies', 'coulomb_scaled', 'initial_density_matrix', 'stationary_density_matrix', 'eigenvectors', 'dipole_operator', 'electrons', 'relaxation_rate', 'propagator', 'spin_degeneracy', 'positions') We can access individual entries print ( args . dipole_operator . shape ) (3, 46, 46) The args object is a lower-level representation of our OrbitalList object: a collection of numbers and arrays that represent the structure we are simulating. The time evolution depends on time, the density matrix and the structure we are simulating. This is directly reflected in the signature of a \"term\". As discussed above, a single function in the Hamiltonian looks like term: time, density_matrix, args -> matrix . Computing Terms Now that we know everything, we can take out and apply individual terms of the default Hamiltonian. First, let's check that the bare hamiltonian is correct import jax.numpy as jnp h_bare = hamiltonian_model [ \"bare_hamiltonian\" ] time = 0.0 jnp . all ( flake . hamiltonian == h_bare ( time , args . initial_density_matrix , args )) Array(True, dtype=bool) The function just returns the bare hamiltonian, independent of the time and density matrix. Let's compute the coulomb potential at the initial time coulomb = hamiltonian_model [ \"coulomb\" ] coulomb_matrix = coulomb ( time , args . initial_density_matrix , args ) jnp . all ( coulomb_matrix == 0.0 ) Array(True, dtype=bool) Right at the beginning, there is no induced coulomb potential (all entries in the matrix are zero), because the system is initially in its ground state. Last, there is the external potential. Since we do not have transition dipole moments, it will be entirely diagonal potential = hamiltonian_model [ \"potential\" ] potential_matrix = potential ( time , args . initial_density_matrix , args ) jnp . all ( potential_matrix == jnp . diag ( potential_matrix . diagonal ()) ) Array(True, dtype=bool) Modelling Terms Now we know how to inject arbitrary terms in the time evolution. We must define a function that Accepts time, density_matrix, args Returns a NxN complex matrix Additionally, the function must be JAX-JIT compatible. In essence, use only Python and jax.numpy operations. Then we just insert it in the dictionary, potentially overwriting a default key (remember the keys don't matter, you can add as many functions as you want and name them however you want). Let's illustrate this at the example of a custom scalar potential. We want to replace the dipole-gauge coupling \\(E P\\) with a scalar potential representing a plane-wave pulse. Let's define this potential first amplitudes = jnp . array ([ 1e-5 , 0 , 0 ]) omega = 2 * jnp . pi sigma = 1 t0 = 4 def pulsed_potential ( time , density_matrix , args ): field = ( amplitudes * jnp . cos ( omega * time ) * jnp . exp ( - ( time - t0 ) ** 2 / sigma ** 2 ) ) diagonal_part = args . positions @ field return jnp . diag ( diagonal_part ) Now, we replace the default potential with our custom term, just as we did before in the case of the pulsed dipole. hamiltonian_model [ \"potential\" ] = pulsed_potential To run a time-domain simulation, we just pass the modified hamiltonian dictionary directly, as demonstrated in the first section result = flake . master_equation ( hamiltonian = hamiltonian_model , expectation_values = [ flake . dipole_operator ], relaxation_rate = 1 / 10 , end_time = 40 ) flake . show_res ( result ) RHS compiled 100.0 % That's it. Custom Argument Objects TBD Modelling Dissipators Dissipators work exactly like the Hamiltonian. Define a function diss : time, density_matrix, args -> jax.Array put it in a dictionary dissipator_model[\"diss\"] = diss Pass dissipator = dissipator_model to the integrator function. You can also get defaults dissipator_model = flake . get_dissipator ( relaxation_rate = 1 / 10 ) print ( dissipator_model ) {'decoherence_time': <function DecoherenceTime.<locals>.<lambda> at 0x7f19f0bb2660>} Postprocesses You can define custom postprocesses. These are functions with the signature postprocess : density_matrix_batch, args -> array . The density_matrix_batch is an array of shape TxNxN , where T encodes time. For example, if you are only interested in the occupation of the 0-th state def extract_element ( density_matrices , args ): return density_matrices [:, 0 , 0 ] result = flake . master_equation ( postprocesses = { \"element\" : extract_element }, relaxation_rate = 1 / 10 , end_time = 40 ) print ( result . output [ 0 ] . shape ) RHS compiled 100.0 % (4000,)","title":"Custom Time Evolution"},{"location":"tutorials/l_master/#custom-time-evolution","text":"GRANAD lets you customize the Master Equation you simulate and extract any information from it. Note : Please consult the tutorial on potentials first. Note : While a bit more complicated, this tutorial can help you make your simulations not only more versatile, but also increase their efficiency. Note : This is still rough. In the future, I might package the functions into a \"Term\" object or sth like that, but this will be purely cosmetic. The underlying functions won't change.","title":"Custom Time Evolution"},{"location":"tutorials/l_master/#hamiltonian","text":"When calling the integration for the master equation, you can give an optional argument, hamiltonian . As already discussed, this argument represents a Hamiltonian as a dictionary of functions. Up to now, we just wanted to use custom potentials, so we simply added them to the dictionary. Let's look more closely at what is going on by considering a flake under CW illumination. from granad import MaterialCatalog , Triangle , Wave flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Triangle ( 15 ) ) wave = Wave ( amplitudes = [ 1.0 , 0. , 0. ], frequency = 1.0 ) hamiltonian_model = flake . get_hamiltonian ( illumination = wave ) print ( hamiltonian_model . keys ()) dict_keys(['bare_hamiltonian', 'coulomb', 'potential']) As discussed, the default Hamiltonian just has three terms: a bare hamiltonian. an induced coulomb interaction. an external potential. Each of these terms is represented by a function. Every function accepts the following three arguments: time the density matrix at this time an argument object args . It contains all required \"static\" information, like relaxation rates, energies or operators (remember we use the Schr\u00f6dinger picture, so, e.g. the dipole operator does not depend on time). Every function maps these arguments to a complex matrix. Before running a simulation, the functions in the dictionary get turned into a list func_list . The matrix representation of the Hamiltonian is then given by applying and adding these functions, like so H[time] = sum( f(times[time], density_matrix[time], args) for f in func_list ) .","title":"Hamiltonian"},{"location":"tutorials/l_master/#argument-objects","text":"What does the args object contain, exactly? We can create this object ourselves. It is just a named tuple (like a C struct) and we can inspect its contents by looking at its fields args = flake . get_args () print ( args . _fields ) ('hamiltonian', 'energies', 'coulomb_scaled', 'initial_density_matrix', 'stationary_density_matrix', 'eigenvectors', 'dipole_operator', 'electrons', 'relaxation_rate', 'propagator', 'spin_degeneracy', 'positions') We can access individual entries print ( args . dipole_operator . shape ) (3, 46, 46) The args object is a lower-level representation of our OrbitalList object: a collection of numbers and arrays that represent the structure we are simulating. The time evolution depends on time, the density matrix and the structure we are simulating. This is directly reflected in the signature of a \"term\". As discussed above, a single function in the Hamiltonian looks like term: time, density_matrix, args -> matrix .","title":"Argument Objects"},{"location":"tutorials/l_master/#computing-terms","text":"Now that we know everything, we can take out and apply individual terms of the default Hamiltonian. First, let's check that the bare hamiltonian is correct import jax.numpy as jnp h_bare = hamiltonian_model [ \"bare_hamiltonian\" ] time = 0.0 jnp . all ( flake . hamiltonian == h_bare ( time , args . initial_density_matrix , args )) Array(True, dtype=bool) The function just returns the bare hamiltonian, independent of the time and density matrix. Let's compute the coulomb potential at the initial time coulomb = hamiltonian_model [ \"coulomb\" ] coulomb_matrix = coulomb ( time , args . initial_density_matrix , args ) jnp . all ( coulomb_matrix == 0.0 ) Array(True, dtype=bool) Right at the beginning, there is no induced coulomb potential (all entries in the matrix are zero), because the system is initially in its ground state. Last, there is the external potential. Since we do not have transition dipole moments, it will be entirely diagonal potential = hamiltonian_model [ \"potential\" ] potential_matrix = potential ( time , args . initial_density_matrix , args ) jnp . all ( potential_matrix == jnp . diag ( potential_matrix . diagonal ()) ) Array(True, dtype=bool)","title":"Computing Terms"},{"location":"tutorials/l_master/#modelling-terms","text":"Now we know how to inject arbitrary terms in the time evolution. We must define a function that Accepts time, density_matrix, args Returns a NxN complex matrix Additionally, the function must be JAX-JIT compatible. In essence, use only Python and jax.numpy operations. Then we just insert it in the dictionary, potentially overwriting a default key (remember the keys don't matter, you can add as many functions as you want and name them however you want). Let's illustrate this at the example of a custom scalar potential. We want to replace the dipole-gauge coupling \\(E P\\) with a scalar potential representing a plane-wave pulse. Let's define this potential first amplitudes = jnp . array ([ 1e-5 , 0 , 0 ]) omega = 2 * jnp . pi sigma = 1 t0 = 4 def pulsed_potential ( time , density_matrix , args ): field = ( amplitudes * jnp . cos ( omega * time ) * jnp . exp ( - ( time - t0 ) ** 2 / sigma ** 2 ) ) diagonal_part = args . positions @ field return jnp . diag ( diagonal_part ) Now, we replace the default potential with our custom term, just as we did before in the case of the pulsed dipole. hamiltonian_model [ \"potential\" ] = pulsed_potential To run a time-domain simulation, we just pass the modified hamiltonian dictionary directly, as demonstrated in the first section result = flake . master_equation ( hamiltonian = hamiltonian_model , expectation_values = [ flake . dipole_operator ], relaxation_rate = 1 / 10 , end_time = 40 ) flake . show_res ( result ) RHS compiled 100.0 % That's it.","title":"Modelling Terms"},{"location":"tutorials/l_master/#custom-argument-objects","text":"TBD","title":"Custom Argument Objects"},{"location":"tutorials/l_master/#modelling-dissipators","text":"Dissipators work exactly like the Hamiltonian. Define a function diss : time, density_matrix, args -> jax.Array put it in a dictionary dissipator_model[\"diss\"] = diss Pass dissipator = dissipator_model to the integrator function. You can also get defaults dissipator_model = flake . get_dissipator ( relaxation_rate = 1 / 10 ) print ( dissipator_model ) {'decoherence_time': <function DecoherenceTime.<locals>.<lambda> at 0x7f19f0bb2660>}","title":"Modelling Dissipators"},{"location":"tutorials/l_master/#postprocesses","text":"You can define custom postprocesses. These are functions with the signature postprocess : density_matrix_batch, args -> array . The density_matrix_batch is an array of shape TxNxN , where T encodes time. For example, if you are only interested in the occupation of the 0-th state def extract_element ( density_matrices , args ): return density_matrices [:, 0 , 0 ] result = flake . master_equation ( postprocesses = { \"element\" : extract_element }, relaxation_rate = 1 / 10 , end_time = 40 ) print ( result . output [ 0 ] . shape ) RHS compiled 100.0 % (4000,)","title":"Postprocesses"},{"location":"tutorials/xyz/","text":"Exporting and Importing GRANAD lets you save orbitals to xyz files. It also offers rudimentary support for loading orbitals from xyz files. For demonstration, we will create a triangular flake, print its xyz representation, save it to file and reload it. from granad import MaterialCatalog , Triangle , OrbitalList graphene = MaterialCatalog . get ( \"graphene\" ) flake = graphene . cut_flake ( Triangle ( 15 ) ) We can look at only the atoms in this file. They are given as a dictionary. The type of atom is the key. The value is all positions where atoms of this type are. print ( flake . atoms ) defaultdict(<class 'list'>, {'C': [['-4.92', '-4.260844986619438', '0.0'], ['-6.15', '-2.130422493309719', '0.0'], ['-2.46', '-4.260844986619438', '0.0'], ['-3.69', '-2.130422493309719', '0.0'], ['-4.92', '0.0', '0.0'], ['0.0', '-4.260844986619438', '0.0'], ['-1.23', '-2.130422493309719', '0.0'], ['-2.46', '0.0', '0.0'], ['-3.69', '2.130422493309719', '0.0'], ['2.46', '-4.260844986619438', '0.0'], ['1.23', '-2.130422493309719', '0.0'], ['0.0', '0.0', '0.0'], ['-1.23', '2.130422493309719', '0.0'], ['-2.46', '4.260844986619438', '0.0'], ['4.92', '-4.260844986619438', '0.0'], ['3.69', '-2.130422493309719', '0.0'], ['2.46', '0.0', '0.0'], ['1.23', '2.130422493309719', '0.0'], ['0.0', '4.260844986619438', '0.0'], ['-1.23', '6.391267479929157', '0.0'], ['6.15', '-2.130422493309719', '0.0'], ['4.92', '0.0', '0.0'], ['3.69', '2.130422493309719', '0.0'], ['2.46', '4.260844986619438', '0.0'], ['1.23', '6.391267479929157', '0.0'], ['-6.15', '-3.5507041555161982', '0.0'], ['-3.69', '-3.5507041555161982', '0.0'], ['-4.92', '-1.4202816622064793', '0.0'], ['-1.23', '-3.5507041555161982', '0.0'], ['-2.46', '-1.4202816622064793', '0.0'], ['-3.69', '0.7101408311032397', '0.0'], ['1.23', '-3.5507041555161982', '0.0'], ['0.0', '-1.4202816622064793', '0.0'], ['-1.23', '0.7101408311032397', '0.0'], ['-2.46', '2.8405633244129587', '0.0'], ['3.69', '-3.5507041555161982', '0.0'], ['2.46', '-1.4202816622064793', '0.0'], ['1.23', '0.7101408311032397', '0.0'], ['0.0', '2.8405633244129587', '0.0'], ['-1.23', '4.970985817722678', '0.0'], ['6.15', '-3.5507041555161982', '0.0'], ['4.92', '-1.4202816622064793', '0.0'], ['3.69', '0.7101408311032397', '0.0'], ['2.46', '2.8405633244129587', '0.0'], ['1.23', '4.970985817722678', '0.0'], ['0.0', '7.1014083110323964', '0.0']]}) If you supply no name to the to_xyz method, it will just return the string print ( flake . to_xyz ()) 46 C -4.92 -4.260844986619438 0.0 C -6.15 -2.130422493309719 0.0 C -2.46 -4.260844986619438 0.0 C -3.69 -2.130422493309719 0.0 C -4.92 0.0 0.0 C 0.0 -4.260844986619438 0.0 C -1.23 -2.130422493309719 0.0 C -2.46 0.0 0.0 C -3.69 2.130422493309719 0.0 C 2.46 -4.260844986619438 0.0 C 1.23 -2.130422493309719 0.0 C 0.0 0.0 0.0 C -1.23 2.130422493309719 0.0 C -2.46 4.260844986619438 0.0 C 4.92 -4.260844986619438 0.0 C 3.69 -2.130422493309719 0.0 C 2.46 0.0 0.0 C 1.23 2.130422493309719 0.0 C 0.0 4.260844986619438 0.0 C -1.23 6.391267479929157 0.0 C 6.15 -2.130422493309719 0.0 C 4.92 0.0 0.0 C 3.69 2.130422493309719 0.0 C 2.46 4.260844986619438 0.0 C 1.23 6.391267479929157 0.0 C -6.15 -3.5507041555161982 0.0 C -3.69 -3.5507041555161982 0.0 C -4.92 -1.4202816622064793 0.0 C -1.23 -3.5507041555161982 0.0 C -2.46 -1.4202816622064793 0.0 C -3.69 0.7101408311032397 0.0 C 1.23 -3.5507041555161982 0.0 C 0.0 -1.4202816622064793 0.0 C -1.23 0.7101408311032397 0.0 C -2.46 2.8405633244129587 0.0 C 3.69 -3.5507041555161982 0.0 C 2.46 -1.4202816622064793 0.0 C 1.23 0.7101408311032397 0.0 C 0.0 2.8405633244129587 0.0 C -1.23 4.970985817722678 0.0 C 6.15 -3.5507041555161982 0.0 C 4.92 -1.4202816622064793 0.0 C 3.69 0.7101408311032397 0.0 C 2.46 2.8405633244129587 0.0 C 1.23 4.970985817722678 0.0 C 0.0 7.1014083110323964 0.0 If you want to save this to a file, do flake . to_xyz ( 'flake.xyz' ) You can also reload, although this is limited: all atoms in the xyz file get the same group id by default. new_flake = OrbitalList . from_xyz ( 'flake.xyz' ) assert new_flake . atoms == flake . atoms","title":"Exporting and Importing"},{"location":"tutorials/xyz/#exporting-and-importing","text":"GRANAD lets you save orbitals to xyz files. It also offers rudimentary support for loading orbitals from xyz files. For demonstration, we will create a triangular flake, print its xyz representation, save it to file and reload it. from granad import MaterialCatalog , Triangle , OrbitalList graphene = MaterialCatalog . get ( \"graphene\" ) flake = graphene . cut_flake ( Triangle ( 15 ) ) We can look at only the atoms in this file. They are given as a dictionary. The type of atom is the key. The value is all positions where atoms of this type are. print ( flake . atoms ) defaultdict(<class 'list'>, {'C': [['-4.92', '-4.260844986619438', '0.0'], ['-6.15', '-2.130422493309719', '0.0'], ['-2.46', '-4.260844986619438', '0.0'], ['-3.69', '-2.130422493309719', '0.0'], ['-4.92', '0.0', '0.0'], ['0.0', '-4.260844986619438', '0.0'], ['-1.23', '-2.130422493309719', '0.0'], ['-2.46', '0.0', '0.0'], ['-3.69', '2.130422493309719', '0.0'], ['2.46', '-4.260844986619438', '0.0'], ['1.23', '-2.130422493309719', '0.0'], ['0.0', '0.0', '0.0'], ['-1.23', '2.130422493309719', '0.0'], ['-2.46', '4.260844986619438', '0.0'], ['4.92', '-4.260844986619438', '0.0'], ['3.69', '-2.130422493309719', '0.0'], ['2.46', '0.0', '0.0'], ['1.23', '2.130422493309719', '0.0'], ['0.0', '4.260844986619438', '0.0'], ['-1.23', '6.391267479929157', '0.0'], ['6.15', '-2.130422493309719', '0.0'], ['4.92', '0.0', '0.0'], ['3.69', '2.130422493309719', '0.0'], ['2.46', '4.260844986619438', '0.0'], ['1.23', '6.391267479929157', '0.0'], ['-6.15', '-3.5507041555161982', '0.0'], ['-3.69', '-3.5507041555161982', '0.0'], ['-4.92', '-1.4202816622064793', '0.0'], ['-1.23', '-3.5507041555161982', '0.0'], ['-2.46', '-1.4202816622064793', '0.0'], ['-3.69', '0.7101408311032397', '0.0'], ['1.23', '-3.5507041555161982', '0.0'], ['0.0', '-1.4202816622064793', '0.0'], ['-1.23', '0.7101408311032397', '0.0'], ['-2.46', '2.8405633244129587', '0.0'], ['3.69', '-3.5507041555161982', '0.0'], ['2.46', '-1.4202816622064793', '0.0'], ['1.23', '0.7101408311032397', '0.0'], ['0.0', '2.8405633244129587', '0.0'], ['-1.23', '4.970985817722678', '0.0'], ['6.15', '-3.5507041555161982', '0.0'], ['4.92', '-1.4202816622064793', '0.0'], ['3.69', '0.7101408311032397', '0.0'], ['2.46', '2.8405633244129587', '0.0'], ['1.23', '4.970985817722678', '0.0'], ['0.0', '7.1014083110323964', '0.0']]}) If you supply no name to the to_xyz method, it will just return the string print ( flake . to_xyz ()) 46 C -4.92 -4.260844986619438 0.0 C -6.15 -2.130422493309719 0.0 C -2.46 -4.260844986619438 0.0 C -3.69 -2.130422493309719 0.0 C -4.92 0.0 0.0 C 0.0 -4.260844986619438 0.0 C -1.23 -2.130422493309719 0.0 C -2.46 0.0 0.0 C -3.69 2.130422493309719 0.0 C 2.46 -4.260844986619438 0.0 C 1.23 -2.130422493309719 0.0 C 0.0 0.0 0.0 C -1.23 2.130422493309719 0.0 C -2.46 4.260844986619438 0.0 C 4.92 -4.260844986619438 0.0 C 3.69 -2.130422493309719 0.0 C 2.46 0.0 0.0 C 1.23 2.130422493309719 0.0 C 0.0 4.260844986619438 0.0 C -1.23 6.391267479929157 0.0 C 6.15 -2.130422493309719 0.0 C 4.92 0.0 0.0 C 3.69 2.130422493309719 0.0 C 2.46 4.260844986619438 0.0 C 1.23 6.391267479929157 0.0 C -6.15 -3.5507041555161982 0.0 C -3.69 -3.5507041555161982 0.0 C -4.92 -1.4202816622064793 0.0 C -1.23 -3.5507041555161982 0.0 C -2.46 -1.4202816622064793 0.0 C -3.69 0.7101408311032397 0.0 C 1.23 -3.5507041555161982 0.0 C 0.0 -1.4202816622064793 0.0 C -1.23 0.7101408311032397 0.0 C -2.46 2.8405633244129587 0.0 C 3.69 -3.5507041555161982 0.0 C 2.46 -1.4202816622064793 0.0 C 1.23 0.7101408311032397 0.0 C 0.0 2.8405633244129587 0.0 C -1.23 4.970985817722678 0.0 C 6.15 -3.5507041555161982 0.0 C 4.92 -1.4202816622064793 0.0 C 3.69 0.7101408311032397 0.0 C 2.46 2.8405633244129587 0.0 C 1.23 4.970985817722678 0.0 C 0.0 7.1014083110323964 0.0 If you want to save this to a file, do flake . to_xyz ( 'flake.xyz' ) You can also reload, although this is limited: all atoms in the xyz file get the same group id by default. new_flake = OrbitalList . from_xyz ( 'flake.xyz' ) assert new_flake . atoms == flake . atoms","title":"Exporting and Importing"}]}