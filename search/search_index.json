{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to GRANAD GRANAD (GRAphene Nanoflakes with ADatoms) is a tight-binding simulation utility geared towards the exploration of systems at the intersection of solid state physics and quantum optics. Features Computes optical and electronic properties Full access to time-dependent density matrices via master equation Relies on JAX for performance and differentiability Installation pip install git+https://github.com/GRANADlauncher/granad.git Quickstart Set up the simulation import jax.numpy as jnp from granad import MaterialCatalog , Triangle # get material graphene = MaterialCatalog . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ) ) # frequencies omegas = jnp . linspace ( 0 , 5 , 50 ) # compute optical properties in the RPA with GPU-acceleration polarizability = flake . get_polarizability_rpa ( omegas , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 # higher numbers are faster and consume more RAM ) absorption = polarizability . imag * 4 * jnp . pi * omegas Plot the results import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas , absorption / jnp . max ( absorption ), linewidth = 2 ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . grid ( True )","title":"Home"},{"location":"#welcome-to-granad","text":"GRANAD (GRAphene Nanoflakes with ADatoms) is a tight-binding simulation utility geared towards the exploration of systems at the intersection of solid state physics and quantum optics.","title":"Welcome to GRANAD"},{"location":"#features","text":"Computes optical and electronic properties Full access to time-dependent density matrices via master equation Relies on JAX for performance and differentiability","title":"Features"},{"location":"#installation","text":"pip install git+https://github.com/GRANADlauncher/granad.git","title":"Installation"},{"location":"#quickstart","text":"Set up the simulation import jax.numpy as jnp from granad import MaterialCatalog , Triangle # get material graphene = MaterialCatalog . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ) ) # frequencies omegas = jnp . linspace ( 0 , 5 , 50 ) # compute optical properties in the RPA with GPU-acceleration polarizability = flake . get_polarizability_rpa ( omegas , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 # higher numbers are faster and consume more RAM ) absorption = polarizability . imag * 4 * jnp . pi * omegas Plot the results import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas , absorption / jnp . max ( absorption ), linewidth = 2 ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . grid ( True )","title":"Quickstart"},{"location":"about/","text":"About GRANAD is developed jointly at the Karlsruhe Institute of Technology by the Institute of Theoretical Solid State Physics and at the Nicolaus Copernicus University in Toru\u0144 by the Department of Quantum Physics .","title":"About"},{"location":"about/#about","text":"GRANAD is developed jointly at the Karlsruhe Institute of Technology by the Institute of Theoretical Solid State Physics and at the Nicolaus Copernicus University in Toru\u0144 by the Department of Quantum Physics .","title":"About"},{"location":"api/","text":"API Orbital dataclass Represents the quantum state of an electron in an atom with specific properties. Attributes: position ( Array ) \u2013 The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index ( Optional [ int ] ) \u2013 An optional index representing the layer of the orbital within its atom, may be None if not specified. tag ( Optional [ str ] ) \u2013 An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level ( Optional [ int ] ) \u2013 The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum ( Optional [ int ] ) \u2013 The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z ( Optional [ int ] ) \u2013 The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin ( Optional [ int ] ) \u2013 The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name ( Optional [ str ] ) \u2013 The name of the atom this orbital belongs to, can be None if not applicable. group_id ( int ) \u2013 A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. For example, all pz orbitals in a single graphene flake get the same group_id. Key Functionality The most important attributes of an orbtial are group_id (automatically generated, not recommended to be set it by the user) tag (user-defined or predefined for existing materials) Source code in src/granad/orbitals.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @dataclass class Orbital : \"\"\" Represents the quantum state of an electron in an atom with specific properties. Attributes: position (jax.Array): The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom, may be None if not specified. tag (Optional[str]): An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable. group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. For example, all pz orbitals in a single graphene flake get the same group_id. Key Functionality: The most important attributes of an orbtial are group_id (automatically generated, not recommended to be set it by the user) tag (user-defined or predefined for existing materials) \"\"\" position : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 , 0 , 0 ]), hash = False , compare = False ) layer_index : Optional [ int ] = None tag : Optional [ str ] = None energy_level : Optional [ int ] = None angular_momentum : Optional [ int ] = None angular_momentum_z : Optional [ int ] = None spin : Optional [ int ] = None atom_name : Optional [ str ] = None group_id : int = field ( default_factory = _watchdog . _Watchdog . next_value ) def __post_init__ ( self ): object . __setattr__ ( self , \"position\" , jnp . array ( self . position ) . astype ( float )) def __hash__ ( self ): # Include only immutable fields in hash calculation return hash ( ( self . layer_index , self . tag , self . energy_level , self . angular_momentum , self . angular_momentum_z , self . angular_momentum , self . spin , self . atom_name , self . group_id , ) ) def __str__ ( self ): return pformat ( vars ( self ), sort_dicts = False ) def __eq__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id == other . group_id and self . layer_index == other . layer_index def __lt__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id < self . group_id def __le__ ( self , other ): return self < other or self == other def __gt__ ( self , other ): return not self <= other def __ge__ ( self , other ): return not self < other def __ne__ ( self , other ): return not self == other OrbitalList A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list, while also maintaining additional functionalities for coupling orbitals and managing their relationships. The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries, where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float or a function representing the coupling strength or mechanism between the orbitals). The class also stores simulation parameters like the number of electrons and temperature in a dataclass. The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so quantity_x == quantity. The class exposes simulation methods. Attributes: orbitals ( list ) \u2013 The underlying list that stores the orbitals. couplings ( dict ) \u2013 A dictionary where keys are tuples of orbital identifiers and values are the couplings (either float values or functions). Key Functionalities Orbital Identification : Orbitals can be identified either by their group_id, a direct reference to the orbital object itself, or via a user-defined tag. Index Access : Orbitals can be accessed and managed by their index in the list, allowing for list-like manipulation (addition, removal, access). Coupling Definition : Allows for the definition and adjustment of couplings between pairs of orbitals, identified by a tuple of their respective identifiers. These couplings can dynamically represent the interaction strength or be a computational function that defines the interaction. Note The coupling values can be dynamically modified. When two orbital lists are added, their couplings are merged, and their simulation parameters are wiped. Source code in src/granad/orbitals.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 @plotting_methods class OrbitalList : \"\"\" A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list, while also maintaining additional functionalities for coupling orbitals and managing their relationships. The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries, where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float or a function representing the coupling strength or mechanism between the orbitals). The class also stores simulation parameters like the number of electrons and temperature in a dataclass. The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so quantity_x == quantity. The class exposes simulation methods. Attributes: orbitals (list): The underlying list that stores the orbitals. couplings (dict): A dictionary where keys are tuples of orbital identifiers and values are the couplings (either float values or functions). Key Functionalities: - **Orbital Identification**: Orbitals can be identified either by their group_id, a direct reference to the orbital object itself, or via a user-defined tag. - **Index Access**: Orbitals can be accessed and managed by their index in the list, allowing for list-like manipulation (addition, removal, access). - **Coupling Definition**: Allows for the definition and adjustment of couplings between pairs of orbitals, identified by a tuple of their respective identifiers. These couplings can dynamically represent the interaction strength or be a computational function that defines the interaction. Note: The coupling values can be dynamically modified. When two orbital lists are added, their couplings are merged, and their simulation parameters are wiped. \"\"\" def __init__ ( self , orbs , _hopping_dict = None , _coulomb_dict = None , _transitions_dict = None ): # couplings are dicts mapping orbital pairs to couplings self . _hopping_dict = ( _hopping_dict if _hopping_dict is not None else _SortedTupleDict () ) self . _coulomb_dict = ( _coulomb_dict if _coulomb_dict is not None else _SortedTupleDict () ) self . _transitions_dict = _transitions_dict if _transitions_dict is not None else _SortedTupleDict () # contains all high-level simulation information self . _list = list ( orbs ) if orbs is not None else [] # flag for recomputing state self . _recompute = True self . simulation_params = SimulationParams () def __getattr__ ( self , property_name ): if property_name . endswith ( \"_x\" ): return getattr ( self , property_name [: - 2 ]) elif property_name . endswith ( \"_e\" ): return self . transform_to_energy_basis ( getattr ( self , property_name [: - 2 ]) ) def __len__ ( self ): return len ( self . _list ) # can't mutate, because orbitals are immutable def __getitem__ ( self , position ): return self . _list [ position ] def __repr__ ( self ): return repr ( self . _list ) def __str__ ( self ): info = f \"List with { len ( self ) } orbitals, { self . electrons } electrons.\" excited = f \" { self . excited_electrons } electrons excited from { self . from_state } to { self . to_state } .\" groups = \" \\n \" . join ( [ f \"group id { key } : { val } orbitals\" for key , val in Counter ( self . get_group_ids ()) . items () ] ) return \" \\n \" . join (( info , excited , groups )) def __iter__ ( self ): return iter ( self . _list ) def __add__ ( self , other ): if not self . _are_orbs ( other ): raise TypeError if any ( orb in other for orb in self . _list ): raise ValueError if isinstance ( other , OrbitalList ): new_hopping_dict = self . _hopping_dict . copy () new_hopping_dict . update ( other . _hopping_dict ) new_coulomb_dict = self . _coulomb_dict . copy () new_coulomb_dict . update ( other . _coulomb_dict ) new_transitions_dict = self . _transitions_dict . copy () new_transitions_dict . update ( other . _transitions_dict ) return OrbitalList ( ( self . _list + list ( other )) . copy (), _SortedTupleDict ( new_hopping_dict ), _SortedTupleDict ( new_coulomb_dict ), _SortedTupleDict ( new_transitions_dict ), ) @mutates def __setitem__ ( self , position , value ): if isinstance ( value , Orbital ): self . _list [ position ] = value raise TypeError def _delete_coupling ( self , orb , coupling ): keys_to_remove = [ key for key in coupling if orb in key ] for key in keys_to_remove : del coupling [ key ] @mutates def __delitem__ ( self , position ): orb = self . _list [ position ] self . _delete_coupling ( orb , self . _hopping_dict ) self . _delete_coupling ( orb , self . _coulomb_dict ) del self . _list [ position ] @staticmethod def _are_orbs ( candidate ): return all ( isinstance ( orb , Orbital ) for orb in candidate ) @mutates def _set_coupling ( self , orb_or_group_id1 , orb_or_group_id2 , val_or_func , coupling ): coupling [( orb_or_group_id1 , orb_or_group_id2 )] = val_or_func def _hamiltonian_coulomb ( self ): def fill_matrix ( matrix , coupling_dict ): dummy = jnp . arange ( len ( self )) triangle_mask = dummy [:, None ] >= dummy # TODO: in principle we can build a big tensor NxNxgroups, vmap over the last axis and sum the groups # first, we loop over all group_id couplings => interactions between groups for key , function in coupling_dict . group_id_items (): # TODO: big uff: we rely on the correct ordering of the group_ids for cols and rows, first key is always smaller than last keys => we get upper triangular valid indices # if it were the other way around, these would be zeroed by the triangle mask cols = group_ids == key [ 0 ] rows = ( group_ids == key [ 1 ])[:, None ] combination_indices = jnp . logical_and ( rows , cols ) valid_indices = jnp . logical_and ( triangle_mask , combination_indices ) function = jax . vmap ( function ) matrix = matrix . at [ valid_indices ] . set ( function ( distances [ valid_indices ]) ) # we now set single elements rows , cols , vals = [], [], [] for key , val in coupling_dict . orbital_items (): rows . append ( self . _list . index ( key [ 0 ])) cols . append ( self . _list . index ( key [ 1 ])) vals . append ( val ) matrix = matrix . at [ rows , cols ] . set ( vals ) return matrix + matrix . conj () . T - jnp . diag ( jnp . diag ( matrix )) # TODO: rounding positions = self . _get_positions () distances = jnp . round ( jnp . linalg . norm ( positions - positions [:, None ], axis =- 1 ), 6 ) group_ids = jnp . array ( self . get_group_ids ()) hamiltonian = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . _hopping_dict ) coulomb = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . _coulomb_dict ) return hamiltonian , coulomb def _get_positions ( self ): return jnp . array ([ orb . position for orb in self . _list ]) def _ensure_complex ( self , func_or_val ): if callable ( func_or_val ): return lambda x : func_or_val ( x ) + 0.0 j if isinstance ( func_or_val , ( int , float , complex )): return func_or_val + 0.0 j raise TypeError def _maybe_orbs_to_group_ids ( self , maybe_orbs ): def convert ( maybe_orb ): # TODO: check if this is really a group_id if isinstance ( maybe_orb , int ): return maybe_orb if isinstance ( maybe_orb , Orbital ): return maybe_orb . group_id return \"You have passed something that is neither an orbital nor a group_id\" return [ convert ( x ) for x in maybe_orbs ] def _maybe_indices_to_orbs ( self , maybe_indices ): def convert ( maybe_index ): if isinstance ( maybe_index , int ): return self . _list [ maybe_index ] if isinstance ( maybe_index , Orbital ): return maybe_index return \"You have passed something that is neither an orbital nor an index\" return [ convert ( x ) for x in maybe_indices ] def _build ( self ): assert len ( self ) > 0 self . _positions = self . _get_positions () self . _hamiltonian , self . _coulomb = self . _hamiltonian_coulomb () self . _eigenvectors , self . _energies = jax . lax . linalg . eigh ( self . _hamiltonian ) self . _initial_density_matrix = _numerics . _density_matrix ( self . _energies , self . electrons , self . spin_degeneracy , self . eps , self . from_state , self . to_state , self . excited_electrons , self . beta , ) self . _stationary_density_matrix = _numerics . _density_matrix ( self . _energies , self . electrons , self . spin_degeneracy , self . eps , jnp . array ([ 0 ]), jnp . array ([ 0 ]), jnp . array ([ 0 ]), self . beta , ) if self . self_consistency_params : ( self . _hamiltonian , self . _initial_density_matrix , self . _stationary_density_matrix , self . _energies , self . _eigenvectors , ) = _get_self_consistent ( self . _hamiltonian , self . _coulomb , self . _positions , self . spin_degeneracy , self . electrons , self . eps , self . _eigenvectors , self . _static_density_matrix , ** self . self_consistent_params , ) self . _initial_density_matrix = self . transform_to_site_basis ( self . _initial_density_matrix ) self . _stationary_density_matrix = self . transform_to_site_basis ( self . _stationary_density_matrix ) def get_group_ids ( self ): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [ orb . group_id for orb in self . _list ] def get_unique_group_ids ( self ): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list ( set ( self . get_group_ids ())) def set_groups_hopping ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _hopping_dict ) def set_groups_coulomb ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _coulomb_dict ) def set_hamiltonian_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _hopping_dict ) def set_coulomb_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _coulomb_dict ) def index ( self , orb ): return self . _list . index ( orb ) @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other ) @mutates def shift_by_vector ( self , tag_or_group_id , translation_vector ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag_or_group_id (str or int or list[int]): The tag, group_id to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" if isinstance ( tag_or_group_id , str ): orbs = [ orb for orb in self . _list if orb . tag == tag_or_group_id ] elif isinstance ( tag_or_group_id , int ): orbs = [ orb for orb in self . _list if orb . group_id == tag_or_group_id ] else : orbs = [ orb for orb in self . _list if orb . group_id in tag_or_group_id ] for orb in orbs : orb . position += jnp . array ( translation_vector ) @mutates def set_position ( self , tag , position ): \"\"\" Sets the position of all orbitals with a specific tag. Parameters: tag (str): The tag to match orbitals. position (jax.Array): The vector at which to move the orbitals Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [ orb for orb in self . _list if orb . tag == tag ] for orb in orbs : orb . position = position @mutates def make_self_consistent ( self , sc_params ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self . self_consistency_params = sc_params @mutates def set_electrons ( self , number ): self . simulation_params . electrons = number @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): maybe_int = jnp . array ( maybe_int ) if isinstance ( maybe_int , jax . Array ): return ( jnp . array ( maybe_int ) if maybe_int . ndim > 1 else jnp . array ([ maybe_int ]) ) raise TypeError self . simulation_params . from_state = maybe_int_to_arr ( from_state ) self . simulation_params . to_state = maybe_int_to_arr ( to_state ) self . simulation_params . excited_electrons = maybe_int_to_arr ( excited_electrons ) @mutates def set_dipole_transition ( self , orb_or_index1 , orb_or_index2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _transitions_dict [( orb_or_index1 , orb_or_index2 )] = jnp . array ( arr ) . astype ( complex ) @property @recomputes def homo ( self ): return ( self . electrons * self . stationary_density_matrix_e ) . real . diagonal () . round ( 2 ) . nonzero ()[ 0 ][ - 1 ] . item () @property def electrons ( self ): if self . simulation_params . electrons is None : return len ( self . _list ) return self . simulation_params . electrons @property def spin_degeneracy ( self ): return self . simulation_params . spin_degeneracy @property def from_state ( self ): return self . simulation_params . from_state @property def to_state ( self ): return self . simulation_params . to_state @property def excited_electrons ( self ): return self . simulation_params . excited_electrons @property def beta ( self ): return self . simulation_params . beta @property def eps ( self ): return self . simulation_params . eps @property @recomputes def positions ( self ): return self . _positions @property @recomputes def eigenvectors ( self ): return self . _eigenvectors @property @recomputes def energies ( self ): return self . _energies @property @recomputes def hamiltonian ( self ): return self . _hamiltonian @property @recomputes def coulomb ( self ): return self . _coulomb @property @recomputes def initial_density_matrix ( self ): return self . _initial_density_matrix @property @recomputes def stationary_density_matrix ( self ): return self . _stationary_density_matrix @property @recomputes def quadrupole_operator ( self ): \"\"\" Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: jax.Array: A tensor representing the quadrupole operator. \"\"\" dip = self . dipole_operator term = jnp . einsum ( \"ijk,jlm->ilkm\" , dip , dip ) diag = jnp . einsum ( \"ijk,jlk->il\" , dip , dip ) diag = jnp . einsum ( \"ij,kl->ijkl\" , diag , jnp . eye ( term . shape [ - 1 ])) return 3 * term - diag @property @recomputes def dipole_operator ( self ): \"\"\" Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. \"\"\" N = self . positions . shape [ 0 ] dipole_operator = jnp . zeros (( 3 , N , N )) . astype ( complex ) for i in range ( 3 ): dipole_operator = dipole_operator . at [ i , :, :] . set ( jnp . diag ( self . _positions [:, i ] / 2 ) ) for orbital_combination , value in self . _transitions_dict . items (): i , j = self . _list . index ( orbital_combination [ 0 ]), self . _list . index ( orbital_combination [ 1 ] ) k = value . nonzero ()[ 0 ] dipole_operator = dipole_operator . at [ k , i , j ] . set ( value [ k ]) return dipole_operator + jnp . transpose ( dipole_operator , ( 0 , 2 , 1 )) . conj () @property @recomputes def velocity_operator ( self ): \"\"\" Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. \"\"\" if self . _transitions_dict is None : x_times_h = jnp . einsum ( \"ij,iL->ijL\" , self . _hamiltonian , self . _positions ) h_times = jnp . einsum ( \"ij,jL->ijL\" , self . _hamiltonian , self . _positions ) else : positions = self . dipole_operator x_times_h = jnp . einsum ( \"kj,Lik->Lij\" , self . _hamiltonian , positions ) h_times = jnp . einsum ( \"ik,Lkj->Lij\" , self . _hamiltonian , positions ) return - 1 j * ( x_times_h - h_times ) @property @recomputes def transition_energies ( self ): \"\"\" Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: jax.Array: The element `arr[i,j]` contains the transition energy from `i` to `j`. \"\"\" return self . _energies [:, None ] - self . _energies @property @recomputes def wigner_weisskopf_transition_rates ( self ): \"\"\" Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: jax.Array: The element `arr[i,j]` contains the transition rate from `i` to `j`. \"\"\" charge = 1.602e-19 eps_0 = 8.85 * 1e-12 hbar = 1.0545718 * 1e-34 c = 3e8 # 137 (a.u.) factor = 1.6e-29 * charge / ( 3 * jnp . pi * eps_0 * hbar ** 2 * c ** 3 ) te = self . transition_energies transition_dipole_moments = self . dipole_operator_e return ( ( te * ( te > self . eps )) ** 3 * jnp . squeeze ( transition_dipole_moments ** 2 ) * factor ) @staticmethod def _transform_basis ( observable , vectors ): dims_einsum_strings = { 2 : \"ij,jk,lk->il\" , 3 : \"ij,mjk,lk->mil\" } einsum_string = dims_einsum_strings [( observable . ndim )] return jnp . einsum ( einsum_string , vectors , observable , vectors . conj ()) def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors ) def transform_to_energy_basis ( self , observable ): # \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T ) @recomputes def get_charge ( density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None : return jnp . diag ( self . initial_density_matrix * self . electrons ) else : return jnp . diag ( density_matrix * self . electrons ) @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians ) @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians ) @recomputes def get_epi ( self , density_matrix_stat : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = epsilon if epsilon is not None else self . eps density_matrix_stat_without_diagonal = jnp . abs ( density_matrix_stat - jnp . diag ( jnp . diag ( density_matrix_stat ))) density_matrix_stat_normalized = density_matrix_stat_without_diagonal / jnp . linalg . norm ( density_matrix_stat_without_diagonal ) te = self . transition_energies excitonic_transitions = ( density_matrix_stat_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * density_matrix_stat_normalized )) / ( jnp . linalg . norm ( density_matrix_stat_normalized ) * jnp . linalg . norm ( excitonic_transitions ) ) @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . _positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field def get_expectation_value ( self , * , operator , density_matrix , induced = True ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->li\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } correction = self . stationary_density_matrix_x if induced == True else 0 return self . electrons * jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , correction - density_matrix , ) def get_expectation_value_time_domain ( self , * args , ** kwargs ): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs . pop ( \"operator\" , None ) return_density = kwargs . pop ( \"return_density\" , False ) time_axis , density_matrices = self . get_density_matrix_time_domain ( * args , ** kwargs ) expectation_value = self . get_expectation_value ( density_matrix = density_matrices , operator = operator ) if return_density == True : return time_axis , expecation_value , density_matrices return time_axis , expectation_value def get_expectation_value_frequency_domain ( self , * args , ** kwargs ): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" density_matrices = kwargs . pop ( \"density_matrices\" , None ) time_axis = kwargs . pop ( \"time\" , None ) omega_min = kwargs . pop ( \"omega_min\" , 0 ) omega_max = kwargs . pop ( \"omega_max\" , 100 ) if density_matrices is None : time_axis , exp_val_td = self . get_expectation_value_time_domain ( * args , ** kwargs ) else : operator = kwargs . pop ( \"operator\" , None ) exp_val_td = self . get_expectation_value ( density_matrix = density_matrices , operator = operator ) omega , exp_val_omega = _numerics . get_fourier_transform ( time_axis , exp_val_td ) mask = ( omega >= omega_min ) & ( omega <= omega_max ) try : electric_field = jax . vmap ( kwargs [ \"illumination\" ])( time_axis ) field_omega = _numerics . get_fourier_transform ( time_axis , electric_field , return_omega_axis = False ) return omega [ mask ], exp_val_omega [ mask ], field_omega [ mask ] except KeyError : return omega [ mask ], exp_val_omega [ mask ] @recomputes def get_density_matrix_time_domain ( self , end_time : float , illumination : Callable [[ float ], jax . Array ], start_time : Optional [ float ] = None , steps_time : Optional [ int ] = None , skip : Optional [ int ] = None , relaxation_rate : Union [ float , jax . Array ] = None , saturation_functional : Callable [[ float ], float ] = lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))), use_old_method : bool = False , include_induced_contribution : bool = False , use_rwa = False , compute_only_at = None , coulomb_strength = 1.0 , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), initial_density_matrix : Optional [ jax . Array ] = None , ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. initial_density_matrix (Union[jax.Array,None]): if given, used as initial density matrix instead Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float ( start_time ) if start_time is not None else 0.0 steps_time = int ( steps_time ) if steps_time is not None else int ( end_time * 1000 ) time_axis = jnp . linspace ( start_time , end_time , steps_time ) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None : relaxation_function = lambda r : 0.0 elif isinstance ( relaxation_rate , jax . Array ): relaxation_function = _numerics . lindblad_saturation_functional ( self . _eigenvectors , relaxation_rate , saturation_functional , self . electrons , self . _stationary_density_matrix , ) else : relaxation_function = _numerics . relaxation_time_approximation ( relaxation_rate , self . stationary_density_matrix , ) # Verify that illumination is a callable if not callable ( illumination ): raise TypeError ( \"Provide a function for e-field\" ) # Initialize common variables coulomb_field_to_from = _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_only_at ) initial_density_matrix = self . initial_density_matrix if initial_density_matrix is None else initial_density_matrix # TODO: not very elegant: we just dump every argument in there by default return time_axis [:: skip ], _numerics . integrate_master_equation ( self . _hamiltonian , coulomb_strength * self . _coulomb , self . dipole_operator , self . electrons , self . velocity_operator , initial_density_matrix , self . stationary_density_matrix , time_axis , illumination , relaxation_function , coulomb_field_to_from , include_induced_contribution , use_rwa , solver , stepsize_controller , use_old_method , skip , ) # TODO: decouple rpa numerics from orbital datataype def get_polarizability_rpa ( self , omegas , relaxation_rate , polarization , coulomb_strength = 1.0 , hungry = 0 , phi_ext = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics . rpa_polarizability_function ( self , relaxation_rate , polarization , coulomb_strength , phi_ext , hungry ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] ) def get_susceptibility_rpa ( self , omegas , relaxation_rate , coulomb_strength = 1.0 , hungry = 0 ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics . rpa_polarizability_function ( self , relaxation_rate , coulomb_strength , hungry ) return jax . lax . map ( sus , omegas ) dipole_operator property Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: \u2013 jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. quadrupole_operator property Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: \u2013 jax.Array: A tensor representing the quadrupole operator. transition_energies property Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition energy from i to j . velocity_operator property Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: \u2013 jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. wigner_weisskopf_transition_rates property Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition rate from i to j . append ( other ) Appends an orbital to the list, ensuring it is not already present. Parameters: other ( Orbital ) \u2013 The orbital to append. Raises: TypeError \u2013 If other is not an instance of Orbital. ValueError \u2013 If other is already in the list. Source code in src/granad/orbitals.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other ) get_charge ( density_matrix = None ) Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix ( Array , default: None ) \u2013 The density matrix to use for calculating charge. Returns: \u2013 jax.Array: A diagonal array representing charges at each site. Source code in src/granad/orbitals.py 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 @recomputes def get_charge ( density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None : return jnp . diag ( self . initial_density_matrix * self . electrons ) else : return jnp . diag ( density_matrix * self . electrons ) get_density_matrix_time_domain ( end_time , illumination , start_time = None , steps_time = None , skip = None , relaxation_rate = None , saturation_functional = lambda x : 1 / 1 + jnp . exp ( - 1000000.0 * 2.0 - x ), use_old_method = False , include_induced_contribution = False , use_rwa = False , compute_only_at = None , coulomb_strength = 1.0 , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), initial_density_matrix = None ) Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time ( float ) \u2013 The end time for the simulation. illumination ( Callable [[ float ], Array ] ) \u2013 A function that returns the electric field at a given time. start_time ( Optional [ float ] , default: None ) \u2013 The start time for the simulation, defaults to zero. steps_time ( Optional [ int ] , default: None ) \u2013 The number of time steps to simulate, defaults to int(end_time * 1000) skip ( Optional [ int ] , default: None ) \u2013 The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate ( Union [ float , Array ] , default: None ) \u2013 The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional ( Callable [[ float ], float ] , default: lambda x: 1 / 1 + exp (-1000000.0 * 2.0 - x ) ) \u2013 A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method ( bool , default: False ) \u2013 Flag to use the old RK method. include_induced_contribution ( bool , default: False ) \u2013 Whether to include induced contributions in the simulation. use_rwa ( bool , default: False ) \u2013 Whether to apply the rotating wave approximation. compute_only_at ( Optional [ any ] , default: None ) \u2013 Specific orbital indices at which the induced field computation is performed. coulomb_strength ( float , default: 1.0 ) \u2013 Strength of Coulomb interactions. solver ( Solver , default: Dopri5 () ) \u2013 The differential equation solver to use. stepsize_controller ( StepSizeController , default: PIDController (rtol=1e-10, atol=1e-10) ) \u2013 The controller for the solver's step size. initial_density_matrix ( Union [ Array , None] , default: None ) \u2013 if given, used as initial density matrix instead Returns: \u2013 Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. Source code in src/granad/orbitals.py 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 @recomputes def get_density_matrix_time_domain ( self , end_time : float , illumination : Callable [[ float ], jax . Array ], start_time : Optional [ float ] = None , steps_time : Optional [ int ] = None , skip : Optional [ int ] = None , relaxation_rate : Union [ float , jax . Array ] = None , saturation_functional : Callable [[ float ], float ] = lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))), use_old_method : bool = False , include_induced_contribution : bool = False , use_rwa = False , compute_only_at = None , coulomb_strength = 1.0 , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), initial_density_matrix : Optional [ jax . Array ] = None , ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. initial_density_matrix (Union[jax.Array,None]): if given, used as initial density matrix instead Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float ( start_time ) if start_time is not None else 0.0 steps_time = int ( steps_time ) if steps_time is not None else int ( end_time * 1000 ) time_axis = jnp . linspace ( start_time , end_time , steps_time ) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None : relaxation_function = lambda r : 0.0 elif isinstance ( relaxation_rate , jax . Array ): relaxation_function = _numerics . lindblad_saturation_functional ( self . _eigenvectors , relaxation_rate , saturation_functional , self . electrons , self . _stationary_density_matrix , ) else : relaxation_function = _numerics . relaxation_time_approximation ( relaxation_rate , self . stationary_density_matrix , ) # Verify that illumination is a callable if not callable ( illumination ): raise TypeError ( \"Provide a function for e-field\" ) # Initialize common variables coulomb_field_to_from = _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_only_at ) initial_density_matrix = self . initial_density_matrix if initial_density_matrix is None else initial_density_matrix # TODO: not very elegant: we just dump every argument in there by default return time_axis [:: skip ], _numerics . integrate_master_equation ( self . _hamiltonian , coulomb_strength * self . _coulomb , self . dipole_operator , self . electrons , self . velocity_operator , initial_density_matrix , self . stationary_density_matrix , time_axis , illumination , relaxation_function , coulomb_field_to_from , include_induced_contribution , use_rwa , solver , stepsize_controller , use_old_method , skip , ) get_dos ( omega , broadening = 0.1 ) Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the DOS. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The integrated density of states at the specified frequency. Source code in src/granad/orbitals.py 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians ) get_epi ( density_matrix_stat , omega , epsilon = None ) Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat ( Array ) \u2013 The density matrix to consider for EPI calculation. omega ( float ) \u2013 The frequency to evaluate the EPI at. epsilon ( float , default: None ) \u2013 The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float ( float ) \u2013 The EPI. Source code in src/granad/orbitals.py 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 @recomputes def get_epi ( self , density_matrix_stat : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = epsilon if epsilon is not None else self . eps density_matrix_stat_without_diagonal = jnp . abs ( density_matrix_stat - jnp . diag ( jnp . diag ( density_matrix_stat ))) density_matrix_stat_normalized = density_matrix_stat_without_diagonal / jnp . linalg . norm ( density_matrix_stat_without_diagonal ) te = self . transition_energies excitonic_transitions = ( density_matrix_stat_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * density_matrix_stat_normalized )) / ( jnp . linalg . norm ( density_matrix_stat_normalized ) * jnp . linalg . norm ( excitonic_transitions ) ) get_expectation_value ( * , operator , density_matrix , induced = True ) Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator ( Array ) \u2013 The operator for which the expectation value is calculated. density_matrix ( Array ) \u2013 The density matrix representing the state of the system. Returns: \u2013 jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. Source code in src/granad/orbitals.py 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 def get_expectation_value ( self , * , operator , density_matrix , induced = True ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->li\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } correction = self . stationary_density_matrix_x if induced == True else 0 return self . electrons * jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , correction - density_matrix , ) get_expectation_value_frequency_domain ( * args , ** kwargs ) Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: \u2013 Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. Source code in src/granad/orbitals.py 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 def get_expectation_value_frequency_domain ( self , * args , ** kwargs ): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" density_matrices = kwargs . pop ( \"density_matrices\" , None ) time_axis = kwargs . pop ( \"time\" , None ) omega_min = kwargs . pop ( \"omega_min\" , 0 ) omega_max = kwargs . pop ( \"omega_max\" , 100 ) if density_matrices is None : time_axis , exp_val_td = self . get_expectation_value_time_domain ( * args , ** kwargs ) else : operator = kwargs . pop ( \"operator\" , None ) exp_val_td = self . get_expectation_value ( density_matrix = density_matrices , operator = operator ) omega , exp_val_omega = _numerics . get_fourier_transform ( time_axis , exp_val_td ) mask = ( omega >= omega_min ) & ( omega <= omega_max ) try : electric_field = jax . vmap ( kwargs [ \"illumination\" ])( time_axis ) field_omega = _numerics . get_fourier_transform ( time_axis , electric_field , return_omega_axis = False ) return omega [ mask ], exp_val_omega [ mask ], field_omega [ mask ] except KeyError : return omega [ mask ], exp_val_omega [ mask ] get_expectation_value_time_domain ( * args , ** kwargs ) Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: \u2013 Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. Source code in src/granad/orbitals.py 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 def get_expectation_value_time_domain ( self , * args , ** kwargs ): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs . pop ( \"operator\" , None ) return_density = kwargs . pop ( \"return_density\" , False ) time_axis , density_matrices = self . get_density_matrix_time_domain ( * args , ** kwargs ) expectation_value = self . get_expectation_value ( density_matrix = density_matrices , operator = operator ) if return_density == True : return time_axis , expecation_value , density_matrices return time_axis , expectation_value get_group_ids () Retrieves a list of group IDs for all orbitals managed by this object. Returns: \u2013 List[int]: A list of group IDs for each orbital. Source code in src/granad/orbitals.py 457 458 459 460 461 462 463 464 def get_group_ids ( self ): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [ orb . group_id for orb in self . _list ] get_induced_field ( positions , density_matrix ) Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions ( Array ) \u2013 The positions at which to evaluate the induced field. density_matrix ( Array ) \u2013 The density matrix used to calculate the induced field. Returns: \u2013 jax.Array: The resulting electric field vector at each position. Source code in src/granad/orbitals.py 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . _positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field get_ldos ( omega , site_index , broadening = 0.1 ) Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the LDOS. site_index ( int ) \u2013 The site index to evaluate the LDOS at. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The local density of states at the specified site and frequency. Source code in src/granad/orbitals.py 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians ) get_polarizability_rpa ( omegas , relaxation_rate , polarization , coulomb_strength = 1.0 , hungry = 0 , phi_ext = None ) Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas ( Array ) \u2013 Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate ( float ) \u2013 The relaxation time parameter. polarization ( Array ) \u2013 Polarization directions or modes. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interaction in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext ( Optional [ Array ] , default: None ) \u2013 External potential influences, if any. Returns: \u2013 jax.Array: The calculated polarizabilities at the specified frequencies. Source code in src/granad/orbitals.py 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 def get_polarizability_rpa ( self , omegas , relaxation_rate , polarization , coulomb_strength = 1.0 , hungry = 0 , phi_ext = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics . rpa_polarizability_function ( self , relaxation_rate , polarization , coulomb_strength , phi_ext , hungry ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] ) get_susceptibility_rpa ( omegas , relaxation_rate , coulomb_strength = 1.0 , hungry = 0 ) Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas ( Array ) \u2013 The frequencies at which to compute susceptibility. relaxation_rate ( float ) \u2013 The relaxation time affecting susceptibility calculations. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interactions considered in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: \u2013 jax.Array: The susceptibility values at the given frequencies. Source code in src/granad/orbitals.py 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 def get_susceptibility_rpa ( self , omegas , relaxation_rate , coulomb_strength = 1.0 , hungry = 0 ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics . rpa_polarizability_function ( self , relaxation_rate , coulomb_strength , hungry ) return jax . lax . map ( sus , omegas ) get_unique_group_ids () Retrieves a unique set of group IDs from all orbitals. Returns: \u2013 List[int]: A list of unique group IDs. Source code in src/granad/orbitals.py 466 467 468 469 470 471 472 473 def get_unique_group_ids ( self ): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list ( set ( self . get_group_ids ())) make_self_consistent ( sc_params ) Configures the list for self-consistent field calculations. Parameters: sc_params ( dict ) \u2013 Parameters for self-consistency. Source code in src/granad/orbitals.py 597 598 599 600 601 602 603 604 605 @mutates def make_self_consistent ( self , sc_params ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self . self_consistency_params = sc_params set_coulomb_element ( orb_or_index1 , orb_or_index2 , val ) Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Coulomb interaction element. Source code in src/granad/orbitals.py 525 526 527 528 529 530 531 532 533 534 535 def set_coulomb_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _coulomb_dict ) set_dipole_transition ( orb_or_index1 , orb_or_index2 , arr ) Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first part of the transition. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second part of the transition. arr ( Array ) \u2013 The 3-element array containing dipole transition elements. Source code in src/granad/orbitals.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 @mutates def set_dipole_transition ( self , orb_or_index1 , orb_or_index2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _transitions_dict [( orb_or_index1 , orb_or_index2 )] = jnp . array ( arr ) . astype ( complex ) set_excitation ( from_state , to_state , excited_electrons ) Sets up an excitation process from one state to another with specified electrons. Parameters: from_state ( int, list, or jax.Array ) \u2013 The initial state index or indices. to_state ( int, list, or jax.Array ) \u2013 The final state index or indices. excited_electrons ( int, list, or jax.Array ) \u2013 The indices of electrons to be excited. Notes The states and electron indices may be specified as scalars, lists, or arrays. Source code in src/granad/orbitals.py 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): maybe_int = jnp . array ( maybe_int ) if isinstance ( maybe_int , jax . Array ): return ( jnp . array ( maybe_int ) if maybe_int . ndim > 1 else jnp . array ([ maybe_int ]) ) raise TypeError self . simulation_params . from_state = maybe_int_to_arr ( from_state ) self . simulation_params . to_state = maybe_int_to_arr ( to_state ) self . simulation_params . excited_electrons = maybe_int_to_arr ( excited_electrons ) set_groups_coulomb ( orb_or_group_id1 , orb_or_group_id2 , func ) Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the Coulomb interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def set_groups_coulomb ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _coulomb_dict ) set_groups_hopping ( orb_or_group_id1 , orb_or_group_id2 , func ) Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the hopping interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def set_groups_hopping ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _hopping_dict ) set_hamiltonian_element ( orb_or_index1 , orb_or_index2 , val ) Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Hamiltonian element. Source code in src/granad/orbitals.py 513 514 515 516 517 518 519 520 521 522 523 def set_hamiltonian_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _hopping_dict ) set_position ( tag , position ) Sets the position of all orbitals with a specific tag. Parameters: tag ( str ) \u2013 The tag to match orbitals. position ( Array ) \u2013 The vector at which to move the orbitals Notes This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 @mutates def set_position ( self , tag , position ): \"\"\" Sets the position of all orbitals with a specific tag. Parameters: tag (str): The tag to match orbitals. position (jax.Array): The vector at which to move the orbitals Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [ orb for orb in self . _list if orb . tag == tag ] for orb in orbs : orb . position = position shift_by_vector ( tag_or_group_id , translation_vector ) Shifts all orbitals with a specific tag by a given vector. Parameters: tag_or_group_id ( str or int or list [ int ] ) \u2013 The tag, group_id to match orbitals. translation_vector ( Array ) \u2013 The vector by which to translate the orbital positions. Notes This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 @mutates def shift_by_vector ( self , tag_or_group_id , translation_vector ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag_or_group_id (str or int or list[int]): The tag, group_id to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" if isinstance ( tag_or_group_id , str ): orbs = [ orb for orb in self . _list if orb . tag == tag_or_group_id ] elif isinstance ( tag_or_group_id , int ): orbs = [ orb for orb in self . _list if orb . group_id == tag_or_group_id ] else : orbs = [ orb for orb in self . _list if orb . group_id in tag_or_group_id ] for orb in orbs : orb . position += jnp . array ( translation_vector ) transform_to_energy_basis ( observable ) Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the energy basis. Source code in src/granad/orbitals.py 836 837 838 839 840 841 842 843 844 845 846 847 def transform_to_energy_basis ( self , observable ): # \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T ) transform_to_site_basis ( observable ) Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the site basis. Source code in src/granad/orbitals.py 824 825 826 827 828 829 830 831 832 833 834 def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors ) SimulationParams dataclass A data class for storing parameters necessary for running a simulation involving electronic states and transitions. Attributes: from_state ( Array ) \u2013 An array where each element is the index of an electronic state from which electrons are excited. Defaults to an array containing a single zero. to_state ( Array ) \u2013 An array where each element is the index of an electronic state to which electrons are excited. Defaults to an array containing a single zero. excited_electrons ( Array ) \u2013 An array where each element indicates the number of electrons excited between the corresponding states in from_state and to_state . Defaults to an array containing a single zero. eps ( float ) \u2013 Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5. beta ( float ) \u2013 Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to jax.numpy.inf by default, implying zero temperature. self_consistency_params ( dict ) \u2013 A dictionary to hold additional parameters required for self-consistency calculations within the simulation. Defaults to an empty dictionary. spin_degeneracy ( float ) \u2013 Factor to account for the degeneracy of spin states in the simulation. Typically set to 2, considering spin up and spin down. electrons ( Optional [ int ] ) \u2013 The total number of electrons in the structure. If not provided, it is assumed that the system's electron number needs to be calculated or is managed elsewhere. Note This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state of OrbitalList. Source code in src/granad/orbitals.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @dataclass class SimulationParams : \"\"\" A data class for storing parameters necessary for running a simulation involving electronic states and transitions. Attributes: from_state (jax.Array): An array where each element is the index of an electronic state from which electrons are excited. Defaults to an array containing a single zero. to_state (jax.Array): An array where each element is the index of an electronic state to which electrons are excited. Defaults to an array containing a single zero. excited_electrons (jax.Array): An array where each element indicates the number of electrons excited between the corresponding states in `from_state` and `to_state`. Defaults to an array containing a single zero. eps (float): Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5. beta (float): Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to `jax.numpy.inf` by default, implying zero temperature. self_consistency_params (dict): A dictionary to hold additional parameters required for self-consistency calculations within the simulation. Defaults to an empty dictionary. spin_degeneracy (float): Factor to account for the degeneracy of spin states in the simulation. Typically set to 2, considering spin up and spin down. electrons (Optional[int]): The total number of electrons in the structure. If not provided, it is assumed that the system's electron number needs to be calculated or is managed elsewhere. Note: This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state of OrbitalList. \"\"\" from_state : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 ])) to_state : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 ])) excited_electrons : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 ])) eps : float = 1e-5 beta : float = jnp . inf self_consistency_params : dict = field ( default_factory = dict ) spin_degeneracy : float = 2.0 electrons : Optional [ int ] = None Pulse ( amplitudes , frequency , peak , fwhm ) Function for computing temporally located time-harmonics electric fields. The pulse is implemented as a temporal Gaussian. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency of the electric field - `peak`: time where the pulse reaches its peak - `fwhm`: full width at half maximum Returns: Function that computes the electric field Source code in src/granad/fields.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def Pulse ( amplitudes : list [ float ], frequency : float , peak : float , fwhm : float , ): \"\"\"Function for computing temporally located time-harmonics electric fields. The pulse is implemented as a temporal Gaussian. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency of the electric field - `peak`: time where the pulse reaches its peak - `fwhm`: full width at half maximum **Returns:** Function that computes the electric field \"\"\" static_part = jnp . array ( amplitudes ) sigma = fwhm / ( 2.0 * jnp . sqrt ( jnp . log ( 2 ))) return lambda t : ( static_part * jnp . exp ( - 1 j * jnp . pi / 2 + 1 j * frequency * ( t - peak )) * jnp . exp ( - (( t - peak ) ** 2 ) / sigma ** 2 ) ) Ramp ( amplitudes , frequency , ramp_duration , time_ramp ) Function for computing ramping up time-harmonic electric fields. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency - `ramp_duration`: specifies how long does the electric field ramps up - `time_ramp`: specifies time at which the field starts to ramp up Returns: Function that computes the electric field as a functon of time Source code in src/granad/fields.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def Ramp ( amplitudes : list [ float ], frequency : float , ramp_duration : float , time_ramp : float , ): \"\"\"Function for computing ramping up time-harmonic electric fields. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency - `ramp_duration`: specifies how long does the electric field ramps up - `time_ramp`: specifies time at which the field starts to ramp up **Returns:** Function that computes the electric field as a functon of time \"\"\" static_part = jnp . array ( amplitudes ) p = 0.99 ramp_constant = 2 * jnp . log ( p / ( 1 - p )) / ramp_duration return lambda t : ( static_part * jnp . exp ( 1 j * frequency * t ) / ( 1 + 1.0 * jnp . exp ( - ramp_constant * ( t - time_ramp ))) ) Wave ( amplitudes , frequency ) Function for computing time-harmonic electric fields. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency Returns: Function that computes the electric field as a functon of time Source code in src/granad/fields.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def Wave ( amplitudes : list [ float ], frequency : float , ): \"\"\"Function for computing time-harmonic electric fields. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency **Returns:** Function that computes the electric field as a functon of time \"\"\" static_part = jnp . array ( amplitudes ) return lambda t : ( jnp . exp ( 1 j * frequency * t ) * static_part ) Material Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name ( str ) \u2013 The name of the material. species ( dict ) \u2013 Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals ( defaultdict [ list ] ) \u2013 A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions ( defaultdict [ dict ] ) \u2013 Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hopping', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Usage The Material class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hopping and Coulomb interactions among these orbitals. Example graphene = ( Material(\"graphene\") .lattice_constant(2.46) .lattice_basis([ [1, 0, 0], [-0.5, jnp.sqrt(3)/2, 0] ]) .add_orbital_species(\"pz\", l=1, atom='C') .add_orbital(position=(0, 0), tag=\"sublattice_1\", species=\"pz\") .add_orbital(position=(-1/3, -2/3), tag=\"sublattice_2\", species=\"pz\") .add_interaction( \"hopping\", participants=(\"pz\", \"pz\"), parameters=[0.0, 2.66], # no expression given => we online look at onsite and nearest neighbors ) .add_interaction( \"coulomb\", participants=(\"pz\", \"pz\"), parameters=[16.522, 8.64, 5.333], # we look at onsite, nn, nnn couplings expression=lambda d: 14.399 / d # for nnnn and more, we apply the coulomb law ) ) Source code in src/granad/materials.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 class Material : \"\"\" Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name (str): The name of the material. species (dict): Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals (defaultdict[list]): A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions (defaultdict[dict]): Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hopping', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Usage: The `Material` class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hopping and Coulomb interactions among these orbitals. Example: graphene = ( Material(\"graphene\") .lattice_constant(2.46) .lattice_basis([ [1, 0, 0], [-0.5, jnp.sqrt(3)/2, 0] ]) .add_orbital_species(\"pz\", l=1, atom='C') .add_orbital(position=(0, 0), tag=\"sublattice_1\", species=\"pz\") .add_orbital(position=(-1/3, -2/3), tag=\"sublattice_2\", species=\"pz\") .add_interaction( \"hopping\", participants=(\"pz\", \"pz\"), parameters=[0.0, 2.66], # no expression given => we online look at onsite and nearest neighbors ) .add_interaction( \"coulomb\", participants=(\"pz\", \"pz\"), parameters=[16.522, 8.64, 5.333], # we look at onsite, nn, nnn couplings expression=lambda d: 14.399 / d # for nnnn and more, we apply the coulomb law ) ) \"\"\" def __init__ ( self , name ): self . name = name self . species = {} self . orbitals = defaultdict ( list ) self . interactions = defaultdict ( dict ) self . _species_to_groups = {} self . dim = None def __str__ ( self ): description = f \"Material: { self . name } \\n \" if self . lattice_constant : description += f \" Lattice Constant: { self . lattice_constant } \u00c5 \\n \" if self . lattice_basis : description += f \" Lattice Basis: { self . _lattice_basis } \\n \" if self . species : description += \" Orbital Species: \\n \" for species_name , attributes in self . species . items (): description += f \" { species_name } characterized by (n,l,m,s, atom name) = { attributes } \\n \" if self . orbitals : description += \" Orbitals: \\n \" for spec , orbs in self . orbitals . items (): for orb in orbs : description += f \" Position: { orb [ 'position' ] } , Tag: { orb [ 'tag' ] } , Species: { spec } \\n \" if self . interactions : description += \" Interactions: \\n \" for type_ , interaction in self . interactions . items (): for participants , coupling in interaction . items (): description += f \" Type: { type_ } , Participants: { participants } , Couplings (neighbor, function): { coupling } \\n \" return description def lattice_constant ( self , value ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . lattice_constant = value return self def lattice_basis ( self , values , periodic = None ): \"\"\" Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values (list of list of float): A list of vectors representing the lattice basis. periodic (list of int, optional): Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material: Returns self to enable method chaining. \"\"\" self . _lattice_basis = jnp . array ( values ) total = set ( range ( len ( self . _lattice_basis ))) periodic = set ( periodic ) if periodic is not None else total self . periodic = list ( periodic ) self . finite = list ( total - periodic ) self . dim = len ( self . periodic ) return self @_finalize def cut_flake ( self ): \"\"\" Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. \"\"\" pass def add_orbital ( self , position , species , tag = '' ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . orbitals [ species ] . append ({ 'position' : position , 'tag' : tag }) return self def add_orbital_species ( self , name , n = 0 , l = 0 , m = 0 , s = 0 , atom = '' ): \"\"\" Adds a species definition for orbitals in the material. Parameters: name (str): The name of the orbital species. n (int): Principal quantum number. l (int): Orbital angular momentum quantum number. m (int): Magnetic quantum number. s (int): Spin quantum number. atom (str, optional): Name of the atom the orbital belongs to. Returns: Material: Returns self to enable method chaining. \"\"\" self . species [ name ] = ( n , l , m , s , atom ) return self def add_interaction ( self , interaction_type , participants , parameters , expression = lambda x : 0 j ): \"\"\" Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type (str): The type of interaction (e.g., 'hopping', 'Coulomb'). participants (tuple): A tuple identifying the participants in the interaction. parameters (dict): Parameters relevant to the interaction. expression (function): A function defining the mathematical form of the interaction. Returns: Material: Returns self to enable method chaining. \"\"\" self . interactions [ interaction_type ][ participants ] = ( parameters , lambda x : expression ( x ) + 0 j ) return self def _get_positions_in_uc ( self , species = None ): if species is None : return jnp . array ( [ x [ \"position\" ] for orb in list ( self . orbitals . values ()) for x in orb ] ) else : return jnp . array ( [ orb_group [ 'position' ] for s in species for orb_group in self . orbitals [ s ] ] ) def _get_positions_in_lattice ( self , uc_positions , grid ): shift = jnp . array ( uc_positions ) @ self . _lattice_basis return self . lattice_constant * ( grid @ self . _lattice_basis + shift [:, None , :] ) . reshape ( shift . shape [ 0 ] * grid . shape [ 0 ], 3 ) def _get_grid ( self , ns ): grid = [( 1 ,) for i in range ( len ( self . finite ) + len ( self . periodic )) ] for i , p in enumerate ( self . periodic ): grid [ p ] = range ( * ns [ i ]) return jnp . array ( list ( product ( * ( x for x in grid ) ) ) ) def _keep_matching_positions ( self , positions , candidates ): idxs = ( jnp . round ( jnp . linalg . norm ( positions - candidates [:, None ], axis =- 1 ), 4 ) == 0 ) . nonzero ()[ 0 ] return candidates [ idxs ] def _couplings_to_function ( self , couplings , outside_fun , species ): couplings = jnp . array ( couplings ) + 0.0 j grid = self . _get_grid ( [ ( 0 , len ( couplings )) for i in range ( self . dim ) ] ) fractional_positions = self . _get_positions_in_uc ( species ) positions = self . _get_positions_in_lattice ( fractional_positions , grid ) distances = jnp . unique ( jnp . round ( jnp . linalg . norm ( positions - positions [:, None , :], axis = 2 ), 8 ) )[: len ( couplings )] def inner ( d ): return jax . lax . cond ( jnp . min ( jnp . abs ( d - distances )) < 1e-5 , lambda x : couplings [ jnp . argmin ( jnp . abs ( x - distances ))], outside_fun , d , ) return inner def _set_couplings ( self , setter_func , interaction_type ): interaction_dict = self . interactions [ interaction_type ] for ( species_1 , species_2 ), couplings in interaction_dict . items (): distance_func = self . _couplings_to_function ( * couplings , ( species_1 , species_2 ) ) setter_func ( self . _species_to_groups [ species_1 ], self . _species_to_groups [ species_2 ], distance_func ) def _get_orbital_list ( self , allowed_positions , grid ): raw_list , layer_index = [], 0 for species , orb_group in self . orbitals . items (): for orb_uc in orb_group : uc_positions = jnp . array ( [ orb_uc [ 'position' ]] ) rs_positions = self . _get_positions_in_lattice ( uc_positions , grid ) final_positions = self . _keep_matching_positions ( allowed_positions , rs_positions ) for position in final_positions : orb = Orbital ( position = position , layer_index = layer_index , tag = orb_uc [ 'tag' ], group_id = self . _species_to_groups [ species ], energy_level = self . species [ species ][ 0 ], angular_momentum = self . species [ species ][ 1 ], angular_momentum_z = self . species [ species ][ 2 ], spin = self . species [ species ][ 3 ], atom_name = self . species [ species ][ 4 ] ) layer_index += 1 raw_list . append ( orb ) orbital_list = OrbitalList ( raw_list ) self . _set_couplings ( orbital_list . set_groups_hopping , \"hopping\" ) self . _set_couplings ( orbital_list . set_groups_coulomb , \"coulomb\" ) return orbital_list add_interaction ( interaction_type , participants , parameters , expression = lambda x : 0 j ) Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type ( str ) \u2013 The type of interaction (e.g., 'hopping', 'Coulomb'). participants ( tuple ) \u2013 A tuple identifying the participants in the interaction. parameters ( dict ) \u2013 Parameters relevant to the interaction. expression ( function , default: lambda x: 0j ) \u2013 A function defining the mathematical form of the interaction. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def add_interaction ( self , interaction_type , participants , parameters , expression = lambda x : 0 j ): \"\"\" Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type (str): The type of interaction (e.g., 'hopping', 'Coulomb'). participants (tuple): A tuple identifying the participants in the interaction. parameters (dict): Parameters relevant to the interaction. expression (function): A function defining the mathematical form of the interaction. Returns: Material: Returns self to enable method chaining. \"\"\" self . interactions [ interaction_type ][ participants ] = ( parameters , lambda x : expression ( x ) + 0 j ) return self add_orbital ( position , species , tag = '' ) Sets the lattice constant for the material. Parameters: value ( float ) \u2013 The lattice constant value. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 315 316 317 318 319 320 321 322 323 324 325 326 def add_orbital ( self , position , species , tag = '' ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . orbitals [ species ] . append ({ 'position' : position , 'tag' : tag }) return self add_orbital_species ( name , n = 0 , l = 0 , m = 0 , s = 0 , atom = '' ) Adds a species definition for orbitals in the material. Parameters: name ( str ) \u2013 The name of the orbital species. n ( int , default: 0 ) \u2013 Principal quantum number. l ( int , default: 0 ) \u2013 Orbital angular momentum quantum number. m ( int , default: 0 ) \u2013 Magnetic quantum number. s ( int , default: 0 ) \u2013 Spin quantum number. atom ( str , default: '' ) \u2013 Name of the atom the orbital belongs to. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 def add_orbital_species ( self , name , n = 0 , l = 0 , m = 0 , s = 0 , atom = '' ): \"\"\" Adds a species definition for orbitals in the material. Parameters: name (str): The name of the orbital species. n (int): Principal quantum number. l (int): Orbital angular momentum quantum number. m (int): Magnetic quantum number. s (int): Spin quantum number. atom (str, optional): Name of the atom the orbital belongs to. Returns: Material: Returns self to enable method chaining. \"\"\" self . species [ name ] = ( n , l , m , s , atom ) return self cut_flake () Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. Source code in src/granad/materials.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 @_finalize def cut_flake ( self ): \"\"\" Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. \"\"\" pass lattice_basis ( values , periodic = None ) Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values ( list of list of float ) \u2013 A list of vectors representing the lattice basis. periodic ( list of int , default: None ) \u2013 Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def lattice_basis ( self , values , periodic = None ): \"\"\" Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values (list of list of float): A list of vectors representing the lattice basis. periodic (list of int, optional): Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material: Returns self to enable method chaining. \"\"\" self . _lattice_basis = jnp . array ( values ) total = set ( range ( len ( self . _lattice_basis ))) periodic = set ( periodic ) if periodic is not None else total self . periodic = list ( periodic ) self . finite = list ( total - periodic ) self . dim = len ( self . periodic ) return self lattice_constant ( value ) Sets the lattice constant for the material. Parameters: value ( float ) \u2013 The lattice constant value. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 263 264 265 266 267 268 269 270 271 272 273 274 def lattice_constant ( self , value ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . lattice_constant = value return self cut_flake_1d ( material , unit_cells , plot = False ) Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. unit_cells ( int ) \u2013 The number of unit cells to include in the flake. plot ( bool , default: False ) \u2013 If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list \u2013 A list of orbitals positioned within the specified range of the material's lattice. Note The function utilizes internal methods of the Material class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. Source code in src/granad/materials.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def cut_flake_1d ( material , unit_cells , plot = False ): \"\"\" Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material (Material): The material instance from which to cut the flake. unit_cells (int): The number of unit cells to include in the flake. plot (bool, optional): If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list: A list of orbitals positioned within the specified range of the material's lattice. Note: The function utilizes internal methods of the `Material` class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. \"\"\" orbital_positions_uc = material . _get_positions_in_uc () grid = material . _get_grid ( [( 0 , unit_cells )] ) orbital_positions = material . _get_positions_in_lattice ( orbital_positions_uc , grid ) if plot : _display_lattice_cut ( orbital_positions , orbital_positions ) orbital_positions = jnp . unique ( orbital_positions , axis = 0 ) return material . _get_orbital_list ( orbital_positions , grid ) cut_flake_2d ( material , polygon , plot = False , minimum_neighbor_number = 2 ) Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. polygon ( array - like ) \u2013 An array of coordinates defining the vertices of the polygon within which to cut the flake. plot ( bool , default: False ) \u2013 If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number ( int , default: 2 ) \u2013 The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list \u2013 A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Details The function first translates the polygon into the positive xy-plane to avoid negative coordinates, then calculates the extent of the grid needed to cover the polygon based on the material's lattice basis. Atom positions are then pruned based on the minimum neighbor count using the _prune_neighbors nested function, which iteratively prunes atoms until the neighbor count condition is met or no further pruning can be done. Source code in src/granad/materials.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def cut_flake_2d ( material , polygon , plot = False , minimum_neighbor_number : int = 2 ): \"\"\" Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material (Material): The material instance from which to cut the flake. polygon (array-like): An array of coordinates defining the vertices of the polygon within which to cut the flake. plot (bool, optional): If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number (int, optional): The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list: A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Details: The function first translates the polygon into the positive xy-plane to avoid negative coordinates, then calculates the extent of the grid needed to cover the polygon based on the material's lattice basis. Atom positions are then pruned based on the minimum neighbor count using the `_prune_neighbors` nested function, which iteratively prunes atoms until the neighbor count condition is met or no further pruning can be done. \"\"\" def _prune_neighbors ( positions , minimum_neighbor_number , remaining_old = jnp . inf ): \"\"\" Recursively prunes positions to ensure each position has a sufficient number of neighboring positions based on a minimum distance calculated from the unique set of distances between positions. Parameters: positions (array-like): Array of positions to prune. minimum_neighbor_number (int): Minimum required number of neighbors for a position to be retained. remaining_old (int): The count of positions remaining from the previous iteration; used to detect convergence. Returns: array-like: Array of positions that meet the neighbor count criterion. \"\"\" if minimum_neighbor_number <= 0 : return positions distances = jnp . round ( jnp . linalg . norm ( positions - positions [:, None ], axis =- 1 ), 4 ) minimum = jnp . unique ( distances )[ 1 ] mask = ( distances <= minimum ) . sum ( axis = 0 ) > minimum_neighbor_number remaining = mask . sum () if remaining_old == remaining : return positions [ mask ] else : return _prune_neighbors ( positions [ mask ], minimum_neighbor_number , remaining ) # shift the polygon into the positive xy plane min_values = jnp . min ( polygon , axis = 0 ) translation = jnp . where ( min_values < 0 , - min_values , 0 ) polygon += translation # we compute the maximum extension of the polyon max_values = jnp . max ( polygon , axis = 0 ) max_dim = max_values . argmax () max_vec = jnp . abs ( material . _lattice_basis )[ material . periodic , max_dim ] . argmax () n = max_values [ max_dim ] / material . _lattice_basis [ material . periodic ,:][ max_vec , max_dim ] . item () / 2 n_rounded = jnp . ceil ( jnp . abs ( n )) + 1 n = int ( jnp . sign ( n ) * n_rounded ) grid = material . _get_grid ( [ ( 0 , n ), ( 0 , n ) ] ) # get atom positions in the unit cell in fractional coordinates orbital_positions = material . _get_positions_in_uc () unit_cell_fractional_atom_positions = jnp . unique ( jnp . round ( orbital_positions , 6 ), axis = 0 ) # get all atom positions in a plane completely covering the polygon initial_atom_positions = material . _get_positions_in_lattice ( unit_cell_fractional_atom_positions , grid ) # get atom positions within the polygon polygon_path = Path ( polygon ) flags = polygon_path . contains_points ( initial_atom_positions [:, : 2 ]) # get atom positions where every atom has at least minimum_neighbor_number neighbors final_atom_positions = _prune_neighbors ( initial_atom_positions [ flags ], minimum_neighbor_number ) if plot == True : _display_lattice_cut ( initial_atom_positions , final_atom_positions , polygon ) return material . _get_orbital_list ( final_atom_positions , grid ) cut_flake_generic ( material , grid_range ) Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. grid_range ( list of tuples ) \u2013 Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list \u2013 A list of orbitals within the specified grid range, uniquely positioned. Note The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. Source code in src/granad/materials.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def cut_flake_generic ( material , grid_range ): \"\"\" Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material (Material): The material instance from which to cut the flake. grid_range (list of tuples): Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list: A list of orbitals within the specified grid range, uniquely positioned. Note: The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. \"\"\" orbital_positions_uc = material . _get_positions_in_uc () grid = material . _get_grid ( grid_range ) orbital_positions = material . _get_positions_in_lattice ( orbital_positions_uc , grid ) orbital_positions = jnp . unique ( orbital_positions , axis = 0 ) return material . _get_orbital_list ( orbital_positions , grid ) Hexagon ( length ) Generates the vertices of a regular hexagon given the side length. The hexagon is oriented such that one vertex points upwards and the function is designed to be used with the @_edge_type decorator for positional adjustments and rotations. Parameters: length ( float ) \u2013 The length of each side of the hexagon, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (7, 2), representing the vertices of the hexagon, including the starting vertex repeated at the end for drawing closed shapes. Example Hexagon with side length of 1.0 angstrom hexagon = Hexagon(1.0) Source code in src/granad/shapes.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @_edge_type def Hexagon ( length ): \"\"\" Generates the vertices of a regular hexagon given the side length. The hexagon is oriented such that one vertex points upwards and the function is designed to be used with the @_edge_type decorator for positional adjustments and rotations. Parameters: length (float): The length of each side of the hexagon, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (7, 2), representing the vertices of the hexagon, including the starting vertex repeated at the end for drawing closed shapes. Example: # Hexagon with side length of 1.0 angstrom hexagon = Hexagon(1.0) \"\"\" n = 6 s = 1 angle = 2 * jnp . pi / n vertices = length * jnp . array ( [ ( s * jnp . cos ( i * angle ), s * jnp . sin ( i * angle )) for i in [ x for x in range ( n )] + [ 0 ] ] ) return vertices Rectangle ( length_x , length_y ) Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x ( float ) \u2013 The length of the rectangle along the x-axis, specified in angstroms. length_y ( float ) \u2013 The length of the rectangle along the y-axis, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Example Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle(2.0, 1.0) Source code in src/granad/shapes.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @_edge_type def Rectangle ( length_x , length_y ): \"\"\" Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x (float): The length of the rectangle along the x-axis, specified in angstroms. length_y (float): The length of the rectangle along the y-axis, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Example: # Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle(2.0, 1.0) \"\"\" vertices = jnp . array ( [ ( - 1 * length_x , - 0.5 * length_y ), ( 1 * length_x , - 0.5 * length_y ), ( 1 * length_x , 0.5 * length_y ), ( - 1 * length_x , 0.5 * length_y ), ( - 1 * length_x , - 0.5 * length_y ), ] ) return vertices Rhomboid ( base , height ) Generates the vertices of a rhomboid given the base length and height. The rhomboid is initially oriented with the base along the x-axis, and one angle being 30 degrees, designed to be adjusted for position and orientation using the @_edge_type decorator. Parameters: base ( float ) \u2013 The length of the base of the rhomboid, specified in angstroms. height ( float ) \u2013 The vertical height of the rhomboid, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rhomboid, starting and ending at the same vertex to complete the shape. Example Rhomboid with base 2.0 angstroms and height 1.0 angstrom rhomboid = Rhomboid(2.0, 1.0) Source code in src/granad/shapes.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 @_edge_type def Rhomboid ( base , height ): \"\"\" Generates the vertices of a rhomboid given the base length and height. The rhomboid is initially oriented with the base along the x-axis, and one angle being 30 degrees, designed to be adjusted for position and orientation using the @_edge_type decorator. Parameters: base (float): The length of the base of the rhomboid, specified in angstroms. height (float): The vertical height of the rhomboid, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rhomboid, starting and ending at the same vertex to complete the shape. Example: # Rhomboid with base 2.0 angstroms and height 1.0 angstrom rhomboid = Rhomboid(2.0, 1.0) \"\"\" angle = jnp . radians ( 30 ) vertices = jnp . array ( [ ( 0 , 0 ), ( base , 0 ), ( base + height * jnp . sin ( angle ), height * jnp . cos ( angle )), ( height * jnp . sin ( angle ), height * jnp . cos ( angle )), ( 0 , 0 ), ] ) return vertices Triangle ( side_length ) Generates the vertices of an equilateral triangle given the side length. The triangle is oriented such that one vertex points upwards and the base is horizontal. This function is designed to be used with the @_edge_type decorator, which adds functionality to shift the triangle's position or rotate it based on additional 'shift' and 'armchair' parameters passed to the function. Parameters: side_length ( float ) \u2013 The length of each side of the triangle, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (4, 2), representing the vertices of the triangle, including the starting vertex repeated at the end to facilitate drawing closed shapes. Example Create a triangle with side length of 1.0 angstrom, no shift or rotation triangle = Triangle(1.0) Create a triangle with side length of 1.0 angstrom, shifted by [1, 1] units triangle_shifted = Triangle(1.0, shift=[1, 1]) Create a triangle with side length of 1.0 angstrom, rotated by 90 degrees (armchair orientation) triangle_rotated = Triangle(1.0, armchair=True) Source code in src/granad/shapes.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 @_edge_type def Triangle ( side_length ): \"\"\" Generates the vertices of an equilateral triangle given the side length. The triangle is oriented such that one vertex points upwards and the base is horizontal. This function is designed to be used with the @_edge_type decorator, which adds functionality to shift the triangle's position or rotate it based on additional 'shift' and 'armchair' parameters passed to the function. Parameters: side_length (float): The length of each side of the triangle, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (4, 2), representing the vertices of the triangle, including the starting vertex repeated at the end to facilitate drawing closed shapes. Example: # Create a triangle with side length of 1.0 angstrom, no shift or rotation triangle = Triangle(1.0) # Create a triangle with side length of 1.0 angstrom, shifted by [1, 1] units triangle_shifted = Triangle(1.0, shift=[1, 1]) # Create a triangle with side length of 1.0 angstrom, rotated by 90 degrees (armchair orientation) triangle_rotated = Triangle(1.0, armchair=True) \"\"\" vertices = side_length * jnp . array ( [ ( 0 , jnp . sqrt ( 3 ) / 3 ), ( - 0.5 , - jnp . sqrt ( 3 ) / 6 ), ( 0.5 , - jnp . sqrt ( 3 ) / 6 ), ( 0 , jnp . sqrt ( 3 ) / 3 ), ] ) return vertices","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#granad.orbitals.Orbital","text":"Represents the quantum state of an electron in an atom with specific properties. Attributes: position ( Array ) \u2013 The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index ( Optional [ int ] ) \u2013 An optional index representing the layer of the orbital within its atom, may be None if not specified. tag ( Optional [ str ] ) \u2013 An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level ( Optional [ int ] ) \u2013 The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum ( Optional [ int ] ) \u2013 The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z ( Optional [ int ] ) \u2013 The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin ( Optional [ int ] ) \u2013 The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name ( Optional [ str ] ) \u2013 The name of the atom this orbital belongs to, can be None if not applicable. group_id ( int ) \u2013 A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. For example, all pz orbitals in a single graphene flake get the same group_id. Key Functionality The most important attributes of an orbtial are group_id (automatically generated, not recommended to be set it by the user) tag (user-defined or predefined for existing materials) Source code in src/granad/orbitals.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @dataclass class Orbital : \"\"\" Represents the quantum state of an electron in an atom with specific properties. Attributes: position (jax.Array): The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom, may be None if not specified. tag (Optional[str]): An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable. group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. For example, all pz orbitals in a single graphene flake get the same group_id. Key Functionality: The most important attributes of an orbtial are group_id (automatically generated, not recommended to be set it by the user) tag (user-defined or predefined for existing materials) \"\"\" position : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 , 0 , 0 ]), hash = False , compare = False ) layer_index : Optional [ int ] = None tag : Optional [ str ] = None energy_level : Optional [ int ] = None angular_momentum : Optional [ int ] = None angular_momentum_z : Optional [ int ] = None spin : Optional [ int ] = None atom_name : Optional [ str ] = None group_id : int = field ( default_factory = _watchdog . _Watchdog . next_value ) def __post_init__ ( self ): object . __setattr__ ( self , \"position\" , jnp . array ( self . position ) . astype ( float )) def __hash__ ( self ): # Include only immutable fields in hash calculation return hash ( ( self . layer_index , self . tag , self . energy_level , self . angular_momentum , self . angular_momentum_z , self . angular_momentum , self . spin , self . atom_name , self . group_id , ) ) def __str__ ( self ): return pformat ( vars ( self ), sort_dicts = False ) def __eq__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id == other . group_id and self . layer_index == other . layer_index def __lt__ ( self , other ): if not isinstance ( other , Orbital ): return NotImplemented return self . group_id < self . group_id def __le__ ( self , other ): return self < other or self == other def __gt__ ( self , other ): return not self <= other def __ge__ ( self , other ): return not self < other def __ne__ ( self , other ): return not self == other","title":"Orbital"},{"location":"api/#granad.orbitals.OrbitalList","text":"A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list, while also maintaining additional functionalities for coupling orbitals and managing their relationships. The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries, where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float or a function representing the coupling strength or mechanism between the orbitals). The class also stores simulation parameters like the number of electrons and temperature in a dataclass. The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so quantity_x == quantity. The class exposes simulation methods. Attributes: orbitals ( list ) \u2013 The underlying list that stores the orbitals. couplings ( dict ) \u2013 A dictionary where keys are tuples of orbital identifiers and values are the couplings (either float values or functions). Key Functionalities Orbital Identification : Orbitals can be identified either by their group_id, a direct reference to the orbital object itself, or via a user-defined tag. Index Access : Orbitals can be accessed and managed by their index in the list, allowing for list-like manipulation (addition, removal, access). Coupling Definition : Allows for the definition and adjustment of couplings between pairs of orbitals, identified by a tuple of their respective identifiers. These couplings can dynamically represent the interaction strength or be a computational function that defines the interaction. Note The coupling values can be dynamically modified. When two orbital lists are added, their couplings are merged, and their simulation parameters are wiped. Source code in src/granad/orbitals.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 @plotting_methods class OrbitalList : \"\"\" A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list, while also maintaining additional functionalities for coupling orbitals and managing their relationships. The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries, where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float or a function representing the coupling strength or mechanism between the orbitals). The class also stores simulation parameters like the number of electrons and temperature in a dataclass. The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so quantity_x == quantity. The class exposes simulation methods. Attributes: orbitals (list): The underlying list that stores the orbitals. couplings (dict): A dictionary where keys are tuples of orbital identifiers and values are the couplings (either float values or functions). Key Functionalities: - **Orbital Identification**: Orbitals can be identified either by their group_id, a direct reference to the orbital object itself, or via a user-defined tag. - **Index Access**: Orbitals can be accessed and managed by their index in the list, allowing for list-like manipulation (addition, removal, access). - **Coupling Definition**: Allows for the definition and adjustment of couplings between pairs of orbitals, identified by a tuple of their respective identifiers. These couplings can dynamically represent the interaction strength or be a computational function that defines the interaction. Note: The coupling values can be dynamically modified. When two orbital lists are added, their couplings are merged, and their simulation parameters are wiped. \"\"\" def __init__ ( self , orbs , _hopping_dict = None , _coulomb_dict = None , _transitions_dict = None ): # couplings are dicts mapping orbital pairs to couplings self . _hopping_dict = ( _hopping_dict if _hopping_dict is not None else _SortedTupleDict () ) self . _coulomb_dict = ( _coulomb_dict if _coulomb_dict is not None else _SortedTupleDict () ) self . _transitions_dict = _transitions_dict if _transitions_dict is not None else _SortedTupleDict () # contains all high-level simulation information self . _list = list ( orbs ) if orbs is not None else [] # flag for recomputing state self . _recompute = True self . simulation_params = SimulationParams () def __getattr__ ( self , property_name ): if property_name . endswith ( \"_x\" ): return getattr ( self , property_name [: - 2 ]) elif property_name . endswith ( \"_e\" ): return self . transform_to_energy_basis ( getattr ( self , property_name [: - 2 ]) ) def __len__ ( self ): return len ( self . _list ) # can't mutate, because orbitals are immutable def __getitem__ ( self , position ): return self . _list [ position ] def __repr__ ( self ): return repr ( self . _list ) def __str__ ( self ): info = f \"List with { len ( self ) } orbitals, { self . electrons } electrons.\" excited = f \" { self . excited_electrons } electrons excited from { self . from_state } to { self . to_state } .\" groups = \" \\n \" . join ( [ f \"group id { key } : { val } orbitals\" for key , val in Counter ( self . get_group_ids ()) . items () ] ) return \" \\n \" . join (( info , excited , groups )) def __iter__ ( self ): return iter ( self . _list ) def __add__ ( self , other ): if not self . _are_orbs ( other ): raise TypeError if any ( orb in other for orb in self . _list ): raise ValueError if isinstance ( other , OrbitalList ): new_hopping_dict = self . _hopping_dict . copy () new_hopping_dict . update ( other . _hopping_dict ) new_coulomb_dict = self . _coulomb_dict . copy () new_coulomb_dict . update ( other . _coulomb_dict ) new_transitions_dict = self . _transitions_dict . copy () new_transitions_dict . update ( other . _transitions_dict ) return OrbitalList ( ( self . _list + list ( other )) . copy (), _SortedTupleDict ( new_hopping_dict ), _SortedTupleDict ( new_coulomb_dict ), _SortedTupleDict ( new_transitions_dict ), ) @mutates def __setitem__ ( self , position , value ): if isinstance ( value , Orbital ): self . _list [ position ] = value raise TypeError def _delete_coupling ( self , orb , coupling ): keys_to_remove = [ key for key in coupling if orb in key ] for key in keys_to_remove : del coupling [ key ] @mutates def __delitem__ ( self , position ): orb = self . _list [ position ] self . _delete_coupling ( orb , self . _hopping_dict ) self . _delete_coupling ( orb , self . _coulomb_dict ) del self . _list [ position ] @staticmethod def _are_orbs ( candidate ): return all ( isinstance ( orb , Orbital ) for orb in candidate ) @mutates def _set_coupling ( self , orb_or_group_id1 , orb_or_group_id2 , val_or_func , coupling ): coupling [( orb_or_group_id1 , orb_or_group_id2 )] = val_or_func def _hamiltonian_coulomb ( self ): def fill_matrix ( matrix , coupling_dict ): dummy = jnp . arange ( len ( self )) triangle_mask = dummy [:, None ] >= dummy # TODO: in principle we can build a big tensor NxNxgroups, vmap over the last axis and sum the groups # first, we loop over all group_id couplings => interactions between groups for key , function in coupling_dict . group_id_items (): # TODO: big uff: we rely on the correct ordering of the group_ids for cols and rows, first key is always smaller than last keys => we get upper triangular valid indices # if it were the other way around, these would be zeroed by the triangle mask cols = group_ids == key [ 0 ] rows = ( group_ids == key [ 1 ])[:, None ] combination_indices = jnp . logical_and ( rows , cols ) valid_indices = jnp . logical_and ( triangle_mask , combination_indices ) function = jax . vmap ( function ) matrix = matrix . at [ valid_indices ] . set ( function ( distances [ valid_indices ]) ) # we now set single elements rows , cols , vals = [], [], [] for key , val in coupling_dict . orbital_items (): rows . append ( self . _list . index ( key [ 0 ])) cols . append ( self . _list . index ( key [ 1 ])) vals . append ( val ) matrix = matrix . at [ rows , cols ] . set ( vals ) return matrix + matrix . conj () . T - jnp . diag ( jnp . diag ( matrix )) # TODO: rounding positions = self . _get_positions () distances = jnp . round ( jnp . linalg . norm ( positions - positions [:, None ], axis =- 1 ), 6 ) group_ids = jnp . array ( self . get_group_ids ()) hamiltonian = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . _hopping_dict ) coulomb = fill_matrix ( jnp . zeros (( len ( self ), len ( self ))) . astype ( complex ), self . _coulomb_dict ) return hamiltonian , coulomb def _get_positions ( self ): return jnp . array ([ orb . position for orb in self . _list ]) def _ensure_complex ( self , func_or_val ): if callable ( func_or_val ): return lambda x : func_or_val ( x ) + 0.0 j if isinstance ( func_or_val , ( int , float , complex )): return func_or_val + 0.0 j raise TypeError def _maybe_orbs_to_group_ids ( self , maybe_orbs ): def convert ( maybe_orb ): # TODO: check if this is really a group_id if isinstance ( maybe_orb , int ): return maybe_orb if isinstance ( maybe_orb , Orbital ): return maybe_orb . group_id return \"You have passed something that is neither an orbital nor a group_id\" return [ convert ( x ) for x in maybe_orbs ] def _maybe_indices_to_orbs ( self , maybe_indices ): def convert ( maybe_index ): if isinstance ( maybe_index , int ): return self . _list [ maybe_index ] if isinstance ( maybe_index , Orbital ): return maybe_index return \"You have passed something that is neither an orbital nor an index\" return [ convert ( x ) for x in maybe_indices ] def _build ( self ): assert len ( self ) > 0 self . _positions = self . _get_positions () self . _hamiltonian , self . _coulomb = self . _hamiltonian_coulomb () self . _eigenvectors , self . _energies = jax . lax . linalg . eigh ( self . _hamiltonian ) self . _initial_density_matrix = _numerics . _density_matrix ( self . _energies , self . electrons , self . spin_degeneracy , self . eps , self . from_state , self . to_state , self . excited_electrons , self . beta , ) self . _stationary_density_matrix = _numerics . _density_matrix ( self . _energies , self . electrons , self . spin_degeneracy , self . eps , jnp . array ([ 0 ]), jnp . array ([ 0 ]), jnp . array ([ 0 ]), self . beta , ) if self . self_consistency_params : ( self . _hamiltonian , self . _initial_density_matrix , self . _stationary_density_matrix , self . _energies , self . _eigenvectors , ) = _get_self_consistent ( self . _hamiltonian , self . _coulomb , self . _positions , self . spin_degeneracy , self . electrons , self . eps , self . _eigenvectors , self . _static_density_matrix , ** self . self_consistent_params , ) self . _initial_density_matrix = self . transform_to_site_basis ( self . _initial_density_matrix ) self . _stationary_density_matrix = self . transform_to_site_basis ( self . _stationary_density_matrix ) def get_group_ids ( self ): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [ orb . group_id for orb in self . _list ] def get_unique_group_ids ( self ): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list ( set ( self . get_group_ids ())) def set_groups_hopping ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _hopping_dict ) def set_groups_coulomb ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _coulomb_dict ) def set_hamiltonian_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _hopping_dict ) def set_coulomb_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _coulomb_dict ) def index ( self , orb ): return self . _list . index ( orb ) @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other ) @mutates def shift_by_vector ( self , tag_or_group_id , translation_vector ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag_or_group_id (str or int or list[int]): The tag, group_id to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" if isinstance ( tag_or_group_id , str ): orbs = [ orb for orb in self . _list if orb . tag == tag_or_group_id ] elif isinstance ( tag_or_group_id , int ): orbs = [ orb for orb in self . _list if orb . group_id == tag_or_group_id ] else : orbs = [ orb for orb in self . _list if orb . group_id in tag_or_group_id ] for orb in orbs : orb . position += jnp . array ( translation_vector ) @mutates def set_position ( self , tag , position ): \"\"\" Sets the position of all orbitals with a specific tag. Parameters: tag (str): The tag to match orbitals. position (jax.Array): The vector at which to move the orbitals Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [ orb for orb in self . _list if orb . tag == tag ] for orb in orbs : orb . position = position @mutates def make_self_consistent ( self , sc_params ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self . self_consistency_params = sc_params @mutates def set_electrons ( self , number ): self . simulation_params . electrons = number @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): maybe_int = jnp . array ( maybe_int ) if isinstance ( maybe_int , jax . Array ): return ( jnp . array ( maybe_int ) if maybe_int . ndim > 1 else jnp . array ([ maybe_int ]) ) raise TypeError self . simulation_params . from_state = maybe_int_to_arr ( from_state ) self . simulation_params . to_state = maybe_int_to_arr ( to_state ) self . simulation_params . excited_electrons = maybe_int_to_arr ( excited_electrons ) @mutates def set_dipole_transition ( self , orb_or_index1 , orb_or_index2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _transitions_dict [( orb_or_index1 , orb_or_index2 )] = jnp . array ( arr ) . astype ( complex ) @property @recomputes def homo ( self ): return ( self . electrons * self . stationary_density_matrix_e ) . real . diagonal () . round ( 2 ) . nonzero ()[ 0 ][ - 1 ] . item () @property def electrons ( self ): if self . simulation_params . electrons is None : return len ( self . _list ) return self . simulation_params . electrons @property def spin_degeneracy ( self ): return self . simulation_params . spin_degeneracy @property def from_state ( self ): return self . simulation_params . from_state @property def to_state ( self ): return self . simulation_params . to_state @property def excited_electrons ( self ): return self . simulation_params . excited_electrons @property def beta ( self ): return self . simulation_params . beta @property def eps ( self ): return self . simulation_params . eps @property @recomputes def positions ( self ): return self . _positions @property @recomputes def eigenvectors ( self ): return self . _eigenvectors @property @recomputes def energies ( self ): return self . _energies @property @recomputes def hamiltonian ( self ): return self . _hamiltonian @property @recomputes def coulomb ( self ): return self . _coulomb @property @recomputes def initial_density_matrix ( self ): return self . _initial_density_matrix @property @recomputes def stationary_density_matrix ( self ): return self . _stationary_density_matrix @property @recomputes def quadrupole_operator ( self ): \"\"\" Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: jax.Array: A tensor representing the quadrupole operator. \"\"\" dip = self . dipole_operator term = jnp . einsum ( \"ijk,jlm->ilkm\" , dip , dip ) diag = jnp . einsum ( \"ijk,jlk->il\" , dip , dip ) diag = jnp . einsum ( \"ij,kl->ijkl\" , diag , jnp . eye ( term . shape [ - 1 ])) return 3 * term - diag @property @recomputes def dipole_operator ( self ): \"\"\" Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. \"\"\" N = self . positions . shape [ 0 ] dipole_operator = jnp . zeros (( 3 , N , N )) . astype ( complex ) for i in range ( 3 ): dipole_operator = dipole_operator . at [ i , :, :] . set ( jnp . diag ( self . _positions [:, i ] / 2 ) ) for orbital_combination , value in self . _transitions_dict . items (): i , j = self . _list . index ( orbital_combination [ 0 ]), self . _list . index ( orbital_combination [ 1 ] ) k = value . nonzero ()[ 0 ] dipole_operator = dipole_operator . at [ k , i , j ] . set ( value [ k ]) return dipole_operator + jnp . transpose ( dipole_operator , ( 0 , 2 , 1 )) . conj () @property @recomputes def velocity_operator ( self ): \"\"\" Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. \"\"\" if self . _transitions_dict is None : x_times_h = jnp . einsum ( \"ij,iL->ijL\" , self . _hamiltonian , self . _positions ) h_times = jnp . einsum ( \"ij,jL->ijL\" , self . _hamiltonian , self . _positions ) else : positions = self . dipole_operator x_times_h = jnp . einsum ( \"kj,Lik->Lij\" , self . _hamiltonian , positions ) h_times = jnp . einsum ( \"ik,Lkj->Lij\" , self . _hamiltonian , positions ) return - 1 j * ( x_times_h - h_times ) @property @recomputes def transition_energies ( self ): \"\"\" Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: jax.Array: The element `arr[i,j]` contains the transition energy from `i` to `j`. \"\"\" return self . _energies [:, None ] - self . _energies @property @recomputes def wigner_weisskopf_transition_rates ( self ): \"\"\" Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: jax.Array: The element `arr[i,j]` contains the transition rate from `i` to `j`. \"\"\" charge = 1.602e-19 eps_0 = 8.85 * 1e-12 hbar = 1.0545718 * 1e-34 c = 3e8 # 137 (a.u.) factor = 1.6e-29 * charge / ( 3 * jnp . pi * eps_0 * hbar ** 2 * c ** 3 ) te = self . transition_energies transition_dipole_moments = self . dipole_operator_e return ( ( te * ( te > self . eps )) ** 3 * jnp . squeeze ( transition_dipole_moments ** 2 ) * factor ) @staticmethod def _transform_basis ( observable , vectors ): dims_einsum_strings = { 2 : \"ij,jk,lk->il\" , 3 : \"ij,mjk,lk->mil\" } einsum_string = dims_einsum_strings [( observable . ndim )] return jnp . einsum ( einsum_string , vectors , observable , vectors . conj ()) def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors ) def transform_to_energy_basis ( self , observable ): # \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T ) @recomputes def get_charge ( density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None : return jnp . diag ( self . initial_density_matrix * self . electrons ) else : return jnp . diag ( density_matrix * self . electrons ) @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians ) @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians ) @recomputes def get_epi ( self , density_matrix_stat : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = epsilon if epsilon is not None else self . eps density_matrix_stat_without_diagonal = jnp . abs ( density_matrix_stat - jnp . diag ( jnp . diag ( density_matrix_stat ))) density_matrix_stat_normalized = density_matrix_stat_without_diagonal / jnp . linalg . norm ( density_matrix_stat_without_diagonal ) te = self . transition_energies excitonic_transitions = ( density_matrix_stat_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * density_matrix_stat_normalized )) / ( jnp . linalg . norm ( density_matrix_stat_normalized ) * jnp . linalg . norm ( excitonic_transitions ) ) @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . _positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field def get_expectation_value ( self , * , operator , density_matrix , induced = True ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->li\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } correction = self . stationary_density_matrix_x if induced == True else 0 return self . electrons * jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , correction - density_matrix , ) def get_expectation_value_time_domain ( self , * args , ** kwargs ): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs . pop ( \"operator\" , None ) return_density = kwargs . pop ( \"return_density\" , False ) time_axis , density_matrices = self . get_density_matrix_time_domain ( * args , ** kwargs ) expectation_value = self . get_expectation_value ( density_matrix = density_matrices , operator = operator ) if return_density == True : return time_axis , expecation_value , density_matrices return time_axis , expectation_value def get_expectation_value_frequency_domain ( self , * args , ** kwargs ): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" density_matrices = kwargs . pop ( \"density_matrices\" , None ) time_axis = kwargs . pop ( \"time\" , None ) omega_min = kwargs . pop ( \"omega_min\" , 0 ) omega_max = kwargs . pop ( \"omega_max\" , 100 ) if density_matrices is None : time_axis , exp_val_td = self . get_expectation_value_time_domain ( * args , ** kwargs ) else : operator = kwargs . pop ( \"operator\" , None ) exp_val_td = self . get_expectation_value ( density_matrix = density_matrices , operator = operator ) omega , exp_val_omega = _numerics . get_fourier_transform ( time_axis , exp_val_td ) mask = ( omega >= omega_min ) & ( omega <= omega_max ) try : electric_field = jax . vmap ( kwargs [ \"illumination\" ])( time_axis ) field_omega = _numerics . get_fourier_transform ( time_axis , electric_field , return_omega_axis = False ) return omega [ mask ], exp_val_omega [ mask ], field_omega [ mask ] except KeyError : return omega [ mask ], exp_val_omega [ mask ] @recomputes def get_density_matrix_time_domain ( self , end_time : float , illumination : Callable [[ float ], jax . Array ], start_time : Optional [ float ] = None , steps_time : Optional [ int ] = None , skip : Optional [ int ] = None , relaxation_rate : Union [ float , jax . Array ] = None , saturation_functional : Callable [[ float ], float ] = lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))), use_old_method : bool = False , include_induced_contribution : bool = False , use_rwa = False , compute_only_at = None , coulomb_strength = 1.0 , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), initial_density_matrix : Optional [ jax . Array ] = None , ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. initial_density_matrix (Union[jax.Array,None]): if given, used as initial density matrix instead Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float ( start_time ) if start_time is not None else 0.0 steps_time = int ( steps_time ) if steps_time is not None else int ( end_time * 1000 ) time_axis = jnp . linspace ( start_time , end_time , steps_time ) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None : relaxation_function = lambda r : 0.0 elif isinstance ( relaxation_rate , jax . Array ): relaxation_function = _numerics . lindblad_saturation_functional ( self . _eigenvectors , relaxation_rate , saturation_functional , self . electrons , self . _stationary_density_matrix , ) else : relaxation_function = _numerics . relaxation_time_approximation ( relaxation_rate , self . stationary_density_matrix , ) # Verify that illumination is a callable if not callable ( illumination ): raise TypeError ( \"Provide a function for e-field\" ) # Initialize common variables coulomb_field_to_from = _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_only_at ) initial_density_matrix = self . initial_density_matrix if initial_density_matrix is None else initial_density_matrix # TODO: not very elegant: we just dump every argument in there by default return time_axis [:: skip ], _numerics . integrate_master_equation ( self . _hamiltonian , coulomb_strength * self . _coulomb , self . dipole_operator , self . electrons , self . velocity_operator , initial_density_matrix , self . stationary_density_matrix , time_axis , illumination , relaxation_function , coulomb_field_to_from , include_induced_contribution , use_rwa , solver , stepsize_controller , use_old_method , skip , ) # TODO: decouple rpa numerics from orbital datataype def get_polarizability_rpa ( self , omegas , relaxation_rate , polarization , coulomb_strength = 1.0 , hungry = 0 , phi_ext = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics . rpa_polarizability_function ( self , relaxation_rate , polarization , coulomb_strength , phi_ext , hungry ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] ) def get_susceptibility_rpa ( self , omegas , relaxation_rate , coulomb_strength = 1.0 , hungry = 0 ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics . rpa_polarizability_function ( self , relaxation_rate , coulomb_strength , hungry ) return jax . lax . map ( sus , omegas )","title":"OrbitalList"},{"location":"api/#granad.orbitals.OrbitalList.dipole_operator","text":"Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: \u2013 jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated.","title":"dipole_operator"},{"location":"api/#granad.orbitals.OrbitalList.quadrupole_operator","text":"Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: \u2013 jax.Array: A tensor representing the quadrupole operator.","title":"quadrupole_operator"},{"location":"api/#granad.orbitals.OrbitalList.transition_energies","text":"Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition energy from i to j .","title":"transition_energies"},{"location":"api/#granad.orbitals.OrbitalList.velocity_operator","text":"Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: \u2013 jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian.","title":"velocity_operator"},{"location":"api/#granad.orbitals.OrbitalList.wigner_weisskopf_transition_rates","text":"Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition rate from i to j .","title":"wigner_weisskopf_transition_rates"},{"location":"api/#granad.orbitals.OrbitalList.append","text":"Appends an orbital to the list, ensuring it is not already present. Parameters: other ( Orbital ) \u2013 The orbital to append. Raises: TypeError \u2013 If other is not an instance of Orbital. ValueError \u2013 If other is already in the list. Source code in src/granad/orbitals.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 @mutates def append ( self , other ): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance ( other , Orbital ): raise TypeError if other in self : raise ValueError self . _list . append ( other )","title":"append"},{"location":"api/#granad.orbitals.OrbitalList.get_charge","text":"Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix ( Array , default: None ) \u2013 The density matrix to use for calculating charge. Returns: \u2013 jax.Array: A diagonal array representing charges at each site. Source code in src/granad/orbitals.py 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 @recomputes def get_charge ( density_matrix = None ): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None : return jnp . diag ( self . initial_density_matrix * self . electrons ) else : return jnp . diag ( density_matrix * self . electrons )","title":"get_charge"},{"location":"api/#granad.orbitals.OrbitalList.get_density_matrix_time_domain","text":"Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time ( float ) \u2013 The end time for the simulation. illumination ( Callable [[ float ], Array ] ) \u2013 A function that returns the electric field at a given time. start_time ( Optional [ float ] , default: None ) \u2013 The start time for the simulation, defaults to zero. steps_time ( Optional [ int ] , default: None ) \u2013 The number of time steps to simulate, defaults to int(end_time * 1000) skip ( Optional [ int ] , default: None ) \u2013 The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate ( Union [ float , Array ] , default: None ) \u2013 The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional ( Callable [[ float ], float ] , default: lambda x: 1 / 1 + exp (-1000000.0 * 2.0 - x ) ) \u2013 A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method ( bool , default: False ) \u2013 Flag to use the old RK method. include_induced_contribution ( bool , default: False ) \u2013 Whether to include induced contributions in the simulation. use_rwa ( bool , default: False ) \u2013 Whether to apply the rotating wave approximation. compute_only_at ( Optional [ any ] , default: None ) \u2013 Specific orbital indices at which the induced field computation is performed. coulomb_strength ( float , default: 1.0 ) \u2013 Strength of Coulomb interactions. solver ( Solver , default: Dopri5 () ) \u2013 The differential equation solver to use. stepsize_controller ( StepSizeController , default: PIDController (rtol=1e-10, atol=1e-10) ) \u2013 The controller for the solver's step size. initial_density_matrix ( Union [ Array , None] , default: None ) \u2013 if given, used as initial density matrix instead Returns: \u2013 Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. Source code in src/granad/orbitals.py 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 @recomputes def get_density_matrix_time_domain ( self , end_time : float , illumination : Callable [[ float ], jax . Array ], start_time : Optional [ float ] = None , steps_time : Optional [ int ] = None , skip : Optional [ int ] = None , relaxation_rate : Union [ float , jax . Array ] = None , saturation_functional : Callable [[ float ], float ] = lambda x : 1 / ( 1 + jnp . exp ( - 1e6 * ( 2.0 - x ))), use_old_method : bool = False , include_induced_contribution : bool = False , use_rwa = False , compute_only_at = None , coulomb_strength = 1.0 , solver = diffrax . Dopri5 (), stepsize_controller = diffrax . PIDController ( rtol = 1e-10 , atol = 1e-10 ), initial_density_matrix : Optional [ jax . Array ] = None , ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. initial_density_matrix (Union[jax.Array,None]): if given, used as initial density matrix instead Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float ( start_time ) if start_time is not None else 0.0 steps_time = int ( steps_time ) if steps_time is not None else int ( end_time * 1000 ) time_axis = jnp . linspace ( start_time , end_time , steps_time ) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None : relaxation_function = lambda r : 0.0 elif isinstance ( relaxation_rate , jax . Array ): relaxation_function = _numerics . lindblad_saturation_functional ( self . _eigenvectors , relaxation_rate , saturation_functional , self . electrons , self . _stationary_density_matrix , ) else : relaxation_function = _numerics . relaxation_time_approximation ( relaxation_rate , self . stationary_density_matrix , ) # Verify that illumination is a callable if not callable ( illumination ): raise TypeError ( \"Provide a function for e-field\" ) # Initialize common variables coulomb_field_to_from = _numerics . get_coulomb_field_to_from ( self . positions , self . positions , compute_only_at ) initial_density_matrix = self . initial_density_matrix if initial_density_matrix is None else initial_density_matrix # TODO: not very elegant: we just dump every argument in there by default return time_axis [:: skip ], _numerics . integrate_master_equation ( self . _hamiltonian , coulomb_strength * self . _coulomb , self . dipole_operator , self . electrons , self . velocity_operator , initial_density_matrix , self . stationary_density_matrix , time_axis , illumination , relaxation_function , coulomb_field_to_from , include_induced_contribution , use_rwa , solver , stepsize_controller , use_old_method , skip , )","title":"get_density_matrix_time_domain"},{"location":"api/#granad.orbitals.OrbitalList.get_dos","text":"Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the DOS. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The integrated density of states at the specified frequency. Source code in src/granad/orbitals.py 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 @recomputes def get_dos ( self , omega : float , broadening : float = 0.1 ): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( gaussians )","title":"get_dos"},{"location":"api/#granad.orbitals.OrbitalList.get_epi","text":"Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat ( Array ) \u2013 The density matrix to consider for EPI calculation. omega ( float ) \u2013 The frequency to evaluate the EPI at. epsilon ( float , default: None ) \u2013 The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float ( float ) \u2013 The EPI. Source code in src/granad/orbitals.py 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 @recomputes def get_epi ( self , density_matrix_stat : jax . Array , omega : float , epsilon : float = None ) -> float : \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: density_matrix_stat (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = epsilon if epsilon is not None else self . eps density_matrix_stat_without_diagonal = jnp . abs ( density_matrix_stat - jnp . diag ( jnp . diag ( density_matrix_stat ))) density_matrix_stat_normalized = density_matrix_stat_without_diagonal / jnp . linalg . norm ( density_matrix_stat_without_diagonal ) te = self . transition_energies excitonic_transitions = ( density_matrix_stat_normalized / ( te * ( te > self . eps ) - omega + 1 j * epsilon ) ** 2 ) return 1 - jnp . sum ( jnp . abs ( excitonic_transitions * density_matrix_stat_normalized )) / ( jnp . linalg . norm ( density_matrix_stat_normalized ) * jnp . linalg . norm ( excitonic_transitions ) )","title":"get_epi"},{"location":"api/#granad.orbitals.OrbitalList.get_expectation_value","text":"Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator ( Array ) \u2013 The operator for which the expectation value is calculated. density_matrix ( Array ) \u2013 The density matrix representing the state of the system. Returns: \u2013 jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. Source code in src/granad/orbitals.py 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 def get_expectation_value ( self , * , operator , density_matrix , induced = True ): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { ( 3 , 2 ): \"ijk,kj->i\" , ( 3 , 3 ): \"ijk,lkj->li\" , ( 2 , 3 ): \"ij,kji->k\" , ( 2 , 2 ): \"ij,ji->\" , } correction = self . stationary_density_matrix_x if induced == True else 0 return self . electrons * jnp . einsum ( dims_einsum_strings [( operator . ndim , density_matrix . ndim )], operator , correction - density_matrix , )","title":"get_expectation_value"},{"location":"api/#granad.orbitals.OrbitalList.get_expectation_value_frequency_domain","text":"Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: \u2013 Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. Source code in src/granad/orbitals.py 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 def get_expectation_value_frequency_domain ( self , * args , ** kwargs ): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" density_matrices = kwargs . pop ( \"density_matrices\" , None ) time_axis = kwargs . pop ( \"time\" , None ) omega_min = kwargs . pop ( \"omega_min\" , 0 ) omega_max = kwargs . pop ( \"omega_max\" , 100 ) if density_matrices is None : time_axis , exp_val_td = self . get_expectation_value_time_domain ( * args , ** kwargs ) else : operator = kwargs . pop ( \"operator\" , None ) exp_val_td = self . get_expectation_value ( density_matrix = density_matrices , operator = operator ) omega , exp_val_omega = _numerics . get_fourier_transform ( time_axis , exp_val_td ) mask = ( omega >= omega_min ) & ( omega <= omega_max ) try : electric_field = jax . vmap ( kwargs [ \"illumination\" ])( time_axis ) field_omega = _numerics . get_fourier_transform ( time_axis , electric_field , return_omega_axis = False ) return omega [ mask ], exp_val_omega [ mask ], field_omega [ mask ] except KeyError : return omega [ mask ], exp_val_omega [ mask ]","title":"get_expectation_value_frequency_domain"},{"location":"api/#granad.orbitals.OrbitalList.get_expectation_value_time_domain","text":"Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: \u2013 Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. Source code in src/granad/orbitals.py 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 def get_expectation_value_time_domain ( self , * args , ** kwargs ): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs . pop ( \"operator\" , None ) return_density = kwargs . pop ( \"return_density\" , False ) time_axis , density_matrices = self . get_density_matrix_time_domain ( * args , ** kwargs ) expectation_value = self . get_expectation_value ( density_matrix = density_matrices , operator = operator ) if return_density == True : return time_axis , expecation_value , density_matrices return time_axis , expectation_value","title":"get_expectation_value_time_domain"},{"location":"api/#granad.orbitals.OrbitalList.get_group_ids","text":"Retrieves a list of group IDs for all orbitals managed by this object. Returns: \u2013 List[int]: A list of group IDs for each orbital. Source code in src/granad/orbitals.py 457 458 459 460 461 462 463 464 def get_group_ids ( self ): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [ orb . group_id for orb in self . _list ]","title":"get_group_ids"},{"location":"api/#granad.orbitals.OrbitalList.get_induced_field","text":"Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions ( Array ) \u2013 The positions at which to evaluate the induced field. density_matrix ( Array ) \u2013 The density matrix used to calculate the induced field. Returns: \u2013 jax.Array: The resulting electric field vector at each position. Source code in src/granad/orbitals.py 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 @recomputes def get_induced_field ( self , positions : jax . Array , density_matrix ): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self . _positions [:, None ] - positions # scalar distances denominator = jnp . linalg . norm ( vec_r , axis = 2 ) ** 3 # normalize distance vector array point_charge = jnp . nan_to_num ( vec_r / denominator [:, :, None ], posinf = 0.0 , neginf = 0.0 ) # compute charge via occupations in site basis charge = self . electrons * density_matrix . real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp . sum ( point_charge * charge [:, None , None ], axis = 0 ) return e_field","title":"get_induced_field"},{"location":"api/#granad.orbitals.OrbitalList.get_ldos","text":"Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the LDOS. site_index ( int ) \u2013 The site index to evaluate the LDOS at. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The local density of states at the specified site and frequency. Source code in src/granad/orbitals.py 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 @recomputes def get_ldos ( self , omega : float , site_index : int , broadening : float = 0.1 ): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp . abs ( self . _eigenvectors [ site_index , :]) ** 2 prefactor = 1 / ( jnp . sqrt ( 2 * jnp . pi ) * broadening ) gaussians = jnp . exp ( - (( self . _energies - omega ) ** 2 ) / 2 * broadening ** 2 ) return prefactor * jnp . sum ( weight * gaussians )","title":"get_ldos"},{"location":"api/#granad.orbitals.OrbitalList.get_polarizability_rpa","text":"Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas ( Array ) \u2013 Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate ( float ) \u2013 The relaxation time parameter. polarization ( Array ) \u2013 Polarization directions or modes. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interaction in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext ( Optional [ Array ] , default: None ) \u2013 External potential influences, if any. Returns: \u2013 jax.Array: The calculated polarizabilities at the specified frequencies. Source code in src/granad/orbitals.py 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 def get_polarizability_rpa ( self , omegas , relaxation_rate , polarization , coulomb_strength = 1.0 , hungry = 0 , phi_ext = None , ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. If given as an nxm array, this function will be applied vectorized to the batches given by the last axis in omegas. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics . rpa_polarizability_function ( self , relaxation_rate , polarization , coulomb_strength , phi_ext , hungry ) if omegas . ndim == 1 : return jax . lax . map ( alpha , omegas ) else : return jnp . concatenate ( [ jax . vmap ( alpha )( omega ) for omega in omegas ] )","title":"get_polarizability_rpa"},{"location":"api/#granad.orbitals.OrbitalList.get_susceptibility_rpa","text":"Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas ( Array ) \u2013 The frequencies at which to compute susceptibility. relaxation_rate ( float ) \u2013 The relaxation time affecting susceptibility calculations. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interactions considered in the calculations. hungry ( int , default: 0 ) \u2013 speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: \u2013 jax.Array: The susceptibility values at the given frequencies. Source code in src/granad/orbitals.py 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 def get_susceptibility_rpa ( self , omegas , relaxation_rate , coulomb_strength = 1.0 , hungry = 0 ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (int): speed up the simulation up, higher numbers (max 2) increase RAM usage. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics . rpa_polarizability_function ( self , relaxation_rate , coulomb_strength , hungry ) return jax . lax . map ( sus , omegas )","title":"get_susceptibility_rpa"},{"location":"api/#granad.orbitals.OrbitalList.get_unique_group_ids","text":"Retrieves a unique set of group IDs from all orbitals. Returns: \u2013 List[int]: A list of unique group IDs. Source code in src/granad/orbitals.py 466 467 468 469 470 471 472 473 def get_unique_group_ids ( self ): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list ( set ( self . get_group_ids ()))","title":"get_unique_group_ids"},{"location":"api/#granad.orbitals.OrbitalList.make_self_consistent","text":"Configures the list for self-consistent field calculations. Parameters: sc_params ( dict ) \u2013 Parameters for self-consistency. Source code in src/granad/orbitals.py 597 598 599 600 601 602 603 604 605 @mutates def make_self_consistent ( self , sc_params ): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self . self_consistency_params = sc_params","title":"make_self_consistent"},{"location":"api/#granad.orbitals.OrbitalList.set_coulomb_element","text":"Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Coulomb interaction element. Source code in src/granad/orbitals.py 525 526 527 528 529 530 531 532 533 534 535 def set_coulomb_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _coulomb_dict )","title":"set_coulomb_element"},{"location":"api/#granad.orbitals.OrbitalList.set_dipole_transition","text":"Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first part of the transition. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second part of the transition. arr ( Array ) \u2013 The 3-element array containing dipole transition elements. Source code in src/granad/orbitals.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 @mutates def set_dipole_transition ( self , orb_or_index1 , orb_or_index2 , arr ): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _transitions_dict [( orb_or_index1 , orb_or_index2 )] = jnp . array ( arr ) . astype ( complex )","title":"set_dipole_transition"},{"location":"api/#granad.orbitals.OrbitalList.set_excitation","text":"Sets up an excitation process from one state to another with specified electrons. Parameters: from_state ( int, list, or jax.Array ) \u2013 The initial state index or indices. to_state ( int, list, or jax.Array ) \u2013 The final state index or indices. excited_electrons ( int, list, or jax.Array ) \u2013 The indices of electrons to be excited. Notes The states and electron indices may be specified as scalars, lists, or arrays. Source code in src/granad/orbitals.py 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 @mutates def set_excitation ( self , from_state , to_state , excited_electrons ): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr ( maybe_int ): if isinstance ( maybe_int , int ): return jnp . array ([ maybe_int ]) if isinstance ( maybe_int , list ): maybe_int = jnp . array ( maybe_int ) if isinstance ( maybe_int , jax . Array ): return ( jnp . array ( maybe_int ) if maybe_int . ndim > 1 else jnp . array ([ maybe_int ]) ) raise TypeError self . simulation_params . from_state = maybe_int_to_arr ( from_state ) self . simulation_params . to_state = maybe_int_to_arr ( to_state ) self . simulation_params . excited_electrons = maybe_int_to_arr ( excited_electrons )","title":"set_excitation"},{"location":"api/#granad.orbitals.OrbitalList.set_groups_coulomb","text":"Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the Coulomb interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def set_groups_coulomb ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _coulomb_dict )","title":"set_groups_coulomb"},{"location":"api/#granad.orbitals.OrbitalList.set_groups_hopping","text":"Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the hopping interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def set_groups_hopping ( self , orb_or_group_id1 , orb_or_group_id2 , func ): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1 , group_id2 = self . _maybe_orbs_to_group_ids ( ( orb_or_group_id1 , orb_or_group_id2 ) ) self . _set_coupling ( group_id1 , group_id2 , self . _ensure_complex ( func ), self . _hopping_dict )","title":"set_groups_hopping"},{"location":"api/#granad.orbitals.OrbitalList.set_hamiltonian_element","text":"Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Hamiltonian element. Source code in src/granad/orbitals.py 513 514 515 516 517 518 519 520 521 522 523 def set_hamiltonian_element ( self , orb_or_index1 , orb_or_index2 , val ): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1 , orb2 = self . _maybe_indices_to_orbs (( orb_or_index1 , orb_or_index2 )) self . _set_coupling ( orb1 , orb2 , self . _ensure_complex ( val ), self . _hopping_dict )","title":"set_hamiltonian_element"},{"location":"api/#granad.orbitals.OrbitalList.set_position","text":"Sets the position of all orbitals with a specific tag. Parameters: tag ( str ) \u2013 The tag to match orbitals. position ( Array ) \u2013 The vector at which to move the orbitals Notes This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 @mutates def set_position ( self , tag , position ): \"\"\" Sets the position of all orbitals with a specific tag. Parameters: tag (str): The tag to match orbitals. position (jax.Array): The vector at which to move the orbitals Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [ orb for orb in self . _list if orb . tag == tag ] for orb in orbs : orb . position = position","title":"set_position"},{"location":"api/#granad.orbitals.OrbitalList.shift_by_vector","text":"Shifts all orbitals with a specific tag by a given vector. Parameters: tag_or_group_id ( str or int or list [ int ] ) \u2013 The tag, group_id to match orbitals. translation_vector ( Array ) \u2013 The vector by which to translate the orbital positions. Notes This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 @mutates def shift_by_vector ( self , tag_or_group_id , translation_vector ): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag_or_group_id (str or int or list[int]): The tag, group_id to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" if isinstance ( tag_or_group_id , str ): orbs = [ orb for orb in self . _list if orb . tag == tag_or_group_id ] elif isinstance ( tag_or_group_id , int ): orbs = [ orb for orb in self . _list if orb . group_id == tag_or_group_id ] else : orbs = [ orb for orb in self . _list if orb . group_id in tag_or_group_id ] for orb in orbs : orb . position += jnp . array ( translation_vector )","title":"shift_by_vector"},{"location":"api/#granad.orbitals.OrbitalList.transform_to_energy_basis","text":"Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the energy basis. Source code in src/granad/orbitals.py 836 837 838 839 840 841 842 843 844 845 846 847 def transform_to_energy_basis ( self , observable ): # \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors . conj () . T )","title":"transform_to_energy_basis"},{"location":"api/#granad.orbitals.OrbitalList.transform_to_site_basis","text":"Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the site basis. Source code in src/granad/orbitals.py 824 825 826 827 828 829 830 831 832 833 834 def transform_to_site_basis ( self , observable ): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self . _transform_basis ( observable , self . _eigenvectors )","title":"transform_to_site_basis"},{"location":"api/#granad.orbitals.SimulationParams","text":"A data class for storing parameters necessary for running a simulation involving electronic states and transitions. Attributes: from_state ( Array ) \u2013 An array where each element is the index of an electronic state from which electrons are excited. Defaults to an array containing a single zero. to_state ( Array ) \u2013 An array where each element is the index of an electronic state to which electrons are excited. Defaults to an array containing a single zero. excited_electrons ( Array ) \u2013 An array where each element indicates the number of electrons excited between the corresponding states in from_state and to_state . Defaults to an array containing a single zero. eps ( float ) \u2013 Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5. beta ( float ) \u2013 Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to jax.numpy.inf by default, implying zero temperature. self_consistency_params ( dict ) \u2013 A dictionary to hold additional parameters required for self-consistency calculations within the simulation. Defaults to an empty dictionary. spin_degeneracy ( float ) \u2013 Factor to account for the degeneracy of spin states in the simulation. Typically set to 2, considering spin up and spin down. electrons ( Optional [ int ] ) \u2013 The total number of electrons in the structure. If not provided, it is assumed that the system's electron number needs to be calculated or is managed elsewhere. Note This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state of OrbitalList. Source code in src/granad/orbitals.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @dataclass class SimulationParams : \"\"\" A data class for storing parameters necessary for running a simulation involving electronic states and transitions. Attributes: from_state (jax.Array): An array where each element is the index of an electronic state from which electrons are excited. Defaults to an array containing a single zero. to_state (jax.Array): An array where each element is the index of an electronic state to which electrons are excited. Defaults to an array containing a single zero. excited_electrons (jax.Array): An array where each element indicates the number of electrons excited between the corresponding states in `from_state` and `to_state`. Defaults to an array containing a single zero. eps (float): Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5. beta (float): Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to `jax.numpy.inf` by default, implying zero temperature. self_consistency_params (dict): A dictionary to hold additional parameters required for self-consistency calculations within the simulation. Defaults to an empty dictionary. spin_degeneracy (float): Factor to account for the degeneracy of spin states in the simulation. Typically set to 2, considering spin up and spin down. electrons (Optional[int]): The total number of electrons in the structure. If not provided, it is assumed that the system's electron number needs to be calculated or is managed elsewhere. Note: This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state of OrbitalList. \"\"\" from_state : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 ])) to_state : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 ])) excited_electrons : jax . Array = field ( default_factory = lambda : jnp . array ([ 0 ])) eps : float = 1e-5 beta : float = jnp . inf self_consistency_params : dict = field ( default_factory = dict ) spin_degeneracy : float = 2.0 electrons : Optional [ int ] = None","title":"SimulationParams"},{"location":"api/#granad.fields.Pulse","text":"Function for computing temporally located time-harmonics electric fields. The pulse is implemented as a temporal Gaussian. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency of the electric field - `peak`: time where the pulse reaches its peak - `fwhm`: full width at half maximum Returns: Function that computes the electric field Source code in src/granad/fields.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def Pulse ( amplitudes : list [ float ], frequency : float , peak : float , fwhm : float , ): \"\"\"Function for computing temporally located time-harmonics electric fields. The pulse is implemented as a temporal Gaussian. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency of the electric field - `peak`: time where the pulse reaches its peak - `fwhm`: full width at half maximum **Returns:** Function that computes the electric field \"\"\" static_part = jnp . array ( amplitudes ) sigma = fwhm / ( 2.0 * jnp . sqrt ( jnp . log ( 2 ))) return lambda t : ( static_part * jnp . exp ( - 1 j * jnp . pi / 2 + 1 j * frequency * ( t - peak )) * jnp . exp ( - (( t - peak ) ** 2 ) / sigma ** 2 ) )","title":"Pulse"},{"location":"api/#granad.fields.Ramp","text":"Function for computing ramping up time-harmonic electric fields. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency - `ramp_duration`: specifies how long does the electric field ramps up - `time_ramp`: specifies time at which the field starts to ramp up Returns: Function that computes the electric field as a functon of time Source code in src/granad/fields.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def Ramp ( amplitudes : list [ float ], frequency : float , ramp_duration : float , time_ramp : float , ): \"\"\"Function for computing ramping up time-harmonic electric fields. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency - `ramp_duration`: specifies how long does the electric field ramps up - `time_ramp`: specifies time at which the field starts to ramp up **Returns:** Function that computes the electric field as a functon of time \"\"\" static_part = jnp . array ( amplitudes ) p = 0.99 ramp_constant = 2 * jnp . log ( p / ( 1 - p )) / ramp_duration return lambda t : ( static_part * jnp . exp ( 1 j * frequency * t ) / ( 1 + 1.0 * jnp . exp ( - ramp_constant * ( t - time_ramp ))) )","title":"Ramp"},{"location":"api/#granad.fields.Wave","text":"Function for computing time-harmonic electric fields. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency Returns: Function that computes the electric field as a functon of time Source code in src/granad/fields.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def Wave ( amplitudes : list [ float ], frequency : float , ): \"\"\"Function for computing time-harmonic electric fields. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency **Returns:** Function that computes the electric field as a functon of time \"\"\" static_part = jnp . array ( amplitudes ) return lambda t : ( jnp . exp ( 1 j * frequency * t ) * static_part )","title":"Wave"},{"location":"api/#granad.materials.Material","text":"Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name ( str ) \u2013 The name of the material. species ( dict ) \u2013 Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals ( defaultdict [ list ] ) \u2013 A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions ( defaultdict [ dict ] ) \u2013 Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hopping', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Usage The Material class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hopping and Coulomb interactions among these orbitals. Example graphene = ( Material(\"graphene\") .lattice_constant(2.46) .lattice_basis([ [1, 0, 0], [-0.5, jnp.sqrt(3)/2, 0] ]) .add_orbital_species(\"pz\", l=1, atom='C') .add_orbital(position=(0, 0), tag=\"sublattice_1\", species=\"pz\") .add_orbital(position=(-1/3, -2/3), tag=\"sublattice_2\", species=\"pz\") .add_interaction( \"hopping\", participants=(\"pz\", \"pz\"), parameters=[0.0, 2.66], # no expression given => we online look at onsite and nearest neighbors ) .add_interaction( \"coulomb\", participants=(\"pz\", \"pz\"), parameters=[16.522, 8.64, 5.333], # we look at onsite, nn, nnn couplings expression=lambda d: 14.399 / d # for nnnn and more, we apply the coulomb law ) ) Source code in src/granad/materials.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 class Material : \"\"\" Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name (str): The name of the material. species (dict): Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals (defaultdict[list]): A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions (defaultdict[dict]): Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hopping', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Usage: The `Material` class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hopping and Coulomb interactions among these orbitals. Example: graphene = ( Material(\"graphene\") .lattice_constant(2.46) .lattice_basis([ [1, 0, 0], [-0.5, jnp.sqrt(3)/2, 0] ]) .add_orbital_species(\"pz\", l=1, atom='C') .add_orbital(position=(0, 0), tag=\"sublattice_1\", species=\"pz\") .add_orbital(position=(-1/3, -2/3), tag=\"sublattice_2\", species=\"pz\") .add_interaction( \"hopping\", participants=(\"pz\", \"pz\"), parameters=[0.0, 2.66], # no expression given => we online look at onsite and nearest neighbors ) .add_interaction( \"coulomb\", participants=(\"pz\", \"pz\"), parameters=[16.522, 8.64, 5.333], # we look at onsite, nn, nnn couplings expression=lambda d: 14.399 / d # for nnnn and more, we apply the coulomb law ) ) \"\"\" def __init__ ( self , name ): self . name = name self . species = {} self . orbitals = defaultdict ( list ) self . interactions = defaultdict ( dict ) self . _species_to_groups = {} self . dim = None def __str__ ( self ): description = f \"Material: { self . name } \\n \" if self . lattice_constant : description += f \" Lattice Constant: { self . lattice_constant } \u00c5 \\n \" if self . lattice_basis : description += f \" Lattice Basis: { self . _lattice_basis } \\n \" if self . species : description += \" Orbital Species: \\n \" for species_name , attributes in self . species . items (): description += f \" { species_name } characterized by (n,l,m,s, atom name) = { attributes } \\n \" if self . orbitals : description += \" Orbitals: \\n \" for spec , orbs in self . orbitals . items (): for orb in orbs : description += f \" Position: { orb [ 'position' ] } , Tag: { orb [ 'tag' ] } , Species: { spec } \\n \" if self . interactions : description += \" Interactions: \\n \" for type_ , interaction in self . interactions . items (): for participants , coupling in interaction . items (): description += f \" Type: { type_ } , Participants: { participants } , Couplings (neighbor, function): { coupling } \\n \" return description def lattice_constant ( self , value ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . lattice_constant = value return self def lattice_basis ( self , values , periodic = None ): \"\"\" Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values (list of list of float): A list of vectors representing the lattice basis. periodic (list of int, optional): Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material: Returns self to enable method chaining. \"\"\" self . _lattice_basis = jnp . array ( values ) total = set ( range ( len ( self . _lattice_basis ))) periodic = set ( periodic ) if periodic is not None else total self . periodic = list ( periodic ) self . finite = list ( total - periodic ) self . dim = len ( self . periodic ) return self @_finalize def cut_flake ( self ): \"\"\" Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. \"\"\" pass def add_orbital ( self , position , species , tag = '' ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . orbitals [ species ] . append ({ 'position' : position , 'tag' : tag }) return self def add_orbital_species ( self , name , n = 0 , l = 0 , m = 0 , s = 0 , atom = '' ): \"\"\" Adds a species definition for orbitals in the material. Parameters: name (str): The name of the orbital species. n (int): Principal quantum number. l (int): Orbital angular momentum quantum number. m (int): Magnetic quantum number. s (int): Spin quantum number. atom (str, optional): Name of the atom the orbital belongs to. Returns: Material: Returns self to enable method chaining. \"\"\" self . species [ name ] = ( n , l , m , s , atom ) return self def add_interaction ( self , interaction_type , participants , parameters , expression = lambda x : 0 j ): \"\"\" Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type (str): The type of interaction (e.g., 'hopping', 'Coulomb'). participants (tuple): A tuple identifying the participants in the interaction. parameters (dict): Parameters relevant to the interaction. expression (function): A function defining the mathematical form of the interaction. Returns: Material: Returns self to enable method chaining. \"\"\" self . interactions [ interaction_type ][ participants ] = ( parameters , lambda x : expression ( x ) + 0 j ) return self def _get_positions_in_uc ( self , species = None ): if species is None : return jnp . array ( [ x [ \"position\" ] for orb in list ( self . orbitals . values ()) for x in orb ] ) else : return jnp . array ( [ orb_group [ 'position' ] for s in species for orb_group in self . orbitals [ s ] ] ) def _get_positions_in_lattice ( self , uc_positions , grid ): shift = jnp . array ( uc_positions ) @ self . _lattice_basis return self . lattice_constant * ( grid @ self . _lattice_basis + shift [:, None , :] ) . reshape ( shift . shape [ 0 ] * grid . shape [ 0 ], 3 ) def _get_grid ( self , ns ): grid = [( 1 ,) for i in range ( len ( self . finite ) + len ( self . periodic )) ] for i , p in enumerate ( self . periodic ): grid [ p ] = range ( * ns [ i ]) return jnp . array ( list ( product ( * ( x for x in grid ) ) ) ) def _keep_matching_positions ( self , positions , candidates ): idxs = ( jnp . round ( jnp . linalg . norm ( positions - candidates [:, None ], axis =- 1 ), 4 ) == 0 ) . nonzero ()[ 0 ] return candidates [ idxs ] def _couplings_to_function ( self , couplings , outside_fun , species ): couplings = jnp . array ( couplings ) + 0.0 j grid = self . _get_grid ( [ ( 0 , len ( couplings )) for i in range ( self . dim ) ] ) fractional_positions = self . _get_positions_in_uc ( species ) positions = self . _get_positions_in_lattice ( fractional_positions , grid ) distances = jnp . unique ( jnp . round ( jnp . linalg . norm ( positions - positions [:, None , :], axis = 2 ), 8 ) )[: len ( couplings )] def inner ( d ): return jax . lax . cond ( jnp . min ( jnp . abs ( d - distances )) < 1e-5 , lambda x : couplings [ jnp . argmin ( jnp . abs ( x - distances ))], outside_fun , d , ) return inner def _set_couplings ( self , setter_func , interaction_type ): interaction_dict = self . interactions [ interaction_type ] for ( species_1 , species_2 ), couplings in interaction_dict . items (): distance_func = self . _couplings_to_function ( * couplings , ( species_1 , species_2 ) ) setter_func ( self . _species_to_groups [ species_1 ], self . _species_to_groups [ species_2 ], distance_func ) def _get_orbital_list ( self , allowed_positions , grid ): raw_list , layer_index = [], 0 for species , orb_group in self . orbitals . items (): for orb_uc in orb_group : uc_positions = jnp . array ( [ orb_uc [ 'position' ]] ) rs_positions = self . _get_positions_in_lattice ( uc_positions , grid ) final_positions = self . _keep_matching_positions ( allowed_positions , rs_positions ) for position in final_positions : orb = Orbital ( position = position , layer_index = layer_index , tag = orb_uc [ 'tag' ], group_id = self . _species_to_groups [ species ], energy_level = self . species [ species ][ 0 ], angular_momentum = self . species [ species ][ 1 ], angular_momentum_z = self . species [ species ][ 2 ], spin = self . species [ species ][ 3 ], atom_name = self . species [ species ][ 4 ] ) layer_index += 1 raw_list . append ( orb ) orbital_list = OrbitalList ( raw_list ) self . _set_couplings ( orbital_list . set_groups_hopping , \"hopping\" ) self . _set_couplings ( orbital_list . set_groups_coulomb , \"coulomb\" ) return orbital_list","title":"Material"},{"location":"api/#granad.materials.Material.add_interaction","text":"Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type ( str ) \u2013 The type of interaction (e.g., 'hopping', 'Coulomb'). participants ( tuple ) \u2013 A tuple identifying the participants in the interaction. parameters ( dict ) \u2013 Parameters relevant to the interaction. expression ( function , default: lambda x: 0j ) \u2013 A function defining the mathematical form of the interaction. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def add_interaction ( self , interaction_type , participants , parameters , expression = lambda x : 0 j ): \"\"\" Adds an interaction between orbitals specified by an interaction type and participants. Parameters: interaction_type (str): The type of interaction (e.g., 'hopping', 'Coulomb'). participants (tuple): A tuple identifying the participants in the interaction. parameters (dict): Parameters relevant to the interaction. expression (function): A function defining the mathematical form of the interaction. Returns: Material: Returns self to enable method chaining. \"\"\" self . interactions [ interaction_type ][ participants ] = ( parameters , lambda x : expression ( x ) + 0 j ) return self","title":"add_interaction"},{"location":"api/#granad.materials.Material.add_orbital","text":"Sets the lattice constant for the material. Parameters: value ( float ) \u2013 The lattice constant value. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 315 316 317 318 319 320 321 322 323 324 325 326 def add_orbital ( self , position , species , tag = '' ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . orbitals [ species ] . append ({ 'position' : position , 'tag' : tag }) return self","title":"add_orbital"},{"location":"api/#granad.materials.Material.add_orbital_species","text":"Adds a species definition for orbitals in the material. Parameters: name ( str ) \u2013 The name of the orbital species. n ( int , default: 0 ) \u2013 Principal quantum number. l ( int , default: 0 ) \u2013 Orbital angular momentum quantum number. m ( int , default: 0 ) \u2013 Magnetic quantum number. s ( int , default: 0 ) \u2013 Spin quantum number. atom ( str , default: '' ) \u2013 Name of the atom the orbital belongs to. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 def add_orbital_species ( self , name , n = 0 , l = 0 , m = 0 , s = 0 , atom = '' ): \"\"\" Adds a species definition for orbitals in the material. Parameters: name (str): The name of the orbital species. n (int): Principal quantum number. l (int): Orbital angular momentum quantum number. m (int): Magnetic quantum number. s (int): Spin quantum number. atom (str, optional): Name of the atom the orbital belongs to. Returns: Material: Returns self to enable method chaining. \"\"\" self . species [ name ] = ( n , l , m , s , atom ) return self","title":"add_orbital_species"},{"location":"api/#granad.materials.Material.cut_flake","text":"Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. Source code in src/granad/materials.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 @_finalize def cut_flake ( self ): \"\"\" Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. \"\"\" pass","title":"cut_flake"},{"location":"api/#granad.materials.Material.lattice_basis","text":"Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values ( list of list of float ) \u2013 A list of vectors representing the lattice basis. periodic ( list of int , default: None ) \u2013 Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def lattice_basis ( self , values , periodic = None ): \"\"\" Defines the lattice basis vectors and specifies which dimensions are periodic. Parameters: values (list of list of float): A list of vectors representing the lattice basis. periodic (list of int, optional): Indices of the basis vectors that are periodic. Defaults to all vectors being periodic. Returns: Material: Returns self to enable method chaining. \"\"\" self . _lattice_basis = jnp . array ( values ) total = set ( range ( len ( self . _lattice_basis ))) periodic = set ( periodic ) if periodic is not None else total self . periodic = list ( periodic ) self . finite = list ( total - periodic ) self . dim = len ( self . periodic ) return self","title":"lattice_basis"},{"location":"api/#granad.materials.Material.lattice_constant","text":"Sets the lattice constant for the material. Parameters: value ( float ) \u2013 The lattice constant value. Returns: Material \u2013 Returns self to enable method chaining. Source code in src/granad/materials.py 263 264 265 266 267 268 269 270 271 272 273 274 def lattice_constant ( self , value ): \"\"\" Sets the lattice constant for the material. Parameters: value (float): The lattice constant value. Returns: Material: Returns self to enable method chaining. \"\"\" self . lattice_constant = value return self","title":"lattice_constant"},{"location":"api/#granad.materials.cut_flake_1d","text":"Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. unit_cells ( int ) \u2013 The number of unit cells to include in the flake. plot ( bool , default: False ) \u2013 If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list \u2013 A list of orbitals positioned within the specified range of the material's lattice. Note The function utilizes internal methods of the Material class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. Source code in src/granad/materials.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def cut_flake_1d ( material , unit_cells , plot = False ): \"\"\" Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material (Material): The material instance from which to cut the flake. unit_cells (int): The number of unit cells to include in the flake. plot (bool, optional): If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list: A list of orbitals positioned within the specified range of the material's lattice. Note: The function utilizes internal methods of the `Material` class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. \"\"\" orbital_positions_uc = material . _get_positions_in_uc () grid = material . _get_grid ( [( 0 , unit_cells )] ) orbital_positions = material . _get_positions_in_lattice ( orbital_positions_uc , grid ) if plot : _display_lattice_cut ( orbital_positions , orbital_positions ) orbital_positions = jnp . unique ( orbital_positions , axis = 0 ) return material . _get_orbital_list ( orbital_positions , grid )","title":"cut_flake_1d"},{"location":"api/#granad.materials.cut_flake_2d","text":"Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. polygon ( array - like ) \u2013 An array of coordinates defining the vertices of the polygon within which to cut the flake. plot ( bool , default: False ) \u2013 If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number ( int , default: 2 ) \u2013 The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list \u2013 A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Details The function first translates the polygon into the positive xy-plane to avoid negative coordinates, then calculates the extent of the grid needed to cover the polygon based on the material's lattice basis. Atom positions are then pruned based on the minimum neighbor count using the _prune_neighbors nested function, which iteratively prunes atoms until the neighbor count condition is met or no further pruning can be done. Source code in src/granad/materials.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def cut_flake_2d ( material , polygon , plot = False , minimum_neighbor_number : int = 2 ): \"\"\" Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material (Material): The material instance from which to cut the flake. polygon (array-like): An array of coordinates defining the vertices of the polygon within which to cut the flake. plot (bool, optional): If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number (int, optional): The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list: A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Details: The function first translates the polygon into the positive xy-plane to avoid negative coordinates, then calculates the extent of the grid needed to cover the polygon based on the material's lattice basis. Atom positions are then pruned based on the minimum neighbor count using the `_prune_neighbors` nested function, which iteratively prunes atoms until the neighbor count condition is met or no further pruning can be done. \"\"\" def _prune_neighbors ( positions , minimum_neighbor_number , remaining_old = jnp . inf ): \"\"\" Recursively prunes positions to ensure each position has a sufficient number of neighboring positions based on a minimum distance calculated from the unique set of distances between positions. Parameters: positions (array-like): Array of positions to prune. minimum_neighbor_number (int): Minimum required number of neighbors for a position to be retained. remaining_old (int): The count of positions remaining from the previous iteration; used to detect convergence. Returns: array-like: Array of positions that meet the neighbor count criterion. \"\"\" if minimum_neighbor_number <= 0 : return positions distances = jnp . round ( jnp . linalg . norm ( positions - positions [:, None ], axis =- 1 ), 4 ) minimum = jnp . unique ( distances )[ 1 ] mask = ( distances <= minimum ) . sum ( axis = 0 ) > minimum_neighbor_number remaining = mask . sum () if remaining_old == remaining : return positions [ mask ] else : return _prune_neighbors ( positions [ mask ], minimum_neighbor_number , remaining ) # shift the polygon into the positive xy plane min_values = jnp . min ( polygon , axis = 0 ) translation = jnp . where ( min_values < 0 , - min_values , 0 ) polygon += translation # we compute the maximum extension of the polyon max_values = jnp . max ( polygon , axis = 0 ) max_dim = max_values . argmax () max_vec = jnp . abs ( material . _lattice_basis )[ material . periodic , max_dim ] . argmax () n = max_values [ max_dim ] / material . _lattice_basis [ material . periodic ,:][ max_vec , max_dim ] . item () / 2 n_rounded = jnp . ceil ( jnp . abs ( n )) + 1 n = int ( jnp . sign ( n ) * n_rounded ) grid = material . _get_grid ( [ ( 0 , n ), ( 0 , n ) ] ) # get atom positions in the unit cell in fractional coordinates orbital_positions = material . _get_positions_in_uc () unit_cell_fractional_atom_positions = jnp . unique ( jnp . round ( orbital_positions , 6 ), axis = 0 ) # get all atom positions in a plane completely covering the polygon initial_atom_positions = material . _get_positions_in_lattice ( unit_cell_fractional_atom_positions , grid ) # get atom positions within the polygon polygon_path = Path ( polygon ) flags = polygon_path . contains_points ( initial_atom_positions [:, : 2 ]) # get atom positions where every atom has at least minimum_neighbor_number neighbors final_atom_positions = _prune_neighbors ( initial_atom_positions [ flags ], minimum_neighbor_number ) if plot == True : _display_lattice_cut ( initial_atom_positions , final_atom_positions , polygon ) return material . _get_orbital_list ( final_atom_positions , grid )","title":"cut_flake_2d"},{"location":"api/#granad.materials.cut_flake_generic","text":"Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material ( Material ) \u2013 The material instance from which to cut the flake. grid_range ( list of tuples ) \u2013 Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list \u2013 A list of orbitals within the specified grid range, uniquely positioned. Note The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. Source code in src/granad/materials.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def cut_flake_generic ( material , grid_range ): \"\"\" Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material (Material): The material instance from which to cut the flake. grid_range (list of tuples): Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list: A list of orbitals within the specified grid range, uniquely positioned. Note: The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. \"\"\" orbital_positions_uc = material . _get_positions_in_uc () grid = material . _get_grid ( grid_range ) orbital_positions = material . _get_positions_in_lattice ( orbital_positions_uc , grid ) orbital_positions = jnp . unique ( orbital_positions , axis = 0 ) return material . _get_orbital_list ( orbital_positions , grid )","title":"cut_flake_generic"},{"location":"api/#granad.shapes.Hexagon","text":"Generates the vertices of a regular hexagon given the side length. The hexagon is oriented such that one vertex points upwards and the function is designed to be used with the @_edge_type decorator for positional adjustments and rotations. Parameters: length ( float ) \u2013 The length of each side of the hexagon, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (7, 2), representing the vertices of the hexagon, including the starting vertex repeated at the end for drawing closed shapes. Example","title":"Hexagon"},{"location":"api/#granad.shapes.Hexagon--hexagon-with-side-length-of-10-angstrom","text":"hexagon = Hexagon(1.0) Source code in src/granad/shapes.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @_edge_type def Hexagon ( length ): \"\"\" Generates the vertices of a regular hexagon given the side length. The hexagon is oriented such that one vertex points upwards and the function is designed to be used with the @_edge_type decorator for positional adjustments and rotations. Parameters: length (float): The length of each side of the hexagon, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (7, 2), representing the vertices of the hexagon, including the starting vertex repeated at the end for drawing closed shapes. Example: # Hexagon with side length of 1.0 angstrom hexagon = Hexagon(1.0) \"\"\" n = 6 s = 1 angle = 2 * jnp . pi / n vertices = length * jnp . array ( [ ( s * jnp . cos ( i * angle ), s * jnp . sin ( i * angle )) for i in [ x for x in range ( n )] + [ 0 ] ] ) return vertices","title":"Hexagon with side length of 1.0 angstrom"},{"location":"api/#granad.shapes.Rectangle","text":"Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x ( float ) \u2013 The length of the rectangle along the x-axis, specified in angstroms. length_y ( float ) \u2013 The length of the rectangle along the y-axis, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Example","title":"Rectangle"},{"location":"api/#granad.shapes.Rectangle--rectangle-with-length-20-and-height-10-angstroms","text":"rectangle = Rectangle(2.0, 1.0) Source code in src/granad/shapes.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @_edge_type def Rectangle ( length_x , length_y ): \"\"\" Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x (float): The length of the rectangle along the x-axis, specified in angstroms. length_y (float): The length of the rectangle along the y-axis, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Example: # Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle(2.0, 1.0) \"\"\" vertices = jnp . array ( [ ( - 1 * length_x , - 0.5 * length_y ), ( 1 * length_x , - 0.5 * length_y ), ( 1 * length_x , 0.5 * length_y ), ( - 1 * length_x , 0.5 * length_y ), ( - 1 * length_x , - 0.5 * length_y ), ] ) return vertices","title":"Rectangle with length 2.0 and height 1.0 angstroms"},{"location":"api/#granad.shapes.Rhomboid","text":"Generates the vertices of a rhomboid given the base length and height. The rhomboid is initially oriented with the base along the x-axis, and one angle being 30 degrees, designed to be adjusted for position and orientation using the @_edge_type decorator. Parameters: base ( float ) \u2013 The length of the base of the rhomboid, specified in angstroms. height ( float ) \u2013 The vertical height of the rhomboid, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rhomboid, starting and ending at the same vertex to complete the shape. Example","title":"Rhomboid"},{"location":"api/#granad.shapes.Rhomboid--rhomboid-with-base-20-angstroms-and-height-10-angstrom","text":"rhomboid = Rhomboid(2.0, 1.0) Source code in src/granad/shapes.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 @_edge_type def Rhomboid ( base , height ): \"\"\" Generates the vertices of a rhomboid given the base length and height. The rhomboid is initially oriented with the base along the x-axis, and one angle being 30 degrees, designed to be adjusted for position and orientation using the @_edge_type decorator. Parameters: base (float): The length of the base of the rhomboid, specified in angstroms. height (float): The vertical height of the rhomboid, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rhomboid, starting and ending at the same vertex to complete the shape. Example: # Rhomboid with base 2.0 angstroms and height 1.0 angstrom rhomboid = Rhomboid(2.0, 1.0) \"\"\" angle = jnp . radians ( 30 ) vertices = jnp . array ( [ ( 0 , 0 ), ( base , 0 ), ( base + height * jnp . sin ( angle ), height * jnp . cos ( angle )), ( height * jnp . sin ( angle ), height * jnp . cos ( angle )), ( 0 , 0 ), ] ) return vertices","title":"Rhomboid with base 2.0 angstroms and height 1.0 angstrom"},{"location":"api/#granad.shapes.Triangle","text":"Generates the vertices of an equilateral triangle given the side length. The triangle is oriented such that one vertex points upwards and the base is horizontal. This function is designed to be used with the @_edge_type decorator, which adds functionality to shift the triangle's position or rotate it based on additional 'shift' and 'armchair' parameters passed to the function. Parameters: side_length ( float ) \u2013 The length of each side of the triangle, specified in angstroms. Returns: \u2013 jax.numpy.ndarray: An array of shape (4, 2), representing the vertices of the triangle, including the starting vertex repeated at the end to facilitate drawing closed shapes. Example","title":"Triangle"},{"location":"api/#granad.shapes.Triangle--create-a-triangle-with-side-length-of-10-angstrom-no-shift-or-rotation","text":"triangle = Triangle(1.0)","title":"Create a triangle with side length of 1.0 angstrom, no shift or rotation"},{"location":"api/#granad.shapes.Triangle--create-a-triangle-with-side-length-of-10-angstrom-shifted-by-1-1-units","text":"triangle_shifted = Triangle(1.0, shift=[1, 1])","title":"Create a triangle with side length of 1.0 angstrom, shifted by [1, 1] units"},{"location":"api/#granad.shapes.Triangle--create-a-triangle-with-side-length-of-10-angstrom-rotated-by-90-degrees-armchair-orientation","text":"triangle_rotated = Triangle(1.0, armchair=True) Source code in src/granad/shapes.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 @_edge_type def Triangle ( side_length ): \"\"\" Generates the vertices of an equilateral triangle given the side length. The triangle is oriented such that one vertex points upwards and the base is horizontal. This function is designed to be used with the @_edge_type decorator, which adds functionality to shift the triangle's position or rotate it based on additional 'shift' and 'armchair' parameters passed to the function. Parameters: side_length (float): The length of each side of the triangle, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (4, 2), representing the vertices of the triangle, including the starting vertex repeated at the end to facilitate drawing closed shapes. Example: # Create a triangle with side length of 1.0 angstrom, no shift or rotation triangle = Triangle(1.0) # Create a triangle with side length of 1.0 angstrom, shifted by [1, 1] units triangle_shifted = Triangle(1.0, shift=[1, 1]) # Create a triangle with side length of 1.0 angstrom, rotated by 90 degrees (armchair orientation) triangle_rotated = Triangle(1.0, armchair=True) \"\"\" vertices = side_length * jnp . array ( [ ( 0 , jnp . sqrt ( 3 ) / 3 ), ( - 0.5 , - jnp . sqrt ( 3 ) / 6 ), ( 0.5 , - jnp . sqrt ( 3 ) / 6 ), ( 0 , jnp . sqrt ( 3 ) / 3 ), ] ) return vertices","title":"Create a triangle with side length of 1.0 angstrom, rotated by 90 degrees (armchair orientation)"},{"location":"units/","text":"Units GRANAD uses the following unit conventions Quantity Unit Energy eV Distance \u00c5ngstr\u00f6m Time \\(0.659 \\cdot 10^{-15}\\) s Charge \\(1.6 \\cdot 10^{-19}\\) C Electric field strength \\(10^{10}\\) V/m","title":"Units"},{"location":"units/#units","text":"GRANAD uses the following unit conventions Quantity Unit Energy eV Distance \u00c5ngstr\u00f6m Time \\(0.659 \\cdot 10^{-15}\\) s Charge \\(1.6 \\cdot 10^{-19}\\) C Electric field strength \\(10^{10}\\) V/m","title":"Units"},{"location":"tutorials/cutting/","text":"4. Cutting Cutting Any material defines a cutting function, but they differ by dimensionality. To see why, let's inspect from granad import MaterialCatalog ssh = MaterialCatalog . get ( \"ssh\" ) help ( ssh . cut_flake ) Help on method cut_flake in module granad.materials: cut_flake() method of granad.materials.Material instance Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. So, the cut_flake method is automatically determined. Let's look at the 1D case from granad.materials import cut_flake_1d help ( cut_flake_1d ) Help on function cut_flake_1d in module granad.materials: cut_flake_1d(material, unit_cells, plot=False) Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material (Material): The material instance from which to cut the flake. unit_cells (int): The number of unit cells to include in the flake. plot (bool, optional): If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list: A list of orbitals positioned within the specified range of the material's lattice. Note: The function utilizes internal methods of the `Material` class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. So we just need to specify the number of unit cells. flake = ssh . cut_flake ( unit_cells = 40 , plot = False ) You may notice this is the configuration with edge states in the band gap flake . show_energies () If you don't want this, just delete the edges by removing the first and the last orbital in the list del flake [ 0 ] del flake [ - 1 ] flake . show_2d () flake . show_energies () That's pretty much all about cutting in 1D. Let's cover 2D. from granad.materials import cut_flake_2d help ( cut_flake_2d ) Help on function cut_flake_2d in module granad.materials: cut_flake_2d(material, polygon, plot=False, minimum_neighbor_number: int = 2) Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material (Material): The material instance from which to cut the flake. polygon (array-like): An array of coordinates defining the vertices of the polygon within which to cut the flake. plot (bool, optional): If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number (int, optional): The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list: A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Details: The function first translates the polygon into the positive xy-plane to avoid negative coordinates, then calculates the extent of the grid needed to cover the polygon based on the material's lattice basis. Atom positions are then pruned based on the minimum neighbor count using the `_prune_neighbors` nested function, which iteratively prunes atoms until the neighbor count condition is met or no further pruning can be done. This is more complex. We can give an arbitrary polygon to the cutting function, so let's do this by approximating a potato (this is an internal joke in Carsten's group). import jax.numpy as jnp potato = 10 * jnp . array ( [ ( 3 , 1 ), # Bottom center (widest point) ( 2 , 2 ), # Lower left bulge ( 1 , 3 ), # Mid left indent ( 2 , 4 ), # Upper left bulge ( 3 , 5 ), # Top center ( 4 , 4 ), # Upper right bulge ( 5 , 3 ), # Mid right indent ( 4 , 2 ), # Lower right bulge ( 3 , 1 ) # Connect back to the bottom center ]) Now, we cut a flake graphene = MaterialCatalog . get ( \"graphene\" ) flake = graphene . cut_flake ( potato , plot = True ) Shapes Built-in shapes are a bit more boring: they are just functions returning a set of vertices. All parameters you pass to them are in Angstr\u00f6m. from granad import Rectangle help ( Rectangle ) Help on function Rectangle in module granad.shapes: Rectangle(length_x, length_y) Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x (float): The length of the rectangle along the x-axis, specified in angstroms. length_y (float): The length of the rectangle along the y-axis, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Example: # Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle(2.0, 1.0) Bearded configurations Cutting removes \"dangling\" atoms by default. Dangling atoms are defined by their neighbor number: if they have only one neighbor, they are removed. If you want to deactivate this to keep \"bearded\" configurations, do flake = graphene . cut_flake ( Rectangle ( 10 , 10 ), plot = True , minimum_neighbor_number = 0 )","title":"4. Cutting"},{"location":"tutorials/cutting/#4-cutting","text":"","title":"4. Cutting"},{"location":"tutorials/cutting/#cutting","text":"Any material defines a cutting function, but they differ by dimensionality. To see why, let's inspect from granad import MaterialCatalog ssh = MaterialCatalog . get ( \"ssh\" ) help ( ssh . cut_flake ) Help on method cut_flake in module granad.materials: cut_flake() method of granad.materials.Material instance Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. So, the cut_flake method is automatically determined. Let's look at the 1D case from granad.materials import cut_flake_1d help ( cut_flake_1d ) Help on function cut_flake_1d in module granad.materials: cut_flake_1d(material, unit_cells, plot=False) Cuts a one-dimensional flake from the material based on the specified number of unit cells and optionally plots the lattice and orbital positions. Parameters: material (Material): The material instance from which to cut the flake. unit_cells (int): The number of unit cells to include in the flake. plot (bool, optional): If True, displays a plot of the orbital positions within the lattice. Default is False. Returns: list: A list of orbitals positioned within the specified range of the material's lattice. Note: The function utilizes internal methods of the `Material` class to compute positions and retrieve orbital data, ensuring that the positions are unique and correctly mapped to the material's grid. So we just need to specify the number of unit cells. flake = ssh . cut_flake ( unit_cells = 40 , plot = False ) You may notice this is the configuration with edge states in the band gap flake . show_energies () If you don't want this, just delete the edges by removing the first and the last orbital in the list del flake [ 0 ] del flake [ - 1 ] flake . show_2d () flake . show_energies () That's pretty much all about cutting in 1D. Let's cover 2D. from granad.materials import cut_flake_2d help ( cut_flake_2d ) Help on function cut_flake_2d in module granad.materials: cut_flake_2d(material, polygon, plot=False, minimum_neighbor_number: int = 2) Cuts a two-dimensional flake from the material defined within the bounds of a specified polygon. It further prunes the positions to ensure that each atom has at least the specified minimum number of neighbors. Optionally, the function can plot the initial and final positions of the atoms within the polygon. Parameters: material (Material): The material instance from which to cut the flake. polygon (array-like): An array of coordinates defining the vertices of the polygon within which to cut the flake. plot (bool, optional): If True, plots the lattice and the positions of atoms before and after pruning. Default is False. minimum_neighbor_number (int, optional): The minimum number of neighbors each atom must have to remain in the final positions. Default is 2. Returns: list: A list of orbitals positioned within the specified polygon and satisfying the neighbor condition. Details: The function first translates the polygon into the positive xy-plane to avoid negative coordinates, then calculates the extent of the grid needed to cover the polygon based on the material's lattice basis. Atom positions are then pruned based on the minimum neighbor count using the `_prune_neighbors` nested function, which iteratively prunes atoms until the neighbor count condition is met or no further pruning can be done. This is more complex. We can give an arbitrary polygon to the cutting function, so let's do this by approximating a potato (this is an internal joke in Carsten's group). import jax.numpy as jnp potato = 10 * jnp . array ( [ ( 3 , 1 ), # Bottom center (widest point) ( 2 , 2 ), # Lower left bulge ( 1 , 3 ), # Mid left indent ( 2 , 4 ), # Upper left bulge ( 3 , 5 ), # Top center ( 4 , 4 ), # Upper right bulge ( 5 , 3 ), # Mid right indent ( 4 , 2 ), # Lower right bulge ( 3 , 1 ) # Connect back to the bottom center ]) Now, we cut a flake graphene = MaterialCatalog . get ( \"graphene\" ) flake = graphene . cut_flake ( potato , plot = True )","title":"Cutting"},{"location":"tutorials/cutting/#shapes","text":"Built-in shapes are a bit more boring: they are just functions returning a set of vertices. All parameters you pass to them are in Angstr\u00f6m. from granad import Rectangle help ( Rectangle ) Help on function Rectangle in module granad.shapes: Rectangle(length_x, length_y) Generates the vertices of a rectangle given the lengths along the x and y dimensions. The rectangle is centered at the origin, and the function is designed to be used with the @_edge_type decorator, allowing for positional shifts and rotations (if specified). Parameters: length_x (float): The length of the rectangle along the x-axis, specified in angstroms. length_y (float): The length of the rectangle along the y-axis, specified in angstroms. Returns: jax.numpy.ndarray: An array of shape (5, 2), representing the vertices of the rectangle, starting and ending at the same vertex to facilitate drawing closed shapes. Example: # Rectangle with length 2.0 and height 1.0 angstroms rectangle = Rectangle(2.0, 1.0)","title":"Shapes"},{"location":"tutorials/cutting/#bearded-configurations","text":"Cutting removes \"dangling\" atoms by default. Dangling atoms are defined by their neighbor number: if they have only one neighbor, they are removed. If you want to deactivate this to keep \"bearded\" configurations, do flake = graphene . cut_flake ( Rectangle ( 10 , 10 ), plot = True , minimum_neighbor_number = 0 )","title":"Bearded configurations"},{"location":"tutorials/defining_materials/","text":"9. Defining Materials We talk about how to modify built-in materials and define custom ones. Defining a custom material Let's first look at the Material class itself from granad import MaterialCatalog , Material , Hexagon print ( Material . __doc__ ) Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name (str): The name of the material. species (dict): Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals (defaultdict[list]): A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions (defaultdict[dict]): Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hopping', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Usage: The `Material` class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hopping and Coulomb interactions among these orbitals. Example: graphene = ( Material(\"graphene\") .lattice_constant(2.46) .lattice_basis([ [1, 0, 0], [-0.5, jnp.sqrt(3)/2, 0] ]) .add_orbital_species(\"pz\", l=1, atom='C') .add_orbital(position=(0, 0), tag=\"sublattice_1\", species=\"pz\") .add_orbital(position=(-1/3, -2/3), tag=\"sublattice_2\", species=\"pz\") .add_interaction( \"hopping\", participants=(\"pz\", \"pz\"), parameters=[0.0, 2.66], # no expression given => we online look at onsite and nearest neighbors ) .add_interaction( \"coulomb\", participants=(\"pz\", \"pz\"), parameters=[16.522, 8.64, 5.333], # we look at onsite, nn, nnn couplings expression=lambda d: 14.399 / d # for nnnn and more, we apply the coulomb law ) ) So, the Material class essentially defines a small language we can use to specify a material. The Hubbard model would look like this t = 1. # nearest-neighbor hopping U = 0.1 # onsite coulomb repulsion hubbard = ( Material ( \"Hubbard\" ) . lattice_constant ( 1.0 ) . lattice_basis ([ [ 1 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , 0 , 1 ] ]) . add_orbital_species ( \"up\" , s = - 1 ) . add_orbital_species ( \"down\" , s = 1 ) . add_orbital ( position = ( 0 , 0 , 0 ), species = \"up\" ) . add_orbital ( position = ( 0 , 0 , 0 ), species = \"down\" ) . add_interaction ( \"hopping\" , participants = ( \"up\" , \"up\" ), parameters = [ 0.0 , t ], ) . add_interaction ( \"hopping\" , participants = ( \"down\" , \"down\" ), parameters = [ 0.0 , t ], ) . add_interaction ( \"coulomb\" , participants = ( \"up\" , \"down\" ), parameters = [ U ] ) ) To see how cutting finite flakes from this 3D material works, let's inspect help ( hubbard . cut_flake ) Help on method cut_flake in module granad.materials: cut_flake() method of granad.materials.Material instance Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. So, the cut_flake method is automatically determined. We have specified a 3D material, so let's look at the function that is applied from granad.materials import cut_flake_generic help ( cut_flake_generic ) Help on function cut_flake_generic in module granad.materials: cut_flake_generic(material, grid_range) Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material (Material): The material instance from which to cut the flake. grid_range (list of tuples): Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list: A list of orbitals within the specified grid range, uniquely positioned. Note: The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. Let's see this in action flake = hubbard . cut_flake ( [( 0 , 3 ), ( 0 , 3 ), ( 0 , 3 )] ) # 3*3*3 = 27 unit cells, 3 in every direction, each hosting spin up and spin down atom flake . show_3d () No artists with labels found to put in legend. Note that artists whose label start with an underscore are ignored when legend() is called with no argument. Modifying existing materials You can just copy the material you want to modify and change/override its attributes. As an example, we will turn our ordinary graphene model into a variant of the Haldane model by introducing complex nnn hoppings from copy import deepcopy graphene = MaterialCatalog . get ( \"graphene\" ) graphene_haldane = deepcopy ( graphene ) graphene_haldane . add_interaction ( \"hopping\" , participants = ( 'pz' , 'pz' ), parameters = [ 0 , 1.0 , 1 j * 0.1 ]) print ( graphene_haldane ) Material: graphene Lattice Constant: 2.46 \u00c5 Lattice Basis: [[ 1. 0. 0. ] [-0.5 0.8660254 0. ]] Orbital Species: pz characterized by (n,l,m,s, atom name) = (0, 1, 0, 0, 'C') Orbitals: Position: (0, 0), Tag: sublattice_1, Species: pz Position: (-0.3333333333333333, -0.6666666666666666), Tag: sublattice_2, Species: pz Interactions: Type: hopping, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([0, 1.0, 0.1j], <function Material.add_interaction.<locals>.<lambda> at 0x7f48b4a63380>) Type: coulomb, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([16.522, 8.64, 5.333], <function Material.add_interaction.<locals>.<lambda> at 0x7f48bc8aa700>) The Haldane model breaks inversion symmetry explicity by a staggered onsite potential. There is no (nice) way to achieve this with a few modifications from the normal graphene model, so we simply use the versatile properties of the orbital list datatype when we cut finite flakes hexagon = Hexagon ( 30 , armchair = False ) flake_topological = graphene_haldane . cut_flake ( hexagon , plot = True ) delta = 0.3 for orb_1 in [ orb for orb in flake_topological if orb . tag == 'sublattice_1' ]: flake_topological . set_hamiltonian_element ( orb_1 , orb_1 , delta ) We now display the edge state import jax.numpy as jnp idx = jnp . argwhere ( jnp . abs ( flake_topological . energies ) < 1e-2 )[ 0 ] . item () flake_topological . show_2d ( display = flake_topological . eigenvectors [:, idx ] )","title":"9. Defining Materials"},{"location":"tutorials/defining_materials/#9-defining-materials","text":"We talk about how to modify built-in materials and define custom ones.","title":"9. Defining Materials"},{"location":"tutorials/defining_materials/#defining-a-custom-material","text":"Let's first look at the Material class itself from granad import MaterialCatalog , Material , Hexagon print ( Material . __doc__ ) Represents a material in a simulation, encapsulating its physical properties and interactions. Attributes: name (str): The name of the material. species (dict): Dictionary mapping species names to their quantum numbers and associated atoms. Each species is defined with properties like principal quantum number (n), angular momentum quantum number (l), magnetic quantum number (m), spin quantum number (s), and the atom type. orbitals (defaultdict[list]): A mapping from species to lists of orbitals. Each orbital is represented as a dictionary containing the orbital's position and an optional tag for further identification. interactions (defaultdict[dict]): Describes the interactions between orbitals within the material. Each interaction is categorized by type (e.g., 'hopping', 'Coulomb'), and includes the participants, parameters like [onsite, offsite_nearest_neighbor, offsite_next_to_nearest_neighbor, ...], and an optional mathematical expression defining the interaction for the coupling beyound the len(parameters) - th nearest neighbor. Usage: The `Material` class is used to define a material's structure and properties step-by-step. An example is constructing the material graphene, with specific lattice properties, orbitals corresponding to carbon's p_z orbitals, and defining hopping and Coulomb interactions among these orbitals. Example: graphene = ( Material(\"graphene\") .lattice_constant(2.46) .lattice_basis([ [1, 0, 0], [-0.5, jnp.sqrt(3)/2, 0] ]) .add_orbital_species(\"pz\", l=1, atom='C') .add_orbital(position=(0, 0), tag=\"sublattice_1\", species=\"pz\") .add_orbital(position=(-1/3, -2/3), tag=\"sublattice_2\", species=\"pz\") .add_interaction( \"hopping\", participants=(\"pz\", \"pz\"), parameters=[0.0, 2.66], # no expression given => we online look at onsite and nearest neighbors ) .add_interaction( \"coulomb\", participants=(\"pz\", \"pz\"), parameters=[16.522, 8.64, 5.333], # we look at onsite, nn, nnn couplings expression=lambda d: 14.399 / d # for nnnn and more, we apply the coulomb law ) ) So, the Material class essentially defines a small language we can use to specify a material. The Hubbard model would look like this t = 1. # nearest-neighbor hopping U = 0.1 # onsite coulomb repulsion hubbard = ( Material ( \"Hubbard\" ) . lattice_constant ( 1.0 ) . lattice_basis ([ [ 1 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , 0 , 1 ] ]) . add_orbital_species ( \"up\" , s = - 1 ) . add_orbital_species ( \"down\" , s = 1 ) . add_orbital ( position = ( 0 , 0 , 0 ), species = \"up\" ) . add_orbital ( position = ( 0 , 0 , 0 ), species = \"down\" ) . add_interaction ( \"hopping\" , participants = ( \"up\" , \"up\" ), parameters = [ 0.0 , t ], ) . add_interaction ( \"hopping\" , participants = ( \"down\" , \"down\" ), parameters = [ 0.0 , t ], ) . add_interaction ( \"coulomb\" , participants = ( \"up\" , \"down\" ), parameters = [ U ] ) ) To see how cutting finite flakes from this 3D material works, let's inspect help ( hubbard . cut_flake ) Help on method cut_flake in module granad.materials: cut_flake() method of granad.materials.Material instance Finalizes the material construction by defining a method to cut a flake of the material, according to the material's dimensions like this 1D material : materials.cut_flake_1d 2D material : materials.cut_flake_2d 3D material and higher : materials.cut_flake_generic This method is intended to be called after all material properties (like lattice constants, basis, orbitals, and interactions) have been fully defined. Note: This method does not take any parameters and does not return any value. Its effect is internal to the state of the Material object and is meant to prepare the material for simulation by implementing necessary final structural adjustments. So, the cut_flake method is automatically determined. We have specified a 3D material, so let's look at the function that is applied from granad.materials import cut_flake_generic help ( cut_flake_generic ) Help on function cut_flake_generic in module granad.materials: cut_flake_generic(material, grid_range) Cuts a flake from the material using a specified grid range. This method is generic and can be applied to materials of any dimensionality. The function calculates the positions of orbitals within the unit cell, projects these onto the full lattice based on the provided grid range, and ensures that each position is unique. The result is a list of orbitals that are correctly positioned within the defined grid. Parameters: material (Material): The material instance from which to cut the flake. grid_range (list of tuples): Each tuple in the list specifies the range for the grid in that dimension. For example, [(0, 10), (0, 5)] defines a grid that extends from 0 to 10 in the first dimension and from 0 to 5 in the second dimension. Returns: list: A list of orbitals within the specified grid range, uniquely positioned. Note: The grid_range parameter should be aligned with the material's dimensions and lattice structure, as mismatches can lead to incorrect or inefficient slicing of the material. Let's see this in action flake = hubbard . cut_flake ( [( 0 , 3 ), ( 0 , 3 ), ( 0 , 3 )] ) # 3*3*3 = 27 unit cells, 3 in every direction, each hosting spin up and spin down atom flake . show_3d () No artists with labels found to put in legend. Note that artists whose label start with an underscore are ignored when legend() is called with no argument.","title":"Defining a custom material"},{"location":"tutorials/defining_materials/#modifying-existing-materials","text":"You can just copy the material you want to modify and change/override its attributes. As an example, we will turn our ordinary graphene model into a variant of the Haldane model by introducing complex nnn hoppings from copy import deepcopy graphene = MaterialCatalog . get ( \"graphene\" ) graphene_haldane = deepcopy ( graphene ) graphene_haldane . add_interaction ( \"hopping\" , participants = ( 'pz' , 'pz' ), parameters = [ 0 , 1.0 , 1 j * 0.1 ]) print ( graphene_haldane ) Material: graphene Lattice Constant: 2.46 \u00c5 Lattice Basis: [[ 1. 0. 0. ] [-0.5 0.8660254 0. ]] Orbital Species: pz characterized by (n,l,m,s, atom name) = (0, 1, 0, 0, 'C') Orbitals: Position: (0, 0), Tag: sublattice_1, Species: pz Position: (-0.3333333333333333, -0.6666666666666666), Tag: sublattice_2, Species: pz Interactions: Type: hopping, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([0, 1.0, 0.1j], <function Material.add_interaction.<locals>.<lambda> at 0x7f48b4a63380>) Type: coulomb, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([16.522, 8.64, 5.333], <function Material.add_interaction.<locals>.<lambda> at 0x7f48bc8aa700>) The Haldane model breaks inversion symmetry explicity by a staggered onsite potential. There is no (nice) way to achieve this with a few modifications from the normal graphene model, so we simply use the versatile properties of the orbital list datatype when we cut finite flakes hexagon = Hexagon ( 30 , armchair = False ) flake_topological = graphene_haldane . cut_flake ( hexagon , plot = True ) delta = 0.3 for orb_1 in [ orb for orb in flake_topological if orb . tag == 'sublattice_1' ]: flake_topological . set_hamiltonian_element ( orb_1 , orb_1 , delta ) We now display the edge state import jax.numpy as jnp idx = jnp . argwhere ( jnp . abs ( flake_topological . energies ) < 1e-2 )[ 0 ] . item () flake_topological . show_2d ( display = flake_topological . eigenvectors [:, idx ] )","title":"Modifying existing materials"},{"location":"tutorials/electric_fields/","text":"5. Electric Fields We present how to handle electric fields The built-in electric fields are just callables, dependent on time. import jax import jax.numpy as jnp import matplotlib.pyplot as plt from granad import Wave help ( Wave ) Help on function Wave in module granad.fields: Wave(amplitudes: list[float], frequency: float) Function for computing time-harmonic electric fields. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency **Returns:** Function that computes the electric field as a functon of time So, calling \"Wave\" gives back a function we can evaluate at single points in time wave = Wave ( [ 1 , 0 , 0 ], 1 ) print ( wave ( 0 )) [1.+0.j 0.+0.j 0.+0.j] A quick way to visualize them is to plot their real and imaginary part. JAX offers the vmap function that vectorizes the application. time = jnp . linspace ( 0 , 2 * 2 * jnp . pi , 100 ) e_field = jax . vmap ( wave ) ( time ) print ( e_field . shape ) (100, 3) plt . plot ( time , e_field . real ) plt . plot ( time , e_field . imag , '--' ) plt . show ()","title":"5. Electric Fields"},{"location":"tutorials/electric_fields/#5-electric-fields","text":"We present how to handle electric fields The built-in electric fields are just callables, dependent on time. import jax import jax.numpy as jnp import matplotlib.pyplot as plt from granad import Wave help ( Wave ) Help on function Wave in module granad.fields: Wave(amplitudes: list[float], frequency: float) Function for computing time-harmonic electric fields. - `amplitudes`: electric field amplitudes in xyz-components - `frequency`: frequency **Returns:** Function that computes the electric field as a functon of time So, calling \"Wave\" gives back a function we can evaluate at single points in time wave = Wave ( [ 1 , 0 , 0 ], 1 ) print ( wave ( 0 )) [1.+0.j 0.+0.j 0.+0.j] A quick way to visualize them is to plot their real and imaginary part. JAX offers the vmap function that vectorizes the application. time = jnp . linspace ( 0 , 2 * 2 * jnp . pi , 100 ) e_field = jax . vmap ( wave ) ( time ) print ( e_field . shape ) (100, 3) plt . plot ( time , e_field . real ) plt . plot ( time , e_field . imag , '--' ) plt . show ()","title":"5. Electric Fields"},{"location":"tutorials/getting_started/","text":"1. Getting started We introduce the basics of GRANAD and do a quick simulation. Orbitals At its core, GRANAD is all about orbitals. Let's create one at the origin and inspect it. from granad import Orbital my_first_orbital = Orbital ( position = ( 0 , 0 , 0 ), tag = \"a tag contains arbitrary information\" , ) print ( my_first_orbital ) {'position': Array([0., 0., 0.], dtype=float64), 'layer_index': None, 'tag': 'a tag contains arbitrary information', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 1} The group_id, unsurprisingly, groups orbitals. For example: if you create a two-level adatom, you need two orbitals that share the same group_id. In the same way, all orbitals in a graphene sheet share the same group_id. my_second_orbital = Orbital ( position = ( 1 , 1 , 1 ), tag = \"a new, shifted orbital\" , ) print ( my_second_orbital ) {'position': Array([1., 1., 1.], dtype=float64), 'layer_index': None, 'tag': 'a new, shifted orbital', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 2} This is all there is to know about orbitals! Materials Materials are stuff you can cut orbitals from. You can define one yourself or import a prebuilt one. We will use the latter option. from granad import MaterialCatalog MaterialCatalog . available () Available materials: graphene ssh metal_1d Let's inspect a material. MaterialCatalog . describe ( \"graphene\" ) Material: graphene Lattice Constant: 2.46 \u00c5 Lattice Basis: [[ 1. 0. 0. ] [-0.5 0.8660254 0. ]] Orbital Species: pz characterized by (n,l,m,s, atom name) = (0, 1, 0, 0, 'C') Orbitals: Position: (0, 0), Tag: sublattice_1, Species: pz Position: (-0.3333333333333333, -0.6666666666666666), Tag: sublattice_2, Species: pz Interactions: Type: hopping, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([0.0, 2.66], <function Material.add_interaction.<locals>.<lambda> at 0x7f6f44075f80>) Type: coulomb, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([16.522, 8.64, 5.333], <function Material.add_interaction.<locals>.<lambda> at 0x7f6f44076700>) There are parameters regarding the geometry, the type of the involved orbitals (the built-in graphene model contains only a single spin polarized pz orbital) , the position of orbitals in the unit cell and the interactions (currently, GRANAD supports hoppings and Coulomb interactions). Let's pick a concrete material. graphene = MaterialCatalog . get ( \"graphene\" ) OrbitalLists OrbitalLists are the last class you need to know. Unsurprisingly, an OrbitalList is a list of orbitals. You can create one yourself from the two orbitals you created above from granad import OrbitalList my_first_orbital_list = OrbitalList ([ my_first_orbital , my_second_orbital ]) print ( my_first_orbital_list ) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals Alternatively, you get orbital lists if you cut a flake from a material. You do this by specifying the shape of the flake. You can specify any shape you want, but this is covered in a separate tutorial. For now, we will use a built-in shape: an equilateral triangle with a side length of 15 Angstr\u00f6m. from granad import Triangle import jax.numpy as jnp triangle = Triangle ( 15 , armchair = True ) Now, our shape is ready and we can start cutting. To make sure that we are satisfied with what we get, we plot the flake. By default, GRANAD cuts any \"dangling\" atoms. my_first_flake = graphene . cut_flake ( triangle , plot = False ) print ( my_first_flake ) List with 26 orbitals, 26 electrons. [0] electrons excited from [0] to [0]. group id 3 : 26 orbitals For more information on cutting, including different edge types and how to keep dangling atoms, have a look at the corresponding tutorial. A first simulation To get a feeling of the setup, we first inspect the energies of the flake my_first_flake . show_energies () Physical observables are expectation values of Hermitian operators. GRANAD offers access to the time-resolved density matrix \\(\\rho(t)\\) of a system by integrating a nonlinear master equation. As a result, it is possible to track the evolution of the physical observable associated with a Hermitian operator \\(A\\) by computing \\(a(t) = Tr[\\rho(t) A]\\) . Optical properties in particular are largely determined by the polarization or dipole operator \\(\\hat{P}\\) and they are usually expressed in frequency domain. To this end, GRANAD offers a way to compute the Fourier transform \\(a(\\omega)\\) directly after time propagation. We will look at an example tracking the time evolution of the dipole operator below, where the computation proceeds in two steps: Excite the flake with an electric field. Compute its dipole moment \\(p(\\omega)\\) from the expectation value of its dipole operator. We first do step 1. To obtain a broad frequency spectrum, we must pick a narrow pulse in time-domain from granad import Pulse my_first_illumination = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) For step 2, a few parameters have to be chosen Simulation duration: we go from 0 to 40 in 1e5 steps. Relaxation rate: this is \\(r\\) in the dissipation term \\(D[\\rho] = r \\cdot(\\rho - \\rho_0)\\) in the master equation. Frequency domain limits: we choose the interval [0, 16]. Density matrix sampling rate: producing 1e5 density matrices can quickly exhaust RAM ressources. So we only save every 100th density matrix, such that we get 1000 density matrices. A simulation is just passing all of these parameters to the corresponding method of our flake. omegas , dipole_omega , pulse_omega = my_first_flake . get_expectation_value_frequency_domain ( operator = my_first_flake . dipole_operator , end_time = 40 , steps_time = 1e5 , relaxation_rate = 1 / 10 , illumination = my_first_illumination , omega_min = 0 , omega_max = 10 , skip = 100 , ) We see that three variables are returned: the omega axis we have specified, the dipole moment and the pulse in freqeuency domain. There is no way to control the number of points in the omega axis, because it is the result of a Fourier transform. We now plot the dipole moment and the pulse in frequency domain. import matplotlib.pyplot as plt plt . plot ( omegas , dipole_omega ) plt . plot ( omegas , pulse_omega , \"--\" ) plt . show ()","title":"1. Getting started"},{"location":"tutorials/getting_started/#1-getting-started","text":"We introduce the basics of GRANAD and do a quick simulation.","title":"1. Getting started"},{"location":"tutorials/getting_started/#orbitals","text":"At its core, GRANAD is all about orbitals. Let's create one at the origin and inspect it. from granad import Orbital my_first_orbital = Orbital ( position = ( 0 , 0 , 0 ), tag = \"a tag contains arbitrary information\" , ) print ( my_first_orbital ) {'position': Array([0., 0., 0.], dtype=float64), 'layer_index': None, 'tag': 'a tag contains arbitrary information', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 1} The group_id, unsurprisingly, groups orbitals. For example: if you create a two-level adatom, you need two orbitals that share the same group_id. In the same way, all orbitals in a graphene sheet share the same group_id. my_second_orbital = Orbital ( position = ( 1 , 1 , 1 ), tag = \"a new, shifted orbital\" , ) print ( my_second_orbital ) {'position': Array([1., 1., 1.], dtype=float64), 'layer_index': None, 'tag': 'a new, shifted orbital', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 2} This is all there is to know about orbitals!","title":"Orbitals"},{"location":"tutorials/getting_started/#materials","text":"Materials are stuff you can cut orbitals from. You can define one yourself or import a prebuilt one. We will use the latter option. from granad import MaterialCatalog MaterialCatalog . available () Available materials: graphene ssh metal_1d Let's inspect a material. MaterialCatalog . describe ( \"graphene\" ) Material: graphene Lattice Constant: 2.46 \u00c5 Lattice Basis: [[ 1. 0. 0. ] [-0.5 0.8660254 0. ]] Orbital Species: pz characterized by (n,l,m,s, atom name) = (0, 1, 0, 0, 'C') Orbitals: Position: (0, 0), Tag: sublattice_1, Species: pz Position: (-0.3333333333333333, -0.6666666666666666), Tag: sublattice_2, Species: pz Interactions: Type: hopping, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([0.0, 2.66], <function Material.add_interaction.<locals>.<lambda> at 0x7f6f44075f80>) Type: coulomb, Participants: ('pz', 'pz'), Couplings (neighbor, function): ([16.522, 8.64, 5.333], <function Material.add_interaction.<locals>.<lambda> at 0x7f6f44076700>) There are parameters regarding the geometry, the type of the involved orbitals (the built-in graphene model contains only a single spin polarized pz orbital) , the position of orbitals in the unit cell and the interactions (currently, GRANAD supports hoppings and Coulomb interactions). Let's pick a concrete material. graphene = MaterialCatalog . get ( \"graphene\" )","title":"Materials"},{"location":"tutorials/getting_started/#orbitallists","text":"OrbitalLists are the last class you need to know. Unsurprisingly, an OrbitalList is a list of orbitals. You can create one yourself from the two orbitals you created above from granad import OrbitalList my_first_orbital_list = OrbitalList ([ my_first_orbital , my_second_orbital ]) print ( my_first_orbital_list ) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals Alternatively, you get orbital lists if you cut a flake from a material. You do this by specifying the shape of the flake. You can specify any shape you want, but this is covered in a separate tutorial. For now, we will use a built-in shape: an equilateral triangle with a side length of 15 Angstr\u00f6m. from granad import Triangle import jax.numpy as jnp triangle = Triangle ( 15 , armchair = True ) Now, our shape is ready and we can start cutting. To make sure that we are satisfied with what we get, we plot the flake. By default, GRANAD cuts any \"dangling\" atoms. my_first_flake = graphene . cut_flake ( triangle , plot = False ) print ( my_first_flake ) List with 26 orbitals, 26 electrons. [0] electrons excited from [0] to [0]. group id 3 : 26 orbitals For more information on cutting, including different edge types and how to keep dangling atoms, have a look at the corresponding tutorial.","title":"OrbitalLists"},{"location":"tutorials/getting_started/#a-first-simulation","text":"To get a feeling of the setup, we first inspect the energies of the flake my_first_flake . show_energies () Physical observables are expectation values of Hermitian operators. GRANAD offers access to the time-resolved density matrix \\(\\rho(t)\\) of a system by integrating a nonlinear master equation. As a result, it is possible to track the evolution of the physical observable associated with a Hermitian operator \\(A\\) by computing \\(a(t) = Tr[\\rho(t) A]\\) . Optical properties in particular are largely determined by the polarization or dipole operator \\(\\hat{P}\\) and they are usually expressed in frequency domain. To this end, GRANAD offers a way to compute the Fourier transform \\(a(\\omega)\\) directly after time propagation. We will look at an example tracking the time evolution of the dipole operator below, where the computation proceeds in two steps: Excite the flake with an electric field. Compute its dipole moment \\(p(\\omega)\\) from the expectation value of its dipole operator. We first do step 1. To obtain a broad frequency spectrum, we must pick a narrow pulse in time-domain from granad import Pulse my_first_illumination = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) For step 2, a few parameters have to be chosen Simulation duration: we go from 0 to 40 in 1e5 steps. Relaxation rate: this is \\(r\\) in the dissipation term \\(D[\\rho] = r \\cdot(\\rho - \\rho_0)\\) in the master equation. Frequency domain limits: we choose the interval [0, 16]. Density matrix sampling rate: producing 1e5 density matrices can quickly exhaust RAM ressources. So we only save every 100th density matrix, such that we get 1000 density matrices. A simulation is just passing all of these parameters to the corresponding method of our flake. omegas , dipole_omega , pulse_omega = my_first_flake . get_expectation_value_frequency_domain ( operator = my_first_flake . dipole_operator , end_time = 40 , steps_time = 1e5 , relaxation_rate = 1 / 10 , illumination = my_first_illumination , omega_min = 0 , omega_max = 10 , skip = 100 , ) We see that three variables are returned: the omega axis we have specified, the dipole moment and the pulse in freqeuency domain. There is no way to control the number of points in the omega axis, because it is the result of a Fourier transform. We now plot the dipole moment and the pulse in frequency domain. import matplotlib.pyplot as plt plt . plot ( omegas , dipole_omega ) plt . plot ( omegas , pulse_omega , \"--\" ) plt . show ()","title":"A first simulation"},{"location":"tutorials/linear_response/","text":"8. Linear response We will calculate the optical absorption in the RPA and compare it to TD simulations with a weak external field. RPA First, we set up the RPA simulation. We will consider a small triangle such that the required simulation time stays in the seconds range. import jax.numpy as jnp from granad import MaterialCatalog , Triangle # get material graphene = MaterialCatalog . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ) ) # frequencies omegas_rpa = jnp . linspace ( 0 , 5 , 40 ) We obtain the polarizability for an external \\(x\\) polarized field and from its imaginary part the absorption. polarizability = flake . get_polarizability_rpa ( omegas_rpa , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 ) absorption_rpa = jnp . abs ( polarizability . imag * 4 * jnp . pi * omegas_rpa ) TD For the TD simulations, we specify a spectrally broad external illumination (i.e. a narrow pulse in time domain) to capture the system's response over a large frequency range. from granad import Pulse pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) We then compute the TD dipole moment and Fourier transform it. omegas , dipole_omega , pulse_omega = flake . get_expectation_value_frequency_domain ( operator = flake . dipole_operator , # the dipole moment is the expectation value of the dipole operator end_time = 40 , steps_time = 1e5 , relaxation_rate = 1 / 10 , illumination = pulse , omega_min = 0 , omega_max = 5 , skip = 100 , ) The polarizability is given by \\(p / E\\) (we only take the \\(x\\) - component). absorption_td = jnp . abs ( - omegas * jnp . imag ( dipole_omega [:, 0 ] / pulse_omega [:, 0 ] ) ) We can now compare the two results. import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas_rpa , absorption_rpa / jnp . max ( absorption_rpa ), 'o' , linewidth = 2 , label = 'RPA' ) plt . plot ( omegas , absorption_td / jnp . max ( absorption_td ), linewidth = 2 , ls = '--' , label = 'TD' ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . legend () plt . grid ( True ) plt . show ()","title":"8. Linear response"},{"location":"tutorials/linear_response/#8-linear-response","text":"We will calculate the optical absorption in the RPA and compare it to TD simulations with a weak external field.","title":"8. Linear response"},{"location":"tutorials/linear_response/#rpa","text":"First, we set up the RPA simulation. We will consider a small triangle such that the required simulation time stays in the seconds range. import jax.numpy as jnp from granad import MaterialCatalog , Triangle # get material graphene = MaterialCatalog . get ( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene . cut_flake ( Triangle ( 15 ) ) # frequencies omegas_rpa = jnp . linspace ( 0 , 5 , 40 ) We obtain the polarizability for an external \\(x\\) polarized field and from its imaginary part the absorption. polarizability = flake . get_polarizability_rpa ( omegas_rpa , relaxation_rate = 1 / 10 , polarization = 0 , hungry = 2 ) absorption_rpa = jnp . abs ( polarizability . imag * 4 * jnp . pi * omegas_rpa )","title":"RPA"},{"location":"tutorials/linear_response/#td","text":"For the TD simulations, we specify a spectrally broad external illumination (i.e. a narrow pulse in time domain) to capture the system's response over a large frequency range. from granad import Pulse pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 2.3 , peak = 5 , fwhm = 2 ) We then compute the TD dipole moment and Fourier transform it. omegas , dipole_omega , pulse_omega = flake . get_expectation_value_frequency_domain ( operator = flake . dipole_operator , # the dipole moment is the expectation value of the dipole operator end_time = 40 , steps_time = 1e5 , relaxation_rate = 1 / 10 , illumination = pulse , omega_min = 0 , omega_max = 5 , skip = 100 , ) The polarizability is given by \\(p / E\\) (we only take the \\(x\\) - component). absorption_td = jnp . abs ( - omegas * jnp . imag ( dipole_omega [:, 0 ] / pulse_omega [:, 0 ] ) ) We can now compare the two results. import matplotlib.pyplot as plt plt . style . use ( 'ggplot' ) plt . figure ( figsize = ( 10 , 6 )) plt . plot ( omegas_rpa , absorption_rpa / jnp . max ( absorption_rpa ), 'o' , linewidth = 2 , label = 'RPA' ) plt . plot ( omegas , absorption_td / jnp . max ( absorption_td ), linewidth = 2 , ls = '--' , label = 'TD' ) plt . xlabel ( r '$\\hbar\\omega$' , fontsize = 20 ) plt . ylabel ( r '$\\sigma(\\omega)$' , fontsize = 25 ) plt . title ( 'Absorption Spectrum as a Function of Photon Energy' , fontsize = 15 ) plt . legend () plt . grid ( True ) plt . show ()","title":"TD"},{"location":"tutorials/list-based_simulations_/","text":"2. List-based Simulations We detail the main datatype of GRANAD. Orbitals: A Recap As already explained in the \"Getting Started\" Tutorial, Orbitals are the basic building blocks of orbital lists. Let's inspect the class from granad import * print ( Orbital . __doc__ ) Represents the quantum state of an electron in an atom with specific properties. Attributes: position (jax.Array): The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom, may be None if not specified. tag (Optional[str]): An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable. group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. For example, all pz orbitals in a single graphene flake get the same group_id. Key Functionality: The most important attributes of an orbtial are group_id (automatically generated, not recommended to be set it by the user) tag (user-defined or predefined for existing materials) Orbital lists To group orbitals, we put them in a list. print ( OrbitalList . __doc__ ) A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list, while also maintaining additional functionalities for coupling orbitals and managing their relationships. The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries, where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float or a function representing the coupling strength or mechanism between the orbitals). The class also stores simulation parameters like the number of electrons and temperature in a dataclass. The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so quantity_x == quantity. The class exposes simulation methods. Attributes: orbitals (list): The underlying list that stores the orbitals. couplings (dict): A dictionary where keys are tuples of orbital identifiers and values are the couplings (either float values or functions). Key Functionalities: - **Orbital Identification**: Orbitals can be identified either by their group_id, a direct reference to the orbital object itself, or via a user-defined tag. - **Index Access**: Orbitals can be accessed and managed by their index in the list, allowing for list-like manipulation (addition, removal, access). - **Coupling Definition**: Allows for the definition and adjustment of couplings between pairs of orbitals, identified by a tuple of their respective identifiers. These couplings can dynamically represent the interaction strength or be a computational function that defines the interaction. Note: The coupling values can be dynamically modified. When two orbital lists are added, their couplings are merged, and their simulation parameters are wiped. So the docstring tells us that orbital lists allow to couple orbitals store simulation parameters in a dataclass compute physical observables lazily (it also talks about bases, but see the seperate tutorial). let us simulate things We will look at these remaining points below. Coupling orbitals Say we want to create a stack of two graphene flakes. flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) How do we create the second flake and stack it on top? First of all, we duplicate the existing flake flake_shifted = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) We then inspect its orbitals. print ( flake_shifted ) List with 68 orbitals, 68 electrons. [0] electrons excited from [0] to [0]. group id 2 : 68 orbitals When the orbitals in a flake are instantiated, they are automatically assigned a group id that has not been in use before. This flake contains only one group for all pz orbitals in the flake. We can check this print ( flake_shifted . get_group_ids ()) # the i-th entry is the group of the i-th orbital print ( flake_shifted . get_unique_group_ids ()) # this is just jnp.unique on the previous array [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2] [2] So, we know that all orbitals in the flake have the same group_id. As such, we can group them and shift them together. group_id_upper = flake_shifted . get_unique_group_ids () # this shift will be applied to all orbitals with the same group => the flake is lifted in z-direction flake_shifted . shift_by_vector ( group_id_upper , [ 0 , 0 , 1 ] ) Creating the stack is easy now stack = flake + flake_shifted stack . show_3d () Okay, we have the geometry right, but what about the coupling? If we inspect the energies stack . show_energies () We see that we get every point twice: the interlayer coupling is zero by default, so we have a two-fold degenerate spectrum. To lift this degeneracy, we need to couple the layers. We do this via a function depending on distance. Say, you want to couple only nearest neighbors in a layer with a strength of -2.66. Interlayer nearest neighbors are separated by a distance of 1 Angstr\u00f6m. So, one way to express the coupling as a function is by a narrow gaussian around 1.0 def interlayer_hopping ( distance ): return jnp . exp ( - 100 * ( distance - 1.0 ) ** 2 ) If the distance is (sufficiently close to) 1.0, we couple with -2.66, otherwise we don't couple. So, we want to couple two groups: the lower group of pz orbitals (the flake in the xy-plane) and the upper group. We do this like this: lower_id = flake . get_unique_group_ids ()[ 0 ] upper_id = flake_shifted . get_unique_group_ids ()[ 0 ] stack . set_groups_hopping ( lower_id , upper_id , interlayer_hopping ) stack . show_energies () The degeneracy is lifted! Consider now an adatom lower_level = Orbital ( tag = \"atom\" ) upper_level = Orbital ( tag = \"atom\" ) atom = OrbitalList ([ lower_level , upper_level ]) print ( atom ) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 3 : 1 orbitals group id 4 : 1 orbitals For now, we have two electrons. We learn how to change this below. Each orbital has its own group_id. Don't change these, GRANAD handles these by default. We want to set energies of this adatom, i.e. its hamiltonian. If we just want a TLS with energies \\(\\pm 0.5\\) , we have a \\(2x2\\) matrix, where H[0,0] = -0.5, and H[1,1] = 0.5. We can set the hamiltonian elements directly atom . set_hamiltonian_element ( 0 , 0 , - 0.5 ) atom . set_hamiltonian_element ( 1 , 1 , 0.5 ) print ( atom . hamiltonian ) [[-0.5+0.j 0. +0.j] [ 0. +0.j 0.5+0.j]] We can also set the elements by directly referencing the orbitals atom . set_hamiltonian_element ( upper_level , upper_level , 0.8 ) print ( atom . hamiltonian ) [[-0.5+0.j 0. +0.j] [ 0. +0.j 0.8+0.j]] You can do the same thing for any element of the graphene flake btw. Talking about it, let's couple the atom to it. First, we combine the lists stack_with_atom = stack + atom Now, we move the atom somewhere in between the two flakes stack_with_atom . show_3d ( show_index = True ) We pick two indices we like and put the atom in between. To move all orbitals on the atom, we use the tag we just defined. new_atom_position = stack_with_atom [ 0 ] . position + jnp . array ( [ 0 , 0 , 0.5 ] ) stack_with_atom . set_position ( \"atom\" , position = new_atom_position ) stack_with_atom . show_3d () Now, we look at the energies stack_with_atom . show_energies () Not much of a change, but the reason is that we forgot to couple the atom to the flakes. So let's do that. We couple it just to its nearest neighbors. stack_with_atom . set_hamiltonian_element ( lower_level , 0 , 0.3 ) # we can even mix orbitals and indices stack_with_atom . set_hamiltonian_element ( upper_level , 0 , 0.3 ) stack_with_atom . set_hamiltonian_element ( upper_level , 64 , 0.3 ) stack_with_atom . set_hamiltonian_element ( upper_level , 64 , 0.3 ) stack . show_energies () Setting coulomb elements works analogously. To wrap up, we can couple by setting matrix elements indexing via orbitals or their list indices setting coupling functions via group ids (you can also pass orbitals to these functions, but the behavior is a bit weirder). Simulation Parameters Let's revisit the adatom we just built. print ( atom ) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 3 : 1 orbitals group id 4 : 1 orbitals We have two electrons, but a traditional TLS should only have one. We can do this like that atom . set_electrons ( atom . electrons - 1 ) print ( atom ) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 3 : 1 orbitals group id 4 : 1 orbitals This looks better. Let's excite the transition (in our lingo, this is HOMO-LUMO) atom . set_excitation ( 0 , 1 , 1 ) atom . show_energies () This works. Let's now combine it with another TLS a = Orbital ( tag = \"atom2\" ) b = Orbital ( tag = \"atom2\" ) atom2 = OrbitalList ([ a , b ]) atoms = atom + atom2 print ( atoms . energies ) print ( atoms ) [-0.5 0. 0. 0.8] List with 4 orbitals, 4 electrons. [0] electrons excited from [0] to [0]. group id 3 : 1 orbitals group id 4 : 1 orbitals group id 5 : 1 orbitals group id 6 : 1 orbitals WAIT! We are back to 2 + 2 = 4 electrons, i.e. one per orbital? Why is this? The reason is that addition for orbital lists is defined as, schematically orb1 + orb2 = [orb1, orb2] coupling1 + coupling2 = [coupling1, coupling2] param1 + param2 = default_params This might change in the future allowing you to define your own addition for all orbital list attributes. For now, we need to reset to the correct orbital number manually atoms . set_electrons ( atoms . electrons - 1 ) Another peculiarity of orbital lists is: they can contain each orbital only one time. So, if you try: # updated_stack = stack_with_atom + atoms This will fail, because stack_with_atom already contains the atom contained in atoms. Admittedly, this is weird. If you are interested in the simulation parameters print ( SimulationParams . __doc__ ) A data class for storing parameters necessary for running a simulation involving electronic states and transitions. Attributes: from_state (jax.Array): An array where each element is the index of an electronic state from which electrons are excited. Defaults to an array containing a single zero. to_state (jax.Array): An array where each element is the index of an electronic state to which electrons are excited. Defaults to an array containing a single zero. excited_electrons (jax.Array): An array where each element indicates the number of electrons excited between the corresponding states in `from_state` and `to_state`. Defaults to an array containing a single zero. eps (float): Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5. beta (float): Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to `jax.numpy.inf` by default, implying zero temperature. self_consistency_params (dict): A dictionary to hold additional parameters required for self-consistency calculations within the simulation. Defaults to an empty dictionary. spin_degeneracy (float): Factor to account for the degeneracy of spin states in the simulation. Typically set to 2, considering spin up and spin down. electrons (Optional[int]): The total number of electrons in the structure. If not provided, it is assumed that the system's electron number needs to be calculated or is managed elsewhere. Note: This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state of OrbitalList. So, they encapsulate the state of the simulation. Just remember to set them directly before you simulate. Lazy computation This is quickly explained: we have used it all the time! atom . set_hamiltonian_element ( 0 , 0 , 0.0 ) # doesnt compute anything atom . set_hamiltonian_element ( 0 , 0 , 1.0 ) # still, nothing computed atom . energies # now, we need to compute Array([0.8, 1. ], dtype=float64) Simulations Simulations don't change anything about the orbitals, so we can do the same time propagation with two different relaxation rates etc. The only methods that change anything about the list explicitly tell you so by starting with \"set\".","title":"2. List-based Simulations"},{"location":"tutorials/list-based_simulations_/#2-list-based-simulations","text":"We detail the main datatype of GRANAD.","title":"2. List-based Simulations"},{"location":"tutorials/list-based_simulations_/#orbitals-a-recap","text":"As already explained in the \"Getting Started\" Tutorial, Orbitals are the basic building blocks of orbital lists. Let's inspect the class from granad import * print ( Orbital . __doc__ ) Represents the quantum state of an electron in an atom with specific properties. Attributes: position (jax.Array): The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom, may be None if not specified. tag (Optional[str]): An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable. group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. For example, all pz orbitals in a single graphene flake get the same group_id. Key Functionality: The most important attributes of an orbtial are group_id (automatically generated, not recommended to be set it by the user) tag (user-defined or predefined for existing materials)","title":"Orbitals: A Recap"},{"location":"tutorials/list-based_simulations_/#orbital-lists","text":"To group orbitals, we put them in a list. print ( OrbitalList . __doc__ ) A class that encapsulates a list of orbitals, providing an interface similar to a standard Python list, while also maintaining additional functionalities for coupling orbitals and managing their relationships. The class stores orbitals in a wrapped Python list and handles the coupling of orbitals using dictionaries, where the keys are tuples of orbital identifiers (orb_id), and the values are the couplings (either a float or a function representing the coupling strength or mechanism between the orbitals). The class also stores simulation parameters like the number of electrons and temperature in a dataclass. The class computes physical observables (energies etc) lazily on the fly, when they are needed. If there is a basis (either site or energy) to reasonably associate with a quantity, the class exposes quantity_x as an attribute for the site basis and quantity_e as an attribute for the energy basis. By default, all quantities are in site basis, so quantity_x == quantity. The class exposes simulation methods. Attributes: orbitals (list): The underlying list that stores the orbitals. couplings (dict): A dictionary where keys are tuples of orbital identifiers and values are the couplings (either float values or functions). Key Functionalities: - **Orbital Identification**: Orbitals can be identified either by their group_id, a direct reference to the orbital object itself, or via a user-defined tag. - **Index Access**: Orbitals can be accessed and managed by their index in the list, allowing for list-like manipulation (addition, removal, access). - **Coupling Definition**: Allows for the definition and adjustment of couplings between pairs of orbitals, identified by a tuple of their respective identifiers. These couplings can dynamically represent the interaction strength or be a computational function that defines the interaction. Note: The coupling values can be dynamically modified. When two orbital lists are added, their couplings are merged, and their simulation parameters are wiped. So the docstring tells us that orbital lists allow to couple orbitals store simulation parameters in a dataclass compute physical observables lazily (it also talks about bases, but see the seperate tutorial). let us simulate things We will look at these remaining points below.","title":"Orbital lists"},{"location":"tutorials/list-based_simulations_/#coupling-orbitals","text":"Say we want to create a stack of two graphene flakes. flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) How do we create the second flake and stack it on top? First of all, we duplicate the existing flake flake_shifted = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) We then inspect its orbitals. print ( flake_shifted ) List with 68 orbitals, 68 electrons. [0] electrons excited from [0] to [0]. group id 2 : 68 orbitals When the orbitals in a flake are instantiated, they are automatically assigned a group id that has not been in use before. This flake contains only one group for all pz orbitals in the flake. We can check this print ( flake_shifted . get_group_ids ()) # the i-th entry is the group of the i-th orbital print ( flake_shifted . get_unique_group_ids ()) # this is just jnp.unique on the previous array [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2] [2] So, we know that all orbitals in the flake have the same group_id. As such, we can group them and shift them together. group_id_upper = flake_shifted . get_unique_group_ids () # this shift will be applied to all orbitals with the same group => the flake is lifted in z-direction flake_shifted . shift_by_vector ( group_id_upper , [ 0 , 0 , 1 ] ) Creating the stack is easy now stack = flake + flake_shifted stack . show_3d () Okay, we have the geometry right, but what about the coupling? If we inspect the energies stack . show_energies () We see that we get every point twice: the interlayer coupling is zero by default, so we have a two-fold degenerate spectrum. To lift this degeneracy, we need to couple the layers. We do this via a function depending on distance. Say, you want to couple only nearest neighbors in a layer with a strength of -2.66. Interlayer nearest neighbors are separated by a distance of 1 Angstr\u00f6m. So, one way to express the coupling as a function is by a narrow gaussian around 1.0 def interlayer_hopping ( distance ): return jnp . exp ( - 100 * ( distance - 1.0 ) ** 2 ) If the distance is (sufficiently close to) 1.0, we couple with -2.66, otherwise we don't couple. So, we want to couple two groups: the lower group of pz orbitals (the flake in the xy-plane) and the upper group. We do this like this: lower_id = flake . get_unique_group_ids ()[ 0 ] upper_id = flake_shifted . get_unique_group_ids ()[ 0 ] stack . set_groups_hopping ( lower_id , upper_id , interlayer_hopping ) stack . show_energies () The degeneracy is lifted! Consider now an adatom lower_level = Orbital ( tag = \"atom\" ) upper_level = Orbital ( tag = \"atom\" ) atom = OrbitalList ([ lower_level , upper_level ]) print ( atom ) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 3 : 1 orbitals group id 4 : 1 orbitals For now, we have two electrons. We learn how to change this below. Each orbital has its own group_id. Don't change these, GRANAD handles these by default. We want to set energies of this adatom, i.e. its hamiltonian. If we just want a TLS with energies \\(\\pm 0.5\\) , we have a \\(2x2\\) matrix, where H[0,0] = -0.5, and H[1,1] = 0.5. We can set the hamiltonian elements directly atom . set_hamiltonian_element ( 0 , 0 , - 0.5 ) atom . set_hamiltonian_element ( 1 , 1 , 0.5 ) print ( atom . hamiltonian ) [[-0.5+0.j 0. +0.j] [ 0. +0.j 0.5+0.j]] We can also set the elements by directly referencing the orbitals atom . set_hamiltonian_element ( upper_level , upper_level , 0.8 ) print ( atom . hamiltonian ) [[-0.5+0.j 0. +0.j] [ 0. +0.j 0.8+0.j]] You can do the same thing for any element of the graphene flake btw. Talking about it, let's couple the atom to it. First, we combine the lists stack_with_atom = stack + atom Now, we move the atom somewhere in between the two flakes stack_with_atom . show_3d ( show_index = True ) We pick two indices we like and put the atom in between. To move all orbitals on the atom, we use the tag we just defined. new_atom_position = stack_with_atom [ 0 ] . position + jnp . array ( [ 0 , 0 , 0.5 ] ) stack_with_atom . set_position ( \"atom\" , position = new_atom_position ) stack_with_atom . show_3d () Now, we look at the energies stack_with_atom . show_energies () Not much of a change, but the reason is that we forgot to couple the atom to the flakes. So let's do that. We couple it just to its nearest neighbors. stack_with_atom . set_hamiltonian_element ( lower_level , 0 , 0.3 ) # we can even mix orbitals and indices stack_with_atom . set_hamiltonian_element ( upper_level , 0 , 0.3 ) stack_with_atom . set_hamiltonian_element ( upper_level , 64 , 0.3 ) stack_with_atom . set_hamiltonian_element ( upper_level , 64 , 0.3 ) stack . show_energies () Setting coulomb elements works analogously. To wrap up, we can couple by setting matrix elements indexing via orbitals or their list indices setting coupling functions via group ids (you can also pass orbitals to these functions, but the behavior is a bit weirder).","title":"Coupling orbitals"},{"location":"tutorials/list-based_simulations_/#simulation-parameters","text":"Let's revisit the adatom we just built. print ( atom ) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 3 : 1 orbitals group id 4 : 1 orbitals We have two electrons, but a traditional TLS should only have one. We can do this like that atom . set_electrons ( atom . electrons - 1 ) print ( atom ) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 3 : 1 orbitals group id 4 : 1 orbitals This looks better. Let's excite the transition (in our lingo, this is HOMO-LUMO) atom . set_excitation ( 0 , 1 , 1 ) atom . show_energies () This works. Let's now combine it with another TLS a = Orbital ( tag = \"atom2\" ) b = Orbital ( tag = \"atom2\" ) atom2 = OrbitalList ([ a , b ]) atoms = atom + atom2 print ( atoms . energies ) print ( atoms ) [-0.5 0. 0. 0.8] List with 4 orbitals, 4 electrons. [0] electrons excited from [0] to [0]. group id 3 : 1 orbitals group id 4 : 1 orbitals group id 5 : 1 orbitals group id 6 : 1 orbitals WAIT! We are back to 2 + 2 = 4 electrons, i.e. one per orbital? Why is this? The reason is that addition for orbital lists is defined as, schematically orb1 + orb2 = [orb1, orb2] coupling1 + coupling2 = [coupling1, coupling2] param1 + param2 = default_params This might change in the future allowing you to define your own addition for all orbital list attributes. For now, we need to reset to the correct orbital number manually atoms . set_electrons ( atoms . electrons - 1 ) Another peculiarity of orbital lists is: they can contain each orbital only one time. So, if you try: # updated_stack = stack_with_atom + atoms This will fail, because stack_with_atom already contains the atom contained in atoms. Admittedly, this is weird. If you are interested in the simulation parameters print ( SimulationParams . __doc__ ) A data class for storing parameters necessary for running a simulation involving electronic states and transitions. Attributes: from_state (jax.Array): An array where each element is the index of an electronic state from which electrons are excited. Defaults to an array containing a single zero. to_state (jax.Array): An array where each element is the index of an electronic state to which electrons are excited. Defaults to an array containing a single zero. excited_electrons (jax.Array): An array where each element indicates the number of electrons excited between the corresponding states in `from_state` and `to_state`. Defaults to an array containing a single zero. eps (float): Numerical precision used for identifying degenerate eigenstates. Defaults to 1e-5. beta (float): Inverse temperature parameter (1/kT) used in thermodynamic calculations. Set to `jax.numpy.inf` by default, implying zero temperature. self_consistency_params (dict): A dictionary to hold additional parameters required for self-consistency calculations within the simulation. Defaults to an empty dictionary. spin_degeneracy (float): Factor to account for the degeneracy of spin states in the simulation. Typically set to 2, considering spin up and spin down. electrons (Optional[int]): The total number of electrons in the structure. If not provided, it is assumed that the system's electron number needs to be calculated or is managed elsewhere. Note: This object should not be created directly, but is rather used to encapsulate (ephemeral) internal state of OrbitalList. So, they encapsulate the state of the simulation. Just remember to set them directly before you simulate.","title":"Simulation Parameters"},{"location":"tutorials/list-based_simulations_/#lazy-computation","text":"This is quickly explained: we have used it all the time! atom . set_hamiltonian_element ( 0 , 0 , 0.0 ) # doesnt compute anything atom . set_hamiltonian_element ( 0 , 0 , 1.0 ) # still, nothing computed atom . energies # now, we need to compute Array([0.8, 1. ], dtype=float64)","title":"Lazy computation"},{"location":"tutorials/list-based_simulations_/#simulations","text":"Simulations don't change anything about the orbitals, so we can do the same time propagation with two different relaxation rates etc. The only methods that change anything about the list explicitly tell you so by starting with \"set\".","title":"Simulations"},{"location":"tutorials/plotting/","text":"3. Plotting We take a look at built-in plotting functions. A typical simulation requires visualizing: geometry time-dependent arrays (such as dipole moments) space-dependent arrays (such as eigenstates, charges, ...) All public plotting functions are associated with a list of orbitals. Geometry Geometries can be visualized in 2D or 3D. from granad import Wave , Orbital , OrbitalList , MaterialCatalog , Rectangle flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) flake . show_2d () If we have a stack flake_shifted = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) flake_shifted . shift_by_vector ( \"sublattice_1\" , [ 0 , 0 , 1 ] ) flake_shifted . shift_by_vector ( \"sublattice_2\" , [ 0 , 0 , 1 ] ) stack = flake + flake_shifted stack . show_3d () Time-dependent arrays There is a dedicated function for processing TD simulation output help ( flake . show_time_dependence ) Help on method show_time_dependence in module granad._plotting: show_time_dependence(density_matrices, operator=None, time: jax.Array = None, indicate_eigenstate=True, ylabel=None, thresh: float = 0.01) method of granad.orbitals.OrbitalList instance Depicts an expectation value as a function of time. - `density_matrices`: TxNxN array, if no operator is given, diagonal elements will be plotted - `operator`: if given, show its time-dependent expectation value - `time`: time axis - `indicate_eigenstate`: whether to associate the i-th energy eigenstate to the i-th column of expectation_value - `thresh`: plotting threshold. o_t is plotted if max(o_t) - min(o_t) > thresh So, lets plot the relaxing energy occupations of the first flake after exciting a HOMO-LUMO transition flake . set_excitation ( flake . homo , flake . homo + 2 , 1 ) time , density_matrices = flake . get_density_matrix_time_domain ( end_time = 40 , steps_time = 1e5 , relaxation_rate = 1 / 10 , illumination = Wave ( [ 0 , 0 , 0 ], 0 ), skip = 100 , ) density_matrices_e = flake . transform_to_energy_basis ( density_matrices ) flake . show_time_dependence ( density_matrices = density_matrices_e ) If we want, we can check that the correct excitation is set flake . show_energies () Space-dependent arrays The functions show_2d and show_3d are a bit more versatile than initially indicated. Let's see why at the 2d example help ( flake . show_2d ) Help on method show_2d in module granad._plotting: show_2d(show_tags=None, show_index=False, display=None) method of granad.orbitals.OrbitalList instance Generates a 2D scatter plot representing the positions of orbitals in the xy-plane, filtered by specified tags. Optionally colors points by eigenvector amplitudes. Parameters: - orbs (list): List of orbital objects, each with attributes 'tag' and 'position'. - show_tags (list of str, optional): Tags used to filter orbitals for display. - show_index (bool): If True, indexes of the orbitals will be shown on the plot. - display: N-element array to display Returns: - None: A 2D scatter plot is displayed. So, the display argument allows us to plot an arbitrary function defined on the grid spanned by the orbitals and filter it by orbital tags. Let's demonstrate this by visualizing the lowest energy one particle state of the flake flake . show_2d ( display = flake . eigenvectors [:, 0 ] ) # the ground state is the Additionally, if you supply the keyword argument name = \"MY-PLOT-NAME.pdf\" to any plotting function, the plot will not be displayed, but instead saved to disk in the directory you invoked Python.","title":"3. Plotting"},{"location":"tutorials/plotting/#3-plotting","text":"We take a look at built-in plotting functions. A typical simulation requires visualizing: geometry time-dependent arrays (such as dipole moments) space-dependent arrays (such as eigenstates, charges, ...) All public plotting functions are associated with a list of orbitals.","title":"3. Plotting"},{"location":"tutorials/plotting/#geometry","text":"Geometries can be visualized in 2D or 3D. from granad import Wave , Orbital , OrbitalList , MaterialCatalog , Rectangle flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) flake . show_2d () If we have a stack flake_shifted = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( Rectangle ( 10 , 10 ) ) flake_shifted . shift_by_vector ( \"sublattice_1\" , [ 0 , 0 , 1 ] ) flake_shifted . shift_by_vector ( \"sublattice_2\" , [ 0 , 0 , 1 ] ) stack = flake + flake_shifted stack . show_3d ()","title":"Geometry"},{"location":"tutorials/plotting/#time-dependent-arrays","text":"There is a dedicated function for processing TD simulation output help ( flake . show_time_dependence ) Help on method show_time_dependence in module granad._plotting: show_time_dependence(density_matrices, operator=None, time: jax.Array = None, indicate_eigenstate=True, ylabel=None, thresh: float = 0.01) method of granad.orbitals.OrbitalList instance Depicts an expectation value as a function of time. - `density_matrices`: TxNxN array, if no operator is given, diagonal elements will be plotted - `operator`: if given, show its time-dependent expectation value - `time`: time axis - `indicate_eigenstate`: whether to associate the i-th energy eigenstate to the i-th column of expectation_value - `thresh`: plotting threshold. o_t is plotted if max(o_t) - min(o_t) > thresh So, lets plot the relaxing energy occupations of the first flake after exciting a HOMO-LUMO transition flake . set_excitation ( flake . homo , flake . homo + 2 , 1 ) time , density_matrices = flake . get_density_matrix_time_domain ( end_time = 40 , steps_time = 1e5 , relaxation_rate = 1 / 10 , illumination = Wave ( [ 0 , 0 , 0 ], 0 ), skip = 100 , ) density_matrices_e = flake . transform_to_energy_basis ( density_matrices ) flake . show_time_dependence ( density_matrices = density_matrices_e ) If we want, we can check that the correct excitation is set flake . show_energies ()","title":"Time-dependent arrays"},{"location":"tutorials/plotting/#space-dependent-arrays","text":"The functions show_2d and show_3d are a bit more versatile than initially indicated. Let's see why at the 2d example help ( flake . show_2d ) Help on method show_2d in module granad._plotting: show_2d(show_tags=None, show_index=False, display=None) method of granad.orbitals.OrbitalList instance Generates a 2D scatter plot representing the positions of orbitals in the xy-plane, filtered by specified tags. Optionally colors points by eigenvector amplitudes. Parameters: - orbs (list): List of orbital objects, each with attributes 'tag' and 'position'. - show_tags (list of str, optional): Tags used to filter orbitals for display. - show_index (bool): If True, indexes of the orbitals will be shown on the plot. - display: N-element array to display Returns: - None: A 2D scatter plot is displayed. So, the display argument allows us to plot an arbitrary function defined on the grid spanned by the orbitals and filter it by orbital tags. Let's demonstrate this by visualizing the lowest energy one particle state of the flake flake . show_2d ( display = flake . eigenvectors [:, 0 ] ) # the ground state is the Additionally, if you supply the keyword argument name = \"MY-PLOT-NAME.pdf\" to any plotting function, the plot will not be displayed, but instead saved to disk in the directory you invoked Python.","title":"Space-dependent arrays"},{"location":"tutorials/rabi_oscillations/","text":"7. Rabi Oscillations We study Rabi oscillations as in the paper Revising quantum optical phenomena in adatoms coupled to graphene nanoantennas . NOTE: It is a good idea to get familiar with orbital lists by consulting the tutorial first. Building a two-level system We set up an isolated adatom. import jax.numpy as jnp import matplotlib from granad import Wave , Orbital , OrbitalList , MaterialCatalog , Triangle lower_level = Orbital ( tag = \"atom\" ) upper_level = Orbital ( tag = \"atom\" ) atom = OrbitalList ([ lower_level , upper_level ]) atom . set_electrons ( 1 ) atom . set_hamiltonian_element ( upper_level , upper_level , 0.5 ) atom . set_hamiltonian_element ( lower_level , lower_level , - 0.5 ) atom . set_dipole_transition ( upper_level , lower_level , [ 0 , 7.5 , 0 ]) We study undamped time evolution under harmonic illumination wave = Wave ( amplitudes = [ 0 , 0.05 , 0 ], frequency = 1 ) time , density_matrices = atom . get_density_matrix_time_domain ( end_time = 50 , illumination = wave , use_rwa = True , coulomb_strength = 0.0 , steps_time = 1e5 , ) atom . show_time_dependence ( density_matrices , time = time ) Coupling to a Flake We combine the TLS with a graphene flake in the top position above an atom. graphene = MaterialCatalog . get ( \"graphene\" ) flake = graphene . cut_flake ( Triangle ( 10 , armchair = True , shift = [ 10 , 10 ]), plot = False ) flake_with_atom = flake + atom flake_with_atom . set_electrons ( flake_with_atom . electrons - 1 ) pz_orbital = flake_with_atom [ 8 ] top = pz_orbital . position + jnp . array ([ 0 , 0 , 1 ]) flake_with_atom . set_position ( tag = \"atom\" , position = top ) flake_with_atom . show_3d ( show_index = True ) We set the couplings flake_with_atom . set_hamiltonian_element ( pz_orbital , lower_level , 0.5 ) flake_with_atom . set_hamiltonian_element ( pz_orbital , upper_level , 0.5 ) Now, the time evolution of the composite system time , density_matrices = flake_with_atom . get_density_matrix_time_domain ( end_time = 50 , illumination = wave , use_rwa = True , coulomb_strength = 0.0 , steps_time = 1e5 , ) density_matrices_e = flake_with_atom . transform_to_energy_basis ( density_matrices ) flake_with_atom . show_time_dependence ( density_matrices_e , time = time )","title":"7. Rabi Oscillations"},{"location":"tutorials/rabi_oscillations/#7-rabi-oscillations","text":"We study Rabi oscillations as in the paper Revising quantum optical phenomena in adatoms coupled to graphene nanoantennas . NOTE: It is a good idea to get familiar with orbital lists by consulting the tutorial first.","title":"7. Rabi Oscillations"},{"location":"tutorials/rabi_oscillations/#building-a-two-level-system","text":"We set up an isolated adatom. import jax.numpy as jnp import matplotlib from granad import Wave , Orbital , OrbitalList , MaterialCatalog , Triangle lower_level = Orbital ( tag = \"atom\" ) upper_level = Orbital ( tag = \"atom\" ) atom = OrbitalList ([ lower_level , upper_level ]) atom . set_electrons ( 1 ) atom . set_hamiltonian_element ( upper_level , upper_level , 0.5 ) atom . set_hamiltonian_element ( lower_level , lower_level , - 0.5 ) atom . set_dipole_transition ( upper_level , lower_level , [ 0 , 7.5 , 0 ]) We study undamped time evolution under harmonic illumination wave = Wave ( amplitudes = [ 0 , 0.05 , 0 ], frequency = 1 ) time , density_matrices = atom . get_density_matrix_time_domain ( end_time = 50 , illumination = wave , use_rwa = True , coulomb_strength = 0.0 , steps_time = 1e5 , ) atom . show_time_dependence ( density_matrices , time = time )","title":"Building a two-level system"},{"location":"tutorials/rabi_oscillations/#coupling-to-a-flake","text":"We combine the TLS with a graphene flake in the top position above an atom. graphene = MaterialCatalog . get ( \"graphene\" ) flake = graphene . cut_flake ( Triangle ( 10 , armchair = True , shift = [ 10 , 10 ]), plot = False ) flake_with_atom = flake + atom flake_with_atom . set_electrons ( flake_with_atom . electrons - 1 ) pz_orbital = flake_with_atom [ 8 ] top = pz_orbital . position + jnp . array ([ 0 , 0 , 1 ]) flake_with_atom . set_position ( tag = \"atom\" , position = top ) flake_with_atom . show_3d ( show_index = True ) We set the couplings flake_with_atom . set_hamiltonian_element ( pz_orbital , lower_level , 0.5 ) flake_with_atom . set_hamiltonian_element ( pz_orbital , upper_level , 0.5 ) Now, the time evolution of the composite system time , density_matrices = flake_with_atom . get_density_matrix_time_domain ( end_time = 50 , illumination = wave , use_rwa = True , coulomb_strength = 0.0 , steps_time = 1e5 , ) density_matrices_e = flake_with_atom . transform_to_energy_basis ( density_matrices ) flake_with_atom . show_time_dependence ( density_matrices_e , time = time )","title":"Coupling to a Flake"},{"location":"tutorials/time-domain_simulations/","text":"6. Time-Domain simulations Performance Tips First, we do the necessary setup: imports, shape, flake and field definition import jax.numpy as jnp import matplotlib.pyplot as plt from granad import MaterialCatalog , Pulse , Triangle , Wave import diffrax # is behind the time propagation triangle = Triangle ( 15 , armchair = True ) flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( triangle , plot = True ) pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 1. , peak = 4 , fwhm = 2 ) The dynamics of any observable depend on the density matrix. The function get_expectation_value_frequency_domain essentially samples density matrices in time computes the time-dependent expectation value Fourier transforms it. This is fine if we want to simulate a single observable, but means that we have to rerun the simulation for every observable. To save time, we can do the TD simulation by hand, save the density matrices and then compute expectation values without needing to recompute. time , density_matrices = flake . get_density_matrix_time_domain ( end_time = 40 , steps_time = 1e6 , relaxation_rate = 1 / 10 , illumination = pulse , skip = 100 , ) print ( density_matrices . shape ) (10000, 26, 26) Now, we have density matrices in time domain. The first axis is time, the last two axis correspond to the dimension of the one particle Hilbert space. Let's compute expectation values for the dipole operator by hand p = flake . get_expectation_value ( density_matrix = density_matrices , operator = flake . dipole_operator ) You might have noticed that neither the density_matrices nor the dipole_operator are square matrices. The function can still handle that. Let's inspect the shape of the dipole moments print ( p . shape ) (10000, 3) So, the first axis is time, the last axis corresponds to x,y,z Cartesian coordinates. Let's do the same computation in Fourier space: we can avoid recomputation by passing the TD density matrix as an explicit argument omegas , p_omega = flake . get_expectation_value_frequency_domain ( operator = flake . dipole_operator , # the dipole moment is the expectation value of the dipole operator time = time , density_matrices = density_matrices , omega_min = 0 , omega_max = 10 , ) print ( p_omega . shape ) (64, 3) So, the first axis is the Fourier partner of time, the frequency, and the last axis still corresponds to x,y,z Cartesian coordinates. Options The time evolution relies on diffrax . You can pass solvers directly to any function calling the time domain evolution. By default, we use 5-th order Runge Kutta with adaptive step size, where the relative and absolute tolerance are set to 1e-10. omegas , p_omega_8 = flake . get_expectation_value_frequency_domain ( operator = flake . dipole_operator , time = time , density_matrices = density_matrices , omega_min = 0 , omega_max = 10 , solver = diffrax . Dopri8 (), ) plt . plot ( omegas , p_omega ) plt . plot ( omegas , p_omega_8 , '--' ) plt . show () We see that we have pretty good agreement. Convergence To check convergence, we can Decrease the initial step size by passing a higher value for steps_time Choose a more accurate diffrax solver Check physical consistency with the continuity equation We will look at the third example. The continuity equation relates the dipole moment and the (longitudinal) current \\[\\nabla j = \\partial_t \\rho = \\partial_t \\nabla P \\implies j = \\partial_t P\\] In Fourier space, we can write equivalently \\[-i \\omega p(\\omega) = j(\\omega)\\] The current operator is, a bit confusingly, called velocity operator in GRANAD, since atomic units are used, where q = 1 and \\(j = q v\\) . omegas , j_omega = flake . get_expectation_value_frequency_domain ( operator = flake . velocity_operator , time = time , density_matrices = density_matrices , omega_min = 0 , omega_max = 10 , ) p_omega_0 = p_omega j_omega_0 = j_omega j_term = j_omega_0 . imag p_term = omegas [:, None ] * p_omega_0 . real plt . plot ( omegas , p_term ) plt . plot ( omegas , j_term , '--' ) plt . show () We see that the continuity equation holds. Resuming simulations TD simulations can be resumed. This is useful, e.g. when computing the EPI, where the system needs to have reached a steady state. Let's compute the EPI for our tiny triangle. First, we propagate the system in time and check the oscillation of the dipole moment end_time = 2 wave = Wave ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 1. ) time , density_matrices = flake . get_density_matrix_time_domain ( end_time = end_time , steps_time = 1e6 , relaxation_rate = 1 / 10 , illumination = wave , skip = 1000 , ) p = flake . get_expectation_value ( density_matrix = density_matrices , operator = flake . dipole_operator ) plt . plot ( time , p ) plt . show () The dipole moment doesn't look periodic, so the system is likely not in a steady state. We can push the system further in time by supplying the time we ended the simulation as start time the last density matrix we sampled time_new , density_matrices_new = flake . get_density_matrix_time_domain ( start_time = end_time , end_time = end_time + 10 , initial_density_matrix = density_matrices [ - 1 ], steps_time = 1e6 , relaxation_rate = 1 / 10 , illumination = wave , skip = 1000 , ) p_new = flake . get_expectation_value ( density_matrix = density_matrices_new , operator = flake . dipole_operator ) plt . plot ( jnp . concatenate ([ time , time_new ]), jnp . concatenate ([ p , p_new ]) ) plt . show () We can repeat this process until we have visual confirmation of the steady state: continue simulation with end_time increased and the initial density matrix set to the last density matrix repeat 1 if the result is not periodic GRANAD offers a way you can try to automate this process: the function \"fraction_periodic\" tries to compute the fraction of a signal that is periodic. Let's look at it from granad import fraction_periodic help ( fraction_periodic ) Help on function fraction_periodic in module granad._numerics: fraction_periodic(signal, threshold=0.01) Estimates the fraction of a periodic component in a given signal by analyzing the deviation of the cumulative mean from its median value. The periodicity is inferred based on the constancy of the cumulative mean of the absolute value of the signal. Parameters: signal (jax.Array): A 1D array representing the signal of interest. threshold (float, optional): A threshold value to determine the significance level of deviation from periodicity. Defaults to 0.01. Returns: float: A ratio representing the fraction of the signal that is considered periodic, based on the specified threshold. Example: >>> import jax.numpy as jnp >>> signal = jnp.array([0.1, 0.2, 0.1, 0.2, 0.1, 0.2]) >>> print(fraction_periodic(signal)) 0.995 In our case, the signal to check for periodicity is the dipole moment: once it is periodic, we have hit a steady state. We can define a custom function to test this def is_steady ( density_matrices ): p = flake . get_expectation_value ( operator = flake . dipole_operator , density_matrix = density_matrices ) if fraction_periodic ( p [:, 0 ], threshold = 1e-1 ) > 0.8 : return True return False We chose the value of 0.8 somewhat arbitrarily, but the exact value probably doesn't matter that much in practice if it's high enough (> 0.5). Our automated loop looks like this loop_iterations = 0 while is_steady ( density_matrices ) == False and loop_iterations < 10 : start_time = end_time end_time = end_time + 10 time_new , density_matrices_new = flake . get_density_matrix_time_domain ( start_time = start_time , end_time = end_time , initial_density_matrix = density_matrices [ - 1 ], steps_time = 1e6 , relaxation_rate = 1 / 10 , illumination = wave , skip = 1000 , ) density_matrices = jnp . concatenate ( [ density_matrices , density_matrices_new ] ) time = jnp . concatenate ( [ time , time_new ] ) loop_iterations += 1 print ( is_steady ( density_matrices ) ) True Now, we plot p = flake . get_expectation_value ( operator = flake . dipole_operator , density_matrix = density_matrices ) plt . plot ( time , p ) plt . show () We have correctly identified periodicity and thus the density matrix density_matrices[-1] can be taken as a steady state for epi calculation print ( flake . get_epi ( flake . transform_to_energy_basis ( density_matrices [ - 1 ]), omega = 1.0 )) 0.19040759965429377","title":"6. Time-Domain simulations"},{"location":"tutorials/time-domain_simulations/#6-time-domain-simulations","text":"","title":"6. Time-Domain simulations"},{"location":"tutorials/time-domain_simulations/#performance-tips","text":"First, we do the necessary setup: imports, shape, flake and field definition import jax.numpy as jnp import matplotlib.pyplot as plt from granad import MaterialCatalog , Pulse , Triangle , Wave import diffrax # is behind the time propagation triangle = Triangle ( 15 , armchair = True ) flake = MaterialCatalog . get ( \"graphene\" ) . cut_flake ( triangle , plot = True ) pulse = Pulse ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 1. , peak = 4 , fwhm = 2 ) The dynamics of any observable depend on the density matrix. The function get_expectation_value_frequency_domain essentially samples density matrices in time computes the time-dependent expectation value Fourier transforms it. This is fine if we want to simulate a single observable, but means that we have to rerun the simulation for every observable. To save time, we can do the TD simulation by hand, save the density matrices and then compute expectation values without needing to recompute. time , density_matrices = flake . get_density_matrix_time_domain ( end_time = 40 , steps_time = 1e6 , relaxation_rate = 1 / 10 , illumination = pulse , skip = 100 , ) print ( density_matrices . shape ) (10000, 26, 26) Now, we have density matrices in time domain. The first axis is time, the last two axis correspond to the dimension of the one particle Hilbert space. Let's compute expectation values for the dipole operator by hand p = flake . get_expectation_value ( density_matrix = density_matrices , operator = flake . dipole_operator ) You might have noticed that neither the density_matrices nor the dipole_operator are square matrices. The function can still handle that. Let's inspect the shape of the dipole moments print ( p . shape ) (10000, 3) So, the first axis is time, the last axis corresponds to x,y,z Cartesian coordinates. Let's do the same computation in Fourier space: we can avoid recomputation by passing the TD density matrix as an explicit argument omegas , p_omega = flake . get_expectation_value_frequency_domain ( operator = flake . dipole_operator , # the dipole moment is the expectation value of the dipole operator time = time , density_matrices = density_matrices , omega_min = 0 , omega_max = 10 , ) print ( p_omega . shape ) (64, 3) So, the first axis is the Fourier partner of time, the frequency, and the last axis still corresponds to x,y,z Cartesian coordinates.","title":"Performance Tips"},{"location":"tutorials/time-domain_simulations/#options","text":"The time evolution relies on diffrax . You can pass solvers directly to any function calling the time domain evolution. By default, we use 5-th order Runge Kutta with adaptive step size, where the relative and absolute tolerance are set to 1e-10. omegas , p_omega_8 = flake . get_expectation_value_frequency_domain ( operator = flake . dipole_operator , time = time , density_matrices = density_matrices , omega_min = 0 , omega_max = 10 , solver = diffrax . Dopri8 (), ) plt . plot ( omegas , p_omega ) plt . plot ( omegas , p_omega_8 , '--' ) plt . show () We see that we have pretty good agreement.","title":"Options"},{"location":"tutorials/time-domain_simulations/#convergence","text":"To check convergence, we can Decrease the initial step size by passing a higher value for steps_time Choose a more accurate diffrax solver Check physical consistency with the continuity equation We will look at the third example. The continuity equation relates the dipole moment and the (longitudinal) current \\[\\nabla j = \\partial_t \\rho = \\partial_t \\nabla P \\implies j = \\partial_t P\\] In Fourier space, we can write equivalently \\[-i \\omega p(\\omega) = j(\\omega)\\] The current operator is, a bit confusingly, called velocity operator in GRANAD, since atomic units are used, where q = 1 and \\(j = q v\\) . omegas , j_omega = flake . get_expectation_value_frequency_domain ( operator = flake . velocity_operator , time = time , density_matrices = density_matrices , omega_min = 0 , omega_max = 10 , ) p_omega_0 = p_omega j_omega_0 = j_omega j_term = j_omega_0 . imag p_term = omegas [:, None ] * p_omega_0 . real plt . plot ( omegas , p_term ) plt . plot ( omegas , j_term , '--' ) plt . show () We see that the continuity equation holds.","title":"Convergence"},{"location":"tutorials/time-domain_simulations/#resuming-simulations","text":"TD simulations can be resumed. This is useful, e.g. when computing the EPI, where the system needs to have reached a steady state. Let's compute the EPI for our tiny triangle. First, we propagate the system in time and check the oscillation of the dipole moment end_time = 2 wave = Wave ( amplitudes = [ 1e-5 , 0 , 0 ], frequency = 1. ) time , density_matrices = flake . get_density_matrix_time_domain ( end_time = end_time , steps_time = 1e6 , relaxation_rate = 1 / 10 , illumination = wave , skip = 1000 , ) p = flake . get_expectation_value ( density_matrix = density_matrices , operator = flake . dipole_operator ) plt . plot ( time , p ) plt . show () The dipole moment doesn't look periodic, so the system is likely not in a steady state. We can push the system further in time by supplying the time we ended the simulation as start time the last density matrix we sampled time_new , density_matrices_new = flake . get_density_matrix_time_domain ( start_time = end_time , end_time = end_time + 10 , initial_density_matrix = density_matrices [ - 1 ], steps_time = 1e6 , relaxation_rate = 1 / 10 , illumination = wave , skip = 1000 , ) p_new = flake . get_expectation_value ( density_matrix = density_matrices_new , operator = flake . dipole_operator ) plt . plot ( jnp . concatenate ([ time , time_new ]), jnp . concatenate ([ p , p_new ]) ) plt . show () We can repeat this process until we have visual confirmation of the steady state: continue simulation with end_time increased and the initial density matrix set to the last density matrix repeat 1 if the result is not periodic GRANAD offers a way you can try to automate this process: the function \"fraction_periodic\" tries to compute the fraction of a signal that is periodic. Let's look at it from granad import fraction_periodic help ( fraction_periodic ) Help on function fraction_periodic in module granad._numerics: fraction_periodic(signal, threshold=0.01) Estimates the fraction of a periodic component in a given signal by analyzing the deviation of the cumulative mean from its median value. The periodicity is inferred based on the constancy of the cumulative mean of the absolute value of the signal. Parameters: signal (jax.Array): A 1D array representing the signal of interest. threshold (float, optional): A threshold value to determine the significance level of deviation from periodicity. Defaults to 0.01. Returns: float: A ratio representing the fraction of the signal that is considered periodic, based on the specified threshold. Example: >>> import jax.numpy as jnp >>> signal = jnp.array([0.1, 0.2, 0.1, 0.2, 0.1, 0.2]) >>> print(fraction_periodic(signal)) 0.995 In our case, the signal to check for periodicity is the dipole moment: once it is periodic, we have hit a steady state. We can define a custom function to test this def is_steady ( density_matrices ): p = flake . get_expectation_value ( operator = flake . dipole_operator , density_matrix = density_matrices ) if fraction_periodic ( p [:, 0 ], threshold = 1e-1 ) > 0.8 : return True return False We chose the value of 0.8 somewhat arbitrarily, but the exact value probably doesn't matter that much in practice if it's high enough (> 0.5). Our automated loop looks like this loop_iterations = 0 while is_steady ( density_matrices ) == False and loop_iterations < 10 : start_time = end_time end_time = end_time + 10 time_new , density_matrices_new = flake . get_density_matrix_time_domain ( start_time = start_time , end_time = end_time , initial_density_matrix = density_matrices [ - 1 ], steps_time = 1e6 , relaxation_rate = 1 / 10 , illumination = wave , skip = 1000 , ) density_matrices = jnp . concatenate ( [ density_matrices , density_matrices_new ] ) time = jnp . concatenate ( [ time , time_new ] ) loop_iterations += 1 print ( is_steady ( density_matrices ) ) True Now, we plot p = flake . get_expectation_value ( operator = flake . dipole_operator , density_matrix = density_matrices ) plt . plot ( time , p ) plt . show () We have correctly identified periodicity and thus the density matrix density_matrices[-1] can be taken as a steady state for epi calculation print ( flake . get_epi ( flake . transform_to_energy_basis ( density_matrices [ - 1 ]), omega = 1.0 )) 0.19040759965429377","title":"Resuming simulations"}]}