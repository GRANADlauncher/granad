{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to GRANAD GRANAD (GRAphene Nanoflakes with ADatoms) is a tight-binding simulation utility geared towards the exploration of systems at the intersection of solid state physics and quantum optics. Features Computes optical and electronic properties Full access to time-dependent density matrices via master equation Relies on JAX for performance and differentiability Installation If you want to just install the package, run pip install git+https://github.com/GRANADlauncher/granad.git The documentations is built automatically by executing git clone https://github.com/GRANADlauncher/granad.git cd granad bash install.sh Quickstart Set up the simulation import jax.numpy as jnp from granad import Material2D, Triangle # get material graphene = Material2D.get( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene.cut_orbitals( Triangle(15) ) # frequencies omegas = jnp.linspace( 0, 5, 50 ) # compute optical properties in the RPA with GPU-acceleration polarizability = flake.get_polarizability_rpa( omegas, relaxation_rate = 1/10, polarization = 0, hungry = True ) absorption = polarizability.imag * 4 * jnp.pi * omegas Plot the results import matplotlib.pyplot as plt plt.style.use('ggplot') plt.figure(figsize=(10, 6)) plt.plot(omegas, absorption / jnp.max(absorption), linewidth=2) plt.xlabel(r'$\\hbar\\omega$', fontsize=20) plt.ylabel(r'$\\sigma(\\omega)$', fontsize=25) plt.title('Absorption Spectrum as a Function of Photon Energy', fontsize=15) plt.grid(True)","title":"Home"},{"location":"#welcome-to-granad","text":"GRANAD (GRAphene Nanoflakes with ADatoms) is a tight-binding simulation utility geared towards the exploration of systems at the intersection of solid state physics and quantum optics.","title":"Welcome to GRANAD"},{"location":"#features","text":"Computes optical and electronic properties Full access to time-dependent density matrices via master equation Relies on JAX for performance and differentiability","title":"Features"},{"location":"#installation","text":"If you want to just install the package, run pip install git+https://github.com/GRANADlauncher/granad.git The documentations is built automatically by executing git clone https://github.com/GRANADlauncher/granad.git cd granad bash install.sh","title":"Installation"},{"location":"#quickstart","text":"Set up the simulation import jax.numpy as jnp from granad import Material2D, Triangle # get material graphene = Material2D.get( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene.cut_orbitals( Triangle(15) ) # frequencies omegas = jnp.linspace( 0, 5, 50 ) # compute optical properties in the RPA with GPU-acceleration polarizability = flake.get_polarizability_rpa( omegas, relaxation_rate = 1/10, polarization = 0, hungry = True ) absorption = polarizability.imag * 4 * jnp.pi * omegas Plot the results import matplotlib.pyplot as plt plt.style.use('ggplot') plt.figure(figsize=(10, 6)) plt.plot(omegas, absorption / jnp.max(absorption), linewidth=2) plt.xlabel(r'$\\hbar\\omega$', fontsize=20) plt.ylabel(r'$\\sigma(\\omega)$', fontsize=25) plt.title('Absorption Spectrum as a Function of Photon Energy', fontsize=15) plt.grid(True)","title":"Quickstart"},{"location":"about/","text":"About GRANAD is developed jointly at the Karlsruhe Institute of Technology by the Institute of Theoretical Solid State Physics and at the Nicolaus Copernicus University in Toru\u0144 by the Department of Quantum Physics .","title":"About"},{"location":"about/#about","text":"GRANAD is developed jointly at the Karlsruhe Institute of Technology by the Institute of Theoretical Solid State Physics and at the Nicolaus Copernicus University in Toru\u0144 by the Department of Quantum Physics .","title":"About"},{"location":"api/","text":"API Orbital dataclass Represents the quantum state of an electron in an atom with specific properties. Attributes: position ( Array ) \u2013 The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index ( Optional [ int ] ) \u2013 An optional index representing the layer of the orbital within its atom, may be None if not specified. tag ( Optional [ str ] ) \u2013 An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level ( Optional [ int ] ) \u2013 The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum ( Optional [ int ] ) \u2013 The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z ( Optional [ int ] ) \u2013 The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin ( Optional [ int ] ) \u2013 The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name ( Optional [ str ] ) \u2013 The name of the atom this orbital belongs to, can be None if not applicable. group_id ( int ) \u2013 A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. Source code in src/granad/orbitals.py @dataclass class Orbital: \"\"\" Represents the quantum state of an electron in an atom with specific properties. Attributes: position (jax.Array): The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom, may be None if not specified. tag (Optional[str]): An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable. group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. \"\"\" position: jax.Array = field(default_factory=pos_zero, hash=False, compare=False) layer_index: Optional[int] = None tag: Optional[str] = None energy_level: Optional[int] = None angular_momentum: Optional[int] = None angular_momentum_z: Optional[int] = None spin: Optional[int] = None atom_name: Optional[str] = None group_id: int = field(default_factory=_watchdog._Watchdog.next_value) def __post_init__(self): object.__setattr__(self, \"position\", jnp.array(self.position).astype(float)) def __hash__(self): # Include only immutable fields in hash calculation return hash( ( self.layer_index, self.tag, self.energy_level, self.angular_momentum, self.angular_momentum_z, self.angular_momentum, self.spin, self.atom_name, self.group_id, ) ) def __str__(self): return pformat(vars(self), sort_dicts=False) # TODO: bla bla bla ... this should be shorter but im too tired def __eq__(self, other): if not isinstance(other, Orbital): return NotImplemented return self.group_id == other.group_id and self.layer_index == other.layer_index def __lt__(self, other): if not isinstance(other, Orbital): return NotImplemented return self.group_id < self.group_id def __le__(self, other): return self < other or self == other def __gt__(self, other): return not self <= other def __ge__(self, other): return not self < other def __ne__(self, other): return not self == other OrbitalList A list of orbitals. Source code in src/granad/orbitals.py @plotting_methods class OrbitalList: \"\"\"A list of orbitals.\"\"\" def __init__(self, orbs, _hopping_dict=None, _coulomb_dict=None): # couplings are dicts mapping orbital pairs to couplings self._hopping_dict = ( _hopping_dict if _hopping_dict is not None else _SortedTupleDict() ) self._coulomb_dict = ( _coulomb_dict if _coulomb_dict is not None else _SortedTupleDict() ) self._transitions = _SortedTupleDict() # contains all high-level simulation information self._list = list(orbs) if orbs is not None else [] # flag for recomputing state self._recompute = True # TODO: this is a bunch of stuff and must be better doable self.from_state = jnp.array([0]) self.to_state = jnp.array([0]) self.excited_electrons = jnp.array([0]) self.eps = 1e-5 self.beta = jnp.inf self.self_consistency_params = {} self.spin_degeneracy = 2.0 self.electrons = len(self._list) def __len__(self): return len(self._list) # can't mutate, because orbitals are immutable def __getitem__(self, position): return self._list[position] def __repr__(self): return repr(self._list) # TODO: hmmm def __str__(self): info = f\"List with {len(self)} orbitals, {self.electrons} electrons.\" excited = f\"{self.excited_electrons} electrons excited from {self.from_state} to {self.to_state}.\" groups = \"\\n\".join( [ f\"group id {key} : {val} orbitals\" for key, val in Counter(self.get_group_ids()).items() ] ) return \"\\n\".join((info, excited, groups)) def __iter__(self): return iter(self._list) # TODO: uff, addition, or, in general, mutation should wipe all attributes except for coupling def __add__(self, other): if not self._are_orbs(other): raise TypeError if any(orb in other for orb in self._list): raise ValueError if isinstance(other, OrbitalList): new_hopping_dict = self._hopping_dict.copy() new_hopping_dict.update(other._hopping_dict) new_coulomb_dict = self._coulomb_dict.copy() new_coulomb_dict.update(other._coulomb_dict) return OrbitalList( (self._list + list(other)).copy(), _SortedTupleDict(new_hopping_dict), _SortedTupleDict(new_coulomb_dict), ) @mutates def __setitem__(self, position, value): if isinstance(value, Orbital): self._list[position] = value raise TypeError def _delete_coupling(self, orb, coupling): keys_to_remove = [key for key in coupling if orb in key] for key in keys_to_remove: del coupling[key] @mutates def __delitem__(self, position): orb = self._list[position] self._delete_coupling(orb, self._hopping_dict) self._delete_coupling(orb, self._coulomb_dict) del self._list[position] @staticmethod def _are_orbs(candidate): return all(isinstance(orb, Orbital) for orb in candidate) @mutates def _set_coupling(self, orb_or_group_id1, orb_or_group_id2, val_or_func, coupling): coupling[(orb_or_group_id1, orb_or_group_id2)] = val_or_func # TODO: we may want to differentiate through this, also this is private so better not wrap return val into container def _hamiltonian_coulomb(self): def fill_matrix(matrix, coupling_dict): # TODO: there should be an internal dummy = jnp.arange(len(self)) triangle_mask = dummy[:, None] >= dummy # TODO: in principle we can build a big tensor NxNxgroups, vmap over the last axis and sum the groups # first, we loop over all group_id couplings => interactions between groups for key, function in coupling_dict.group_id_items(): # TODO: big uff: we rely on the correct ordering of the group_ids for cols and rows, first key is always smaller than last keys => we get upper triangular valid indices # if it were the other way around, these would be zeroed by the triangle mask cols = group_ids == key[0] rows = (group_ids == key[1])[:, None] combination_indices = jnp.logical_and(rows, cols) valid_indices = jnp.logical_and(triangle_mask, combination_indices) function = jax.vmap(function) matrix = matrix.at[valid_indices].set( function(distances[valid_indices]) ) # we now set single elements rows, cols, vals = [], [], [] for key, val in coupling_dict.orbital_items(): rows.append(self._list.index(key[0])) cols.append(self._list.index(key[1])) vals.append(val) matrix = matrix.at[rows, cols].set(vals) return matrix + matrix.conj().T - jnp.diag(jnp.diag(matrix)) # TODO: oh noes rounding again, but don't know what to do else positions = self._get_positions() distances = jnp.round( jnp.linalg.norm(positions - positions[:, None], axis=-1), 6 ) group_ids = jnp.array(self.get_group_ids()) hamiltonian = fill_matrix( jnp.zeros((len(self), len(self))).astype(complex), self._hopping_dict ) coulomb = fill_matrix( jnp.zeros((len(self), len(self))).astype(complex), self._coulomb_dict ) return hamiltonian, coulomb def _get_positions(self): return jnp.array([orb.position for orb in self._list]) def _ensure_complex(self, func_or_val): if callable(func_or_val): return lambda x: func_or_val(x) + 0.0j if isinstance(func_or_val, (int, float, complex)): return func_or_val + 0.0j raise TypeError # TODO: bla bla bla ... incredibly verbose, but couldn't think of anything better yet def _maybe_orbs_to_group_ids(self, maybe_orbs): def convert(maybe_orb): # TODO: check if this is really a group_id if isinstance(maybe_orb, int): return maybe_orb if isinstance(maybe_orb, Orbital): return maybe_orb.group_id return \"You have passed something that is neither an orbital nor a group_id\" return [convert(x) for x in maybe_orbs] def _maybe_indices_to_orbs(self, maybe_indices): def convert(maybe_index): if isinstance(maybe_index, int): return self._list[maybe_index] if isinstance(maybe_index, Orbital): return maybe_index return \"You have passed something that is neither an orbital nor an index\" return [convert(x) for x in maybe_indices] def _build(self): # TODO: uff assert len(self) > 0 self._positions = self._get_positions() self._hamiltonian, self._coulomb = self._hamiltonian_coulomb() self._eigenvectors, self._energies = jax.lax.linalg.eigh(self._hamiltonian) self._initial_density_matrix = _numerics._density_matrix( self._energies, self.electrons, self.spin_degeneracy, self.eps, self.from_state, self.to_state, self.excited_electrons, self.beta, ) self._stationary_density_matrix = _numerics._density_matrix( self._energies, self.electrons, self.spin_degeneracy, self.eps, jnp.array([0]), jnp.array([0]), jnp.array([0]), self.beta, ) # TODO: uff if self.self_consistency_params: ( self._hamiltonian, self._initial_density_matrix, self._stationary_density_matrix, self._energies, self._eigenvectors, ) = _get_self_consistent( self._hamiltonian, self._coulomb, self._positions, self.spin_degeneracy, self.electrons, self.eps, self._eigenvectors, self._static_density_matrix, **self.self_consistent_params, ) def get_group_ids(self): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [orb.group_id for orb in self._list] def get_unique_group_ids(self): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list(set(self.get_group_ids())) def set_groups_hopping(self, orb_or_group_id1, orb_or_group_id2, func): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1, group_id2 = self._maybe_orbs_to_group_ids( (orb_or_group_id1, orb_or_group_id2) ) self._set_coupling( group_id1, group_id2, self._ensure_complex(func), self._hopping_dict ) def set_groups_coulomb(self, orb_or_group_id1, orb_or_group_id2, func): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1, group_id2 = self._maybe_orbs_to_group_ids( (orb_or_group_id1, orb_or_group_id2) ) self._set_coupling( group_id1, group_id2, self._ensure_complex(func), self._coulomb_dict ) def set_hamiltonian_element(self, orb_or_index1, orb_or_index2, val): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._set_coupling(orb1, orb2, self._ensure_complex(val), self._hopping_dict) def set_coulomb_element(self, orb_or_index1, orb_or_index2, val): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._set_coupling(orb1, orb2, self._ensure_complex(val), self._coulomb_dict) @mutates def append(self, other): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance(other, Orbital): raise TypeError if other in self: raise ValueError self._list.append(other) # TODO: remove this once better position handling is done @mutates def shift_by_vector(self, tag, translation_vector): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag (str): The tag to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [orb for orb in self._list if orb.tag == tag] for orb in orbs: orb.position += translation_vector # TODO: validate @mutates def make_self_consistent(self, sc_params): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self.self_consistency_params = sc_params # TODO: uff @mutates def set_excitation(self, from_state, to_state, excited_electrons): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr(maybe_int): if isinstance(maybe_int, int): return jnp.array([maybe_int]) if isinstance(maybe_int, list): maybe_int = jnp.array(maybe_int) if isinstance(maybe_int, jax.Array): return ( jnp.array(maybe_int) if maybe_int.ndim > 1 else jnp.array([maybe_int]) ) raise TypeError self.from_state = maybe_int_to_arr(from_state) self.to_state = maybe_int_to_arr(to_state) self.excited_electrons = maybe_int_to_arr(excited_electrons) @mutates def set_dipole_transition(self, orb_or_index1, orb_or_index2, arr): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._transitions[(orb_or_index1, orb_or_index2)] = jnp.array(arr).astype( complex ) # TODO: bla bla bla @property @recomputes def homo(self): # TODO: hmmm return jnp.diag(self._stationary_density_matrix).nonzero()[0][-1] @property @recomputes def positions(self): return self._positions @property @recomputes def eigenvectors(self): return self._eigenvectors @property @recomputes def energies(self): return self._energies # TODO: uff decorator inception, also should return copies to avoid weirdness @property @recomputes def hamiltonian(self): return self._hamiltonian @property @recomputes def coulomb(self): return self._coulomb @property @recomputes def initial_density_matrix(self): return self._initial_density_matrix @property @recomputes def stationary_density_matrix(self): return self._stationary_density_matrix @property @recomputes def quadrupole_operator(self): \"\"\" Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: jax.Array: A tensor representing the quadrupole operator. \"\"\" dip = self.dipole_operator term = jnp.einsum(\"ijk,jlm->ilkm\", dip, dip) diag = jnp.einsum(\"ijk,jlk->il\", dip, dip) diag = jnp.einsum(\"ij,kl->ijkl\", diag, jnp.eye(term.shape[-1])) return 3 * term - diag @property @recomputes def dipole_operator(self): \"\"\" Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. \"\"\" N = self.positions.shape[0] dipole_operator = jnp.zeros((3, N, N)).astype(complex) for i in range(3): dipole_operator = dipole_operator.at[i, :, :].set( jnp.diag(self._positions[:, i] / 2) ) for orbital_combination, value in self._transitions.items(): i, j = self._list.index(orbital_combination[0]), self._list.index( orbital_combination[1] ) k = value.nonzero()[0] dipole_operator = dipole_operator.at[k, i, j].set(value[k]) return dipole_operator + jnp.transpose(dipole_operator, (0, 2, 1)).conj() @property @recomputes def velocity_operator(self): \"\"\" Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. \"\"\" if self._transitions is None: x_times_h = jnp.einsum(\"ij,iL->ijL\", self._hamiltonian, self._positions) h_times_x = jnp.einsum(\"ij,jL->ijL\", self._hamiltonian, self._positions) else: positions = self.dipole_operator x_times_h = jnp.einsum(\"kj,Lik->Lij\", self._hamiltonian, positions) h_times_x = jnp.einsum(\"ik,Lkj->Lij\", self._hamiltonian, positions) return -1j * (x_times_h - h_times_x) @property @recomputes def transition_energies(self): \"\"\" Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: jax.Array: The element `arr[i,j]` contains the transition energy from `i` to `j`. \"\"\" return self._energies[:, None] - self._energies @property @recomputes def wigner_weisskopf_transition_rates(self): \"\"\" Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: jax.Array: The element `arr[i,j]` contains the transition rate from `i` to `j`. \"\"\" charge = 1.602e-19 eps_0 = 8.85 * 1e-12 hbar = 1.0545718 * 1e-34 c = 3e8 # 137 (a.u.) factor = 1.6e-29 * charge / (3 * jnp.pi * eps_0 * hbar**2 * c**3) te = self.transition_energies transition_dipole_moments = self.transform_to_energy_basis(self.dipole_operator) return ( (te * (te > self.eps)) ** 3 * jnp.squeeze(transition_dipole_moments**2) * factor ) @staticmethod def _transform_basis(observable, vectors): dims_einsum_strings = {2: \"ij,jk,lk->il\", 3: \"ij,mjk,lk->mil\"} einsum_string = dims_einsum_strings[(observable.ndim)] return jnp.einsum(einsum_string, vectors, observable, vectors.conj()) def transform_to_site_basis(self, observable): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self._transform_basis(observable, self._eigenvectors) def transform_to_energy_basis(self, observable):# \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self._transform_basis(observable, self._eigenvectors.conj().T) @recomputes def get_charge(density_matrix: None): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None: return jnp.diag( self.transform_to_site_basis(self.initial_density_matrix) * self.electrons ) else: return jnp.diag(density_matrix * self.electrons) @recomputes def get_dos(self, omega: float, broadening: float = 0.1): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening) gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2) return prefactor * jnp.sum(gaussians) # TODO: make compatbile with orbital @recomputes def get_ldos(self, omega: float, site_index: int, broadening: float = 0.1): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp.abs(self._eigenvectors[site_index, :]) ** 2 prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening) gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2) return prefactor * jnp.sum(weight * gaussians) @recomputes def get_epi(self, rho: jax.Array, omega: float, epsilon: float = None) -> float: \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = self.params.eps if epsilon is None else epsilon rho_without_diagonal = jnp.abs(rho - jnp.diag(jnp.diag(rho))) rho_normalized = rho_without_diagonal / jnp.linalg.norm(rho_without_diagonal) te = self.transition_energies excitonic_transitions = ( rho_normalized / (te * (te > self.eps) - omega + 1j * epsilon) ** 2 ) return 1 - jnp.sum(jnp.abs(excitonic_transitions * rho_normalized)) / ( jnp.linalg.norm(rho_normalized) * jnp.linalg.norm(excitonic_transitions) ) @recomputes def get_induced_field(self, positions: jax.Array, density_matrix): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self._positions[:, None] - positions # scalar distances denominator = jnp.linalg.norm(vec_r, axis=2) ** 3 # normalize distance vector array point_charge = jnp.nan_to_num( vec_r / denominator[:, :, None], posinf=0.0, neginf=0.0 ) # compute charge via occupations in site basis charge = self.electrons * self.transform_to_site_basis(density_matrix).real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp.sum(point_charge * charge[:, None, None], axis=0) return e_field @staticmethod def get_expectation_value(operator, density_matrix): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { (3, 2): \"ijk,kj->i\", (3, 3): \"ijk,lkj->il\", (2, 3): \"ij,kji->k\", (2, 2): \"ij,ji->\", } return jnp.einsum( dims_einsum_strings[(operator.ndim, density_matrix.ndim)], operator, density_matrix, ) # TODO: uff, all of the methods below should be rewritten def get_expectation_value_time_domain(self, *args, **kwargs): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs.pop(\"operator\", None) correction = self.transform_to_site_basis(self.stationary_density_matrix) time_axis, density_matrices = self.get_density_matrix_time_domain( *args, **kwargs ) try: return time_axis, self.electrons * self.get_expectation_value( correction - density_matrices.ys, operator ) except AttributeError: return time_axis, self.electrons * self.get_expectation_value( correction - density_matrices, operator ) def get_expectation_value_frequency_domain(self, *args, **kwargs): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" omega_min = kwargs.pop(\"omega_min\", 0) omega_max = kwargs.pop(\"omega_max\", 100) time_axis, exp_val_td = self.get_expectation_value_time_domain(*args, **kwargs) omega, exp_val_omega = _numerics.get_fourier_transform(time_axis, exp_val_td) mask = (omega >= omega_min) & (omega <= omega_max) try: electric_field = jax.vmap(kwargs[\"illumination\"])(time_axis) field_omega = _numerics.get_fourier_transform( time_axis, electric_field, return_omega_axis=False ) return omega[mask], exp_val_omega[mask], field_omega[mask] except KeyError: return omega[mask], exp_val_omega[mask] @recomputes def get_density_matrix_time_domain( self, end_time: float, illumination: Callable[[float], jax.Array], start_time: Optional[float] = None, steps_time: Optional[int] = None, skip: Optional[int] = None, relaxation_rate: Union[float, jax.Array] = None, saturation_functional: Callable[[float], float] = lambda x: 1 / (1 + jnp.exp(-1e6 * (2.0 - x))), use_old_method: bool = False, include_induced_contribution: bool = False, use_rwa=False, compute_only_at=None, coulomb_strength=1.0, solver=diffrax.Dopri5(), stepsize_controller=diffrax.PIDController(rtol=1e-10, atol=1e-10), ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float(start_time) if start_time is not None else 0.0 steps_time = int(steps_time) if steps_time is not None else int(end_time * 1000) time_axis = jnp.linspace(start_time, end_time, steps_time) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None: relaxation_function = lambda r: 0.0 elif isinstance(relaxation_rate, jax.Array): relaxation_function = _numerics.lindblad_saturation_functional( self._eigenvectors, relaxation_rate, saturation_functional, self.electrons, self._stationary_density_matrix, ) else: relaxation_function = _numerics.relaxation_time_approximation( relaxation_rate, self.transform_to_site_basis(self._stationary_density_matrix), ) # Verify that illumination is a callable if not callable(illumination): raise TypeError(\"Provide a function for e-field\") # Initialize common variables initial_density_matrix = self.transform_to_site_basis( self._initial_density_matrix ) stationary_density_matrix = self.transform_to_site_basis( self._stationary_density_matrix ) coulomb_field_to_from = _numerics.get_coulomb_field_to_from( self.positions, self.positions, compute_only_at ) # TODO: not very elegant: we just dump every argument in there by default return time_axis[::skip], _numerics.integrate_master_equation( self._hamiltonian, coulomb_strength * self._coulomb, self.dipole_operator, self.electrons, self.velocity_operator, initial_density_matrix, stationary_density_matrix, time_axis, illumination, relaxation_function, coulomb_field_to_from, include_induced_contribution, use_rwa, solver, stepsize_controller, use_old_method, skip, ) # TODO: uff, again verbose def get_polarizability_rpa( self, omegas, relaxation_rate, polarization, coulomb_strength=1.0, hungry=False, phi_ext=None, ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (bool): speed up the simulation up, taking more RAM. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics.rpa_polarizability_function( self, relaxation_rate, polarization, coulomb_strength, phi_ext, hungry ) return jax.lax.map(alpha, omegas) def get_susceptibility_rpa( self, omegas, relaxation_rate, coulomb_strength=1.0, hungry=False ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (bool): speed up the simulation up, taking more RAM. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics.rpa_polarizability_function( self, relaxation_rate, coulomb_strength, hungry ) return jax.lax.map(sus, omegas) dipole_operator property Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: \u2013 jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. quadrupole_operator property Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: \u2013 jax.Array: A tensor representing the quadrupole operator. transition_energies property Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition energy from i to j . velocity_operator property Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: \u2013 jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. wigner_weisskopf_transition_rates property Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition rate from i to j . append(other) Appends an orbital to the list, ensuring it is not already present. Parameters: other ( Orbital ) \u2013 The orbital to append. Raises: TypeError \u2013 If other is not an instance of Orbital. ValueError \u2013 If other is already in the list. Source code in src/granad/orbitals.py @mutates def append(self, other): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance(other, Orbital): raise TypeError if other in self: raise ValueError self._list.append(other) get_charge(density_matrix) Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix ( Array ) \u2013 The density matrix to use for calculating charge. Returns: \u2013 jax.Array: A diagonal array representing charges at each site. Source code in src/granad/orbitals.py @recomputes def get_charge(density_matrix: None): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None: return jnp.diag( self.transform_to_site_basis(self.initial_density_matrix) * self.electrons ) else: return jnp.diag(density_matrix * self.electrons) get_density_matrix_time_domain(end_time, illumination, start_time=None, steps_time=None, skip=None, relaxation_rate=None, saturation_functional=lambda x: 1 / 1 + jnp.exp(-1000000.0 * 2.0 - x), use_old_method=False, include_induced_contribution=False, use_rwa=False, compute_only_at=None, coulomb_strength=1.0, solver=diffrax.Dopri5(), stepsize_controller=diffrax.PIDController(rtol=1e-10, atol=1e-10)) Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time ( float ) \u2013 The end time for the simulation. illumination ( Callable [[ float ], Array ] ) \u2013 A function that returns the electric field at a given time. start_time ( Optional [ float ] , default: None ) \u2013 The start time for the simulation, defaults to zero. steps_time ( Optional [ int ] , default: None ) \u2013 The number of time steps to simulate, defaults to int(end_time * 1000) skip ( Optional [ int ] , default: None ) \u2013 The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate ( Union [ float , Array ] , default: None ) \u2013 The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional ( Callable [[ float ], float ] , default: lambda x: 1 / 1 + exp (-1000000.0 * 2.0 - x ) ) \u2013 A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method ( bool , default: False ) \u2013 Flag to use the old RK method. include_induced_contribution ( bool , default: False ) \u2013 Whether to include induced contributions in the simulation. use_rwa ( bool , default: False ) \u2013 Whether to apply the rotating wave approximation. compute_only_at ( Optional [ any ] , default: None ) \u2013 Specific orbital indices at which the induced field computation is performed. coulomb_strength ( float , default: 1.0 ) \u2013 Strength of Coulomb interactions. solver ( Solver , default: Dopri5 () ) \u2013 The differential equation solver to use. stepsize_controller ( StepSizeController , default: PIDController (rtol=1e-10, atol=1e-10) ) \u2013 The controller for the solver's step size. Returns: \u2013 Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. Source code in src/granad/orbitals.py @recomputes def get_density_matrix_time_domain( self, end_time: float, illumination: Callable[[float], jax.Array], start_time: Optional[float] = None, steps_time: Optional[int] = None, skip: Optional[int] = None, relaxation_rate: Union[float, jax.Array] = None, saturation_functional: Callable[[float], float] = lambda x: 1 / (1 + jnp.exp(-1e6 * (2.0 - x))), use_old_method: bool = False, include_induced_contribution: bool = False, use_rwa=False, compute_only_at=None, coulomb_strength=1.0, solver=diffrax.Dopri5(), stepsize_controller=diffrax.PIDController(rtol=1e-10, atol=1e-10), ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float(start_time) if start_time is not None else 0.0 steps_time = int(steps_time) if steps_time is not None else int(end_time * 1000) time_axis = jnp.linspace(start_time, end_time, steps_time) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None: relaxation_function = lambda r: 0.0 elif isinstance(relaxation_rate, jax.Array): relaxation_function = _numerics.lindblad_saturation_functional( self._eigenvectors, relaxation_rate, saturation_functional, self.electrons, self._stationary_density_matrix, ) else: relaxation_function = _numerics.relaxation_time_approximation( relaxation_rate, self.transform_to_site_basis(self._stationary_density_matrix), ) # Verify that illumination is a callable if not callable(illumination): raise TypeError(\"Provide a function for e-field\") # Initialize common variables initial_density_matrix = self.transform_to_site_basis( self._initial_density_matrix ) stationary_density_matrix = self.transform_to_site_basis( self._stationary_density_matrix ) coulomb_field_to_from = _numerics.get_coulomb_field_to_from( self.positions, self.positions, compute_only_at ) # TODO: not very elegant: we just dump every argument in there by default return time_axis[::skip], _numerics.integrate_master_equation( self._hamiltonian, coulomb_strength * self._coulomb, self.dipole_operator, self.electrons, self.velocity_operator, initial_density_matrix, stationary_density_matrix, time_axis, illumination, relaxation_function, coulomb_field_to_from, include_induced_contribution, use_rwa, solver, stepsize_controller, use_old_method, skip, ) get_dos(omega, broadening=0.1) Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the DOS. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The integrated density of states at the specified frequency. Source code in src/granad/orbitals.py @recomputes def get_dos(self, omega: float, broadening: float = 0.1): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening) gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2) return prefactor * jnp.sum(gaussians) get_epi(rho, omega, epsilon=None) Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho ( Array ) \u2013 The density matrix to consider for EPI calculation. omega ( float ) \u2013 The frequency to evaluate the EPI at. epsilon ( float , default: None ) \u2013 The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float ( float ) \u2013 The EPI. Source code in src/granad/orbitals.py @recomputes def get_epi(self, rho: jax.Array, omega: float, epsilon: float = None) -> float: \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = self.params.eps if epsilon is None else epsilon rho_without_diagonal = jnp.abs(rho - jnp.diag(jnp.diag(rho))) rho_normalized = rho_without_diagonal / jnp.linalg.norm(rho_without_diagonal) te = self.transition_energies excitonic_transitions = ( rho_normalized / (te * (te > self.eps) - omega + 1j * epsilon) ** 2 ) return 1 - jnp.sum(jnp.abs(excitonic_transitions * rho_normalized)) / ( jnp.linalg.norm(rho_normalized) * jnp.linalg.norm(excitonic_transitions) ) get_expectation_value(operator, density_matrix) staticmethod Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator ( Array ) \u2013 The operator for which the expectation value is calculated. density_matrix ( Array ) \u2013 The density matrix representing the state of the system. Returns: \u2013 jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. Source code in src/granad/orbitals.py @staticmethod def get_expectation_value(operator, density_matrix): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { (3, 2): \"ijk,kj->i\", (3, 3): \"ijk,lkj->il\", (2, 3): \"ij,kji->k\", (2, 2): \"ij,ji->\", } return jnp.einsum( dims_einsum_strings[(operator.ndim, density_matrix.ndim)], operator, density_matrix, ) get_expectation_value_frequency_domain(*args, **kwargs) Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: \u2013 Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. Source code in src/granad/orbitals.py def get_expectation_value_frequency_domain(self, *args, **kwargs): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" omega_min = kwargs.pop(\"omega_min\", 0) omega_max = kwargs.pop(\"omega_max\", 100) time_axis, exp_val_td = self.get_expectation_value_time_domain(*args, **kwargs) omega, exp_val_omega = _numerics.get_fourier_transform(time_axis, exp_val_td) mask = (omega >= omega_min) & (omega <= omega_max) try: electric_field = jax.vmap(kwargs[\"illumination\"])(time_axis) field_omega = _numerics.get_fourier_transform( time_axis, electric_field, return_omega_axis=False ) return omega[mask], exp_val_omega[mask], field_omega[mask] except KeyError: return omega[mask], exp_val_omega[mask] get_expectation_value_time_domain(*args, **kwargs) Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: \u2013 Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. Source code in src/granad/orbitals.py def get_expectation_value_time_domain(self, *args, **kwargs): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs.pop(\"operator\", None) correction = self.transform_to_site_basis(self.stationary_density_matrix) time_axis, density_matrices = self.get_density_matrix_time_domain( *args, **kwargs ) try: return time_axis, self.electrons * self.get_expectation_value( correction - density_matrices.ys, operator ) except AttributeError: return time_axis, self.electrons * self.get_expectation_value( correction - density_matrices, operator ) get_group_ids() Retrieves a list of group IDs for all orbitals managed by this object. Returns: \u2013 List[int]: A list of group IDs for each orbital. Source code in src/granad/orbitals.py def get_group_ids(self): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [orb.group_id for orb in self._list] get_induced_field(positions, density_matrix) Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions ( Array ) \u2013 The positions at which to evaluate the induced field. density_matrix ( Array ) \u2013 The density matrix used to calculate the induced field. Returns: \u2013 jax.Array: The resulting electric field vector at each position. Source code in src/granad/orbitals.py @recomputes def get_induced_field(self, positions: jax.Array, density_matrix): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self._positions[:, None] - positions # scalar distances denominator = jnp.linalg.norm(vec_r, axis=2) ** 3 # normalize distance vector array point_charge = jnp.nan_to_num( vec_r / denominator[:, :, None], posinf=0.0, neginf=0.0 ) # compute charge via occupations in site basis charge = self.electrons * self.transform_to_site_basis(density_matrix).real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp.sum(point_charge * charge[:, None, None], axis=0) return e_field get_ldos(omega, site_index, broadening=0.1) Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the LDOS. site_index ( int ) \u2013 The site index to evaluate the LDOS at. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The local density of states at the specified site and frequency. Source code in src/granad/orbitals.py @recomputes def get_ldos(self, omega: float, site_index: int, broadening: float = 0.1): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp.abs(self._eigenvectors[site_index, :]) ** 2 prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening) gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2) return prefactor * jnp.sum(weight * gaussians) get_polarizability_rpa(omegas, relaxation_rate, polarization, coulomb_strength=1.0, hungry=False, phi_ext=None) Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas ( Array ) \u2013 Frequencies at which to calculate polarizability. relaxation_rate ( float ) \u2013 The relaxation time parameter. polarization ( Array ) \u2013 Polarization directions or modes. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interaction in the calculations. hungry ( bool , default: False ) \u2013 speed up the simulation up, taking more RAM. phi_ext ( Optional [ Array ] , default: None ) \u2013 External potential influences, if any. Returns: \u2013 jax.Array: The calculated polarizabilities at the specified frequencies. Source code in src/granad/orbitals.py def get_polarizability_rpa( self, omegas, relaxation_rate, polarization, coulomb_strength=1.0, hungry=False, phi_ext=None, ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (bool): speed up the simulation up, taking more RAM. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics.rpa_polarizability_function( self, relaxation_rate, polarization, coulomb_strength, phi_ext, hungry ) return jax.lax.map(alpha, omegas) get_susceptibility_rpa(omegas, relaxation_rate, coulomb_strength=1.0, hungry=False) Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas ( Array ) \u2013 The frequencies at which to compute susceptibility. relaxation_rate ( float ) \u2013 The relaxation time affecting susceptibility calculations. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interactions considered in the calculations. hungry ( bool , default: False ) \u2013 speed up the simulation up, taking more RAM. Returns: \u2013 jax.Array: The susceptibility values at the given frequencies. Source code in src/granad/orbitals.py def get_susceptibility_rpa( self, omegas, relaxation_rate, coulomb_strength=1.0, hungry=False ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (bool): speed up the simulation up, taking more RAM. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics.rpa_polarizability_function( self, relaxation_rate, coulomb_strength, hungry ) return jax.lax.map(sus, omegas) get_unique_group_ids() Retrieves a unique set of group IDs from all orbitals. Returns: \u2013 List[int]: A list of unique group IDs. Source code in src/granad/orbitals.py def get_unique_group_ids(self): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list(set(self.get_group_ids())) make_self_consistent(sc_params) Configures the list for self-consistent field calculations. Parameters: sc_params ( dict ) \u2013 Parameters for self-consistency. Source code in src/granad/orbitals.py @mutates def make_self_consistent(self, sc_params): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self.self_consistency_params = sc_params set_coulomb_element(orb_or_index1, orb_or_index2, val) Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Coulomb interaction element. Source code in src/granad/orbitals.py def set_coulomb_element(self, orb_or_index1, orb_or_index2, val): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._set_coupling(orb1, orb2, self._ensure_complex(val), self._coulomb_dict) set_dipole_transition(orb_or_index1, orb_or_index2, arr) Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first part of the transition. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second part of the transition. arr ( Array ) \u2013 The 3-element array containing dipole transition elements. Source code in src/granad/orbitals.py @mutates def set_dipole_transition(self, orb_or_index1, orb_or_index2, arr): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._transitions[(orb_or_index1, orb_or_index2)] = jnp.array(arr).astype( complex ) set_excitation(from_state, to_state, excited_electrons) Sets up an excitation process from one state to another with specified electrons. Parameters: from_state ( int, list, or jax.Array ) \u2013 The initial state index or indices. to_state ( int, list, or jax.Array ) \u2013 The final state index or indices. excited_electrons ( int, list, or jax.Array ) \u2013 The indices of electrons to be excited. Notes The states and electron indices may be specified as scalars, lists, or arrays. Source code in src/granad/orbitals.py @mutates def set_excitation(self, from_state, to_state, excited_electrons): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr(maybe_int): if isinstance(maybe_int, int): return jnp.array([maybe_int]) if isinstance(maybe_int, list): maybe_int = jnp.array(maybe_int) if isinstance(maybe_int, jax.Array): return ( jnp.array(maybe_int) if maybe_int.ndim > 1 else jnp.array([maybe_int]) ) raise TypeError self.from_state = maybe_int_to_arr(from_state) self.to_state = maybe_int_to_arr(to_state) self.excited_electrons = maybe_int_to_arr(excited_electrons) set_groups_coulomb(orb_or_group_id1, orb_or_group_id2, func) Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the Coulomb interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py def set_groups_coulomb(self, orb_or_group_id1, orb_or_group_id2, func): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1, group_id2 = self._maybe_orbs_to_group_ids( (orb_or_group_id1, orb_or_group_id2) ) self._set_coupling( group_id1, group_id2, self._ensure_complex(func), self._coulomb_dict ) set_groups_hopping(orb_or_group_id1, orb_or_group_id2, func) Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the hopping interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py def set_groups_hopping(self, orb_or_group_id1, orb_or_group_id2, func): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1, group_id2 = self._maybe_orbs_to_group_ids( (orb_or_group_id1, orb_or_group_id2) ) self._set_coupling( group_id1, group_id2, self._ensure_complex(func), self._hopping_dict ) set_hamiltonian_element(orb_or_index1, orb_or_index2, val) Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Hamiltonian element. Source code in src/granad/orbitals.py def set_hamiltonian_element(self, orb_or_index1, orb_or_index2, val): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._set_coupling(orb1, orb2, self._ensure_complex(val), self._hopping_dict) shift_by_vector(tag, translation_vector) Shifts all orbitals with a specific tag by a given vector. Parameters: tag ( str ) \u2013 The tag to match orbitals. translation_vector ( Array ) \u2013 The vector by which to translate the orbital positions. Notes This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py @mutates def shift_by_vector(self, tag, translation_vector): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag (str): The tag to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [orb for orb in self._list if orb.tag == tag] for orb in orbs: orb.position += translation_vector transform_to_energy_basis(observable) Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the energy basis. Source code in src/granad/orbitals.py def transform_to_energy_basis(self, observable):# \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self._transform_basis(observable, self._eigenvectors.conj().T) transform_to_site_basis(observable) Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the site basis. Source code in src/granad/orbitals.py def transform_to_site_basis(self, observable): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self._transform_basis(observable, self._eigenvectors)","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#granad.orbitals.Orbital","text":"Represents the quantum state of an electron in an atom with specific properties. Attributes: position ( Array ) \u2013 The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index ( Optional [ int ] ) \u2013 An optional index representing the layer of the orbital within its atom, may be None if not specified. tag ( Optional [ str ] ) \u2013 An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level ( Optional [ int ] ) \u2013 The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum ( Optional [ int ] ) \u2013 The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z ( Optional [ int ] ) \u2013 The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin ( Optional [ int ] ) \u2013 The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name ( Optional [ str ] ) \u2013 The name of the atom this orbital belongs to, can be None if not applicable. group_id ( int ) \u2013 A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. Source code in src/granad/orbitals.py @dataclass class Orbital: \"\"\" Represents the quantum state of an electron in an atom with specific properties. Attributes: position (jax.Array): The position of the orbital in space, initialized by default to a zero position. This field is not used in hashing or comparison of instances. layer_index (Optional[int]): An optional index representing the layer of the orbital within its atom, may be None if not specified. tag (Optional[str]): An optional tag for additional identification or categorization of the orbital, defaults to None. energy_level (Optional[int]): The principal quantum number indicating the energy level of the orbital, can be None. angular_momentum (Optional[int]): The quantum number representing the angular momentum of the orbital, optional and can be None. angular_momentum_z (Optional[int]): The magnetic quantum number related to the z-component of the orbital's angular momentum, optional. spin (Optional[int]): The spin quantum number of the orbital, indicating its intrinsic angular momentum, optional and may be None. atom_name (Optional[str]): The name of the atom this orbital belongs to, can be None if not applicable. group_id (int): A group identifier for the orbital, automatically assigned by a Watchdog class default factory method. \"\"\" position: jax.Array = field(default_factory=pos_zero, hash=False, compare=False) layer_index: Optional[int] = None tag: Optional[str] = None energy_level: Optional[int] = None angular_momentum: Optional[int] = None angular_momentum_z: Optional[int] = None spin: Optional[int] = None atom_name: Optional[str] = None group_id: int = field(default_factory=_watchdog._Watchdog.next_value) def __post_init__(self): object.__setattr__(self, \"position\", jnp.array(self.position).astype(float)) def __hash__(self): # Include only immutable fields in hash calculation return hash( ( self.layer_index, self.tag, self.energy_level, self.angular_momentum, self.angular_momentum_z, self.angular_momentum, self.spin, self.atom_name, self.group_id, ) ) def __str__(self): return pformat(vars(self), sort_dicts=False) # TODO: bla bla bla ... this should be shorter but im too tired def __eq__(self, other): if not isinstance(other, Orbital): return NotImplemented return self.group_id == other.group_id and self.layer_index == other.layer_index def __lt__(self, other): if not isinstance(other, Orbital): return NotImplemented return self.group_id < self.group_id def __le__(self, other): return self < other or self == other def __gt__(self, other): return not self <= other def __ge__(self, other): return not self < other def __ne__(self, other): return not self == other","title":"Orbital"},{"location":"api/#granad.orbitals.OrbitalList","text":"A list of orbitals. Source code in src/granad/orbitals.py @plotting_methods class OrbitalList: \"\"\"A list of orbitals.\"\"\" def __init__(self, orbs, _hopping_dict=None, _coulomb_dict=None): # couplings are dicts mapping orbital pairs to couplings self._hopping_dict = ( _hopping_dict if _hopping_dict is not None else _SortedTupleDict() ) self._coulomb_dict = ( _coulomb_dict if _coulomb_dict is not None else _SortedTupleDict() ) self._transitions = _SortedTupleDict() # contains all high-level simulation information self._list = list(orbs) if orbs is not None else [] # flag for recomputing state self._recompute = True # TODO: this is a bunch of stuff and must be better doable self.from_state = jnp.array([0]) self.to_state = jnp.array([0]) self.excited_electrons = jnp.array([0]) self.eps = 1e-5 self.beta = jnp.inf self.self_consistency_params = {} self.spin_degeneracy = 2.0 self.electrons = len(self._list) def __len__(self): return len(self._list) # can't mutate, because orbitals are immutable def __getitem__(self, position): return self._list[position] def __repr__(self): return repr(self._list) # TODO: hmmm def __str__(self): info = f\"List with {len(self)} orbitals, {self.electrons} electrons.\" excited = f\"{self.excited_electrons} electrons excited from {self.from_state} to {self.to_state}.\" groups = \"\\n\".join( [ f\"group id {key} : {val} orbitals\" for key, val in Counter(self.get_group_ids()).items() ] ) return \"\\n\".join((info, excited, groups)) def __iter__(self): return iter(self._list) # TODO: uff, addition, or, in general, mutation should wipe all attributes except for coupling def __add__(self, other): if not self._are_orbs(other): raise TypeError if any(orb in other for orb in self._list): raise ValueError if isinstance(other, OrbitalList): new_hopping_dict = self._hopping_dict.copy() new_hopping_dict.update(other._hopping_dict) new_coulomb_dict = self._coulomb_dict.copy() new_coulomb_dict.update(other._coulomb_dict) return OrbitalList( (self._list + list(other)).copy(), _SortedTupleDict(new_hopping_dict), _SortedTupleDict(new_coulomb_dict), ) @mutates def __setitem__(self, position, value): if isinstance(value, Orbital): self._list[position] = value raise TypeError def _delete_coupling(self, orb, coupling): keys_to_remove = [key for key in coupling if orb in key] for key in keys_to_remove: del coupling[key] @mutates def __delitem__(self, position): orb = self._list[position] self._delete_coupling(orb, self._hopping_dict) self._delete_coupling(orb, self._coulomb_dict) del self._list[position] @staticmethod def _are_orbs(candidate): return all(isinstance(orb, Orbital) for orb in candidate) @mutates def _set_coupling(self, orb_or_group_id1, orb_or_group_id2, val_or_func, coupling): coupling[(orb_or_group_id1, orb_or_group_id2)] = val_or_func # TODO: we may want to differentiate through this, also this is private so better not wrap return val into container def _hamiltonian_coulomb(self): def fill_matrix(matrix, coupling_dict): # TODO: there should be an internal dummy = jnp.arange(len(self)) triangle_mask = dummy[:, None] >= dummy # TODO: in principle we can build a big tensor NxNxgroups, vmap over the last axis and sum the groups # first, we loop over all group_id couplings => interactions between groups for key, function in coupling_dict.group_id_items(): # TODO: big uff: we rely on the correct ordering of the group_ids for cols and rows, first key is always smaller than last keys => we get upper triangular valid indices # if it were the other way around, these would be zeroed by the triangle mask cols = group_ids == key[0] rows = (group_ids == key[1])[:, None] combination_indices = jnp.logical_and(rows, cols) valid_indices = jnp.logical_and(triangle_mask, combination_indices) function = jax.vmap(function) matrix = matrix.at[valid_indices].set( function(distances[valid_indices]) ) # we now set single elements rows, cols, vals = [], [], [] for key, val in coupling_dict.orbital_items(): rows.append(self._list.index(key[0])) cols.append(self._list.index(key[1])) vals.append(val) matrix = matrix.at[rows, cols].set(vals) return matrix + matrix.conj().T - jnp.diag(jnp.diag(matrix)) # TODO: oh noes rounding again, but don't know what to do else positions = self._get_positions() distances = jnp.round( jnp.linalg.norm(positions - positions[:, None], axis=-1), 6 ) group_ids = jnp.array(self.get_group_ids()) hamiltonian = fill_matrix( jnp.zeros((len(self), len(self))).astype(complex), self._hopping_dict ) coulomb = fill_matrix( jnp.zeros((len(self), len(self))).astype(complex), self._coulomb_dict ) return hamiltonian, coulomb def _get_positions(self): return jnp.array([orb.position for orb in self._list]) def _ensure_complex(self, func_or_val): if callable(func_or_val): return lambda x: func_or_val(x) + 0.0j if isinstance(func_or_val, (int, float, complex)): return func_or_val + 0.0j raise TypeError # TODO: bla bla bla ... incredibly verbose, but couldn't think of anything better yet def _maybe_orbs_to_group_ids(self, maybe_orbs): def convert(maybe_orb): # TODO: check if this is really a group_id if isinstance(maybe_orb, int): return maybe_orb if isinstance(maybe_orb, Orbital): return maybe_orb.group_id return \"You have passed something that is neither an orbital nor a group_id\" return [convert(x) for x in maybe_orbs] def _maybe_indices_to_orbs(self, maybe_indices): def convert(maybe_index): if isinstance(maybe_index, int): return self._list[maybe_index] if isinstance(maybe_index, Orbital): return maybe_index return \"You have passed something that is neither an orbital nor an index\" return [convert(x) for x in maybe_indices] def _build(self): # TODO: uff assert len(self) > 0 self._positions = self._get_positions() self._hamiltonian, self._coulomb = self._hamiltonian_coulomb() self._eigenvectors, self._energies = jax.lax.linalg.eigh(self._hamiltonian) self._initial_density_matrix = _numerics._density_matrix( self._energies, self.electrons, self.spin_degeneracy, self.eps, self.from_state, self.to_state, self.excited_electrons, self.beta, ) self._stationary_density_matrix = _numerics._density_matrix( self._energies, self.electrons, self.spin_degeneracy, self.eps, jnp.array([0]), jnp.array([0]), jnp.array([0]), self.beta, ) # TODO: uff if self.self_consistency_params: ( self._hamiltonian, self._initial_density_matrix, self._stationary_density_matrix, self._energies, self._eigenvectors, ) = _get_self_consistent( self._hamiltonian, self._coulomb, self._positions, self.spin_degeneracy, self.electrons, self.eps, self._eigenvectors, self._static_density_matrix, **self.self_consistent_params, ) def get_group_ids(self): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [orb.group_id for orb in self._list] def get_unique_group_ids(self): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list(set(self.get_group_ids())) def set_groups_hopping(self, orb_or_group_id1, orb_or_group_id2, func): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1, group_id2 = self._maybe_orbs_to_group_ids( (orb_or_group_id1, orb_or_group_id2) ) self._set_coupling( group_id1, group_id2, self._ensure_complex(func), self._hopping_dict ) def set_groups_coulomb(self, orb_or_group_id1, orb_or_group_id2, func): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1, group_id2 = self._maybe_orbs_to_group_ids( (orb_or_group_id1, orb_or_group_id2) ) self._set_coupling( group_id1, group_id2, self._ensure_complex(func), self._coulomb_dict ) def set_hamiltonian_element(self, orb_or_index1, orb_or_index2, val): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._set_coupling(orb1, orb2, self._ensure_complex(val), self._hopping_dict) def set_coulomb_element(self, orb_or_index1, orb_or_index2, val): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._set_coupling(orb1, orb2, self._ensure_complex(val), self._coulomb_dict) @mutates def append(self, other): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance(other, Orbital): raise TypeError if other in self: raise ValueError self._list.append(other) # TODO: remove this once better position handling is done @mutates def shift_by_vector(self, tag, translation_vector): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag (str): The tag to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [orb for orb in self._list if orb.tag == tag] for orb in orbs: orb.position += translation_vector # TODO: validate @mutates def make_self_consistent(self, sc_params): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self.self_consistency_params = sc_params # TODO: uff @mutates def set_excitation(self, from_state, to_state, excited_electrons): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr(maybe_int): if isinstance(maybe_int, int): return jnp.array([maybe_int]) if isinstance(maybe_int, list): maybe_int = jnp.array(maybe_int) if isinstance(maybe_int, jax.Array): return ( jnp.array(maybe_int) if maybe_int.ndim > 1 else jnp.array([maybe_int]) ) raise TypeError self.from_state = maybe_int_to_arr(from_state) self.to_state = maybe_int_to_arr(to_state) self.excited_electrons = maybe_int_to_arr(excited_electrons) @mutates def set_dipole_transition(self, orb_or_index1, orb_or_index2, arr): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._transitions[(orb_or_index1, orb_or_index2)] = jnp.array(arr).astype( complex ) # TODO: bla bla bla @property @recomputes def homo(self): # TODO: hmmm return jnp.diag(self._stationary_density_matrix).nonzero()[0][-1] @property @recomputes def positions(self): return self._positions @property @recomputes def eigenvectors(self): return self._eigenvectors @property @recomputes def energies(self): return self._energies # TODO: uff decorator inception, also should return copies to avoid weirdness @property @recomputes def hamiltonian(self): return self._hamiltonian @property @recomputes def coulomb(self): return self._coulomb @property @recomputes def initial_density_matrix(self): return self._initial_density_matrix @property @recomputes def stationary_density_matrix(self): return self._stationary_density_matrix @property @recomputes def quadrupole_operator(self): \"\"\" Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: jax.Array: A tensor representing the quadrupole operator. \"\"\" dip = self.dipole_operator term = jnp.einsum(\"ijk,jlm->ilkm\", dip, dip) diag = jnp.einsum(\"ijk,jlk->il\", dip, dip) diag = jnp.einsum(\"ij,kl->ijkl\", diag, jnp.eye(term.shape[-1])) return 3 * term - diag @property @recomputes def dipole_operator(self): \"\"\" Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated. \"\"\" N = self.positions.shape[0] dipole_operator = jnp.zeros((3, N, N)).astype(complex) for i in range(3): dipole_operator = dipole_operator.at[i, :, :].set( jnp.diag(self._positions[:, i] / 2) ) for orbital_combination, value in self._transitions.items(): i, j = self._list.index(orbital_combination[0]), self._list.index( orbital_combination[1] ) k = value.nonzero()[0] dipole_operator = dipole_operator.at[k, i, j].set(value[k]) return dipole_operator + jnp.transpose(dipole_operator, (0, 2, 1)).conj() @property @recomputes def velocity_operator(self): \"\"\" Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian. \"\"\" if self._transitions is None: x_times_h = jnp.einsum(\"ij,iL->ijL\", self._hamiltonian, self._positions) h_times_x = jnp.einsum(\"ij,jL->ijL\", self._hamiltonian, self._positions) else: positions = self.dipole_operator x_times_h = jnp.einsum(\"kj,Lik->Lij\", self._hamiltonian, positions) h_times_x = jnp.einsum(\"ik,Lkj->Lij\", self._hamiltonian, positions) return -1j * (x_times_h - h_times_x) @property @recomputes def transition_energies(self): \"\"\" Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: jax.Array: The element `arr[i,j]` contains the transition energy from `i` to `j`. \"\"\" return self._energies[:, None] - self._energies @property @recomputes def wigner_weisskopf_transition_rates(self): \"\"\" Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: jax.Array: The element `arr[i,j]` contains the transition rate from `i` to `j`. \"\"\" charge = 1.602e-19 eps_0 = 8.85 * 1e-12 hbar = 1.0545718 * 1e-34 c = 3e8 # 137 (a.u.) factor = 1.6e-29 * charge / (3 * jnp.pi * eps_0 * hbar**2 * c**3) te = self.transition_energies transition_dipole_moments = self.transform_to_energy_basis(self.dipole_operator) return ( (te * (te > self.eps)) ** 3 * jnp.squeeze(transition_dipole_moments**2) * factor ) @staticmethod def _transform_basis(observable, vectors): dims_einsum_strings = {2: \"ij,jk,lk->il\", 3: \"ij,mjk,lk->mil\"} einsum_string = dims_einsum_strings[(observable.ndim)] return jnp.einsum(einsum_string, vectors, observable, vectors.conj()) def transform_to_site_basis(self, observable): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self._transform_basis(observable, self._eigenvectors) def transform_to_energy_basis(self, observable):# \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self._transform_basis(observable, self._eigenvectors.conj().T) @recomputes def get_charge(density_matrix: None): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None: return jnp.diag( self.transform_to_site_basis(self.initial_density_matrix) * self.electrons ) else: return jnp.diag(density_matrix * self.electrons) @recomputes def get_dos(self, omega: float, broadening: float = 0.1): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening) gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2) return prefactor * jnp.sum(gaussians) # TODO: make compatbile with orbital @recomputes def get_ldos(self, omega: float, site_index: int, broadening: float = 0.1): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp.abs(self._eigenvectors[site_index, :]) ** 2 prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening) gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2) return prefactor * jnp.sum(weight * gaussians) @recomputes def get_epi(self, rho: jax.Array, omega: float, epsilon: float = None) -> float: \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = self.params.eps if epsilon is None else epsilon rho_without_diagonal = jnp.abs(rho - jnp.diag(jnp.diag(rho))) rho_normalized = rho_without_diagonal / jnp.linalg.norm(rho_without_diagonal) te = self.transition_energies excitonic_transitions = ( rho_normalized / (te * (te > self.eps) - omega + 1j * epsilon) ** 2 ) return 1 - jnp.sum(jnp.abs(excitonic_transitions * rho_normalized)) / ( jnp.linalg.norm(rho_normalized) * jnp.linalg.norm(excitonic_transitions) ) @recomputes def get_induced_field(self, positions: jax.Array, density_matrix): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self._positions[:, None] - positions # scalar distances denominator = jnp.linalg.norm(vec_r, axis=2) ** 3 # normalize distance vector array point_charge = jnp.nan_to_num( vec_r / denominator[:, :, None], posinf=0.0, neginf=0.0 ) # compute charge via occupations in site basis charge = self.electrons * self.transform_to_site_basis(density_matrix).real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp.sum(point_charge * charge[:, None, None], axis=0) return e_field @staticmethod def get_expectation_value(operator, density_matrix): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { (3, 2): \"ijk,kj->i\", (3, 3): \"ijk,lkj->il\", (2, 3): \"ij,kji->k\", (2, 2): \"ij,ji->\", } return jnp.einsum( dims_einsum_strings[(operator.ndim, density_matrix.ndim)], operator, density_matrix, ) # TODO: uff, all of the methods below should be rewritten def get_expectation_value_time_domain(self, *args, **kwargs): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs.pop(\"operator\", None) correction = self.transform_to_site_basis(self.stationary_density_matrix) time_axis, density_matrices = self.get_density_matrix_time_domain( *args, **kwargs ) try: return time_axis, self.electrons * self.get_expectation_value( correction - density_matrices.ys, operator ) except AttributeError: return time_axis, self.electrons * self.get_expectation_value( correction - density_matrices, operator ) def get_expectation_value_frequency_domain(self, *args, **kwargs): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" omega_min = kwargs.pop(\"omega_min\", 0) omega_max = kwargs.pop(\"omega_max\", 100) time_axis, exp_val_td = self.get_expectation_value_time_domain(*args, **kwargs) omega, exp_val_omega = _numerics.get_fourier_transform(time_axis, exp_val_td) mask = (omega >= omega_min) & (omega <= omega_max) try: electric_field = jax.vmap(kwargs[\"illumination\"])(time_axis) field_omega = _numerics.get_fourier_transform( time_axis, electric_field, return_omega_axis=False ) return omega[mask], exp_val_omega[mask], field_omega[mask] except KeyError: return omega[mask], exp_val_omega[mask] @recomputes def get_density_matrix_time_domain( self, end_time: float, illumination: Callable[[float], jax.Array], start_time: Optional[float] = None, steps_time: Optional[int] = None, skip: Optional[int] = None, relaxation_rate: Union[float, jax.Array] = None, saturation_functional: Callable[[float], float] = lambda x: 1 / (1 + jnp.exp(-1e6 * (2.0 - x))), use_old_method: bool = False, include_induced_contribution: bool = False, use_rwa=False, compute_only_at=None, coulomb_strength=1.0, solver=diffrax.Dopri5(), stepsize_controller=diffrax.PIDController(rtol=1e-10, atol=1e-10), ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float(start_time) if start_time is not None else 0.0 steps_time = int(steps_time) if steps_time is not None else int(end_time * 1000) time_axis = jnp.linspace(start_time, end_time, steps_time) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None: relaxation_function = lambda r: 0.0 elif isinstance(relaxation_rate, jax.Array): relaxation_function = _numerics.lindblad_saturation_functional( self._eigenvectors, relaxation_rate, saturation_functional, self.electrons, self._stationary_density_matrix, ) else: relaxation_function = _numerics.relaxation_time_approximation( relaxation_rate, self.transform_to_site_basis(self._stationary_density_matrix), ) # Verify that illumination is a callable if not callable(illumination): raise TypeError(\"Provide a function for e-field\") # Initialize common variables initial_density_matrix = self.transform_to_site_basis( self._initial_density_matrix ) stationary_density_matrix = self.transform_to_site_basis( self._stationary_density_matrix ) coulomb_field_to_from = _numerics.get_coulomb_field_to_from( self.positions, self.positions, compute_only_at ) # TODO: not very elegant: we just dump every argument in there by default return time_axis[::skip], _numerics.integrate_master_equation( self._hamiltonian, coulomb_strength * self._coulomb, self.dipole_operator, self.electrons, self.velocity_operator, initial_density_matrix, stationary_density_matrix, time_axis, illumination, relaxation_function, coulomb_field_to_from, include_induced_contribution, use_rwa, solver, stepsize_controller, use_old_method, skip, ) # TODO: uff, again verbose def get_polarizability_rpa( self, omegas, relaxation_rate, polarization, coulomb_strength=1.0, hungry=False, phi_ext=None, ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (bool): speed up the simulation up, taking more RAM. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics.rpa_polarizability_function( self, relaxation_rate, polarization, coulomb_strength, phi_ext, hungry ) return jax.lax.map(alpha, omegas) def get_susceptibility_rpa( self, omegas, relaxation_rate, coulomb_strength=1.0, hungry=False ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (bool): speed up the simulation up, taking more RAM. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics.rpa_polarizability_function( self, relaxation_rate, coulomb_strength, hungry ) return jax.lax.map(sus, omegas)","title":"OrbitalList"},{"location":"api/#granad.orbitals.OrbitalList.dipole_operator","text":"Computes the dipole operator using positions and transition values. The diagonal is set by position components, and the off-diagonal elements are set by transition matrix values. Returns: \u2013 jax.Array: A 3D tensor representing the dipole operator, symmetrized and complex conjugated.","title":"dipole_operator"},{"location":"api/#granad.orbitals.OrbitalList.quadrupole_operator","text":"Calculates the quadrupole operator based on the dipole operator terms. It combines products of the dipole terms and their differences from the identity matrix scaled by the diagonal components. Returns: \u2013 jax.Array: A tensor representing the quadrupole operator.","title":"quadrupole_operator"},{"location":"api/#granad.orbitals.OrbitalList.transition_energies","text":"Computes independent-particle transition energies associated with the TB-Hamiltonian of a stack. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition energy from i to j .","title":"transition_energies"},{"location":"api/#granad.orbitals.OrbitalList.velocity_operator","text":"Calculates the velocity operator as the commutator of position with the Hamiltonian using matrix multiplications. Returns: \u2013 jax.Array: A tensor representing the velocity operator, computed as a differential of position and Hamiltonian.","title":"velocity_operator"},{"location":"api/#granad.orbitals.OrbitalList.wigner_weisskopf_transition_rates","text":"Calculates Wigner-Weisskopf transition rates based on transition energies and dipole moments transformed to the energy basis. Returns: \u2013 jax.Array: The element arr[i,j] contains the transition rate from i to j .","title":"wigner_weisskopf_transition_rates"},{"location":"api/#granad.orbitals.OrbitalList.append","text":"Appends an orbital to the list, ensuring it is not already present. Parameters: other ( Orbital ) \u2013 The orbital to append. Raises: TypeError \u2013 If other is not an instance of Orbital. ValueError \u2013 If other is already in the list. Source code in src/granad/orbitals.py @mutates def append(self, other): \"\"\" Appends an orbital to the list, ensuring it is not already present. Parameters: other (Orbital): The orbital to append. Raises: TypeError: If `other` is not an instance of Orbital. ValueError: If `other` is already in the list. \"\"\" if not isinstance(other, Orbital): raise TypeError if other in self: raise ValueError self._list.append(other)","title":"append"},{"location":"api/#granad.orbitals.OrbitalList.get_charge","text":"Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix ( Array ) \u2013 The density matrix to use for calculating charge. Returns: \u2013 jax.Array: A diagonal array representing charges at each site. Source code in src/granad/orbitals.py @recomputes def get_charge(density_matrix: None): \"\"\" Calculates the charge distribution from a given density matrix or from the initial density matrix if not specified. Parameters: density_matrix (jax.Array, optional): The density matrix to use for calculating charge. Returns: jax.Array: A diagonal array representing charges at each site. \"\"\" if density_matrix is None: return jnp.diag( self.transform_to_site_basis(self.initial_density_matrix) * self.electrons ) else: return jnp.diag(density_matrix * self.electrons)","title":"get_charge"},{"location":"api/#granad.orbitals.OrbitalList.get_density_matrix_time_domain","text":"Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time ( float ) \u2013 The end time for the simulation. illumination ( Callable [[ float ], Array ] ) \u2013 A function that returns the electric field at a given time. start_time ( Optional [ float ] , default: None ) \u2013 The start time for the simulation, defaults to zero. steps_time ( Optional [ int ] , default: None ) \u2013 The number of time steps to simulate, defaults to int(end_time * 1000) skip ( Optional [ int ] , default: None ) \u2013 The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate ( Union [ float , Array ] , default: None ) \u2013 The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional ( Callable [[ float ], float ] , default: lambda x: 1 / 1 + exp (-1000000.0 * 2.0 - x ) ) \u2013 A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method ( bool , default: False ) \u2013 Flag to use the old RK method. include_induced_contribution ( bool , default: False ) \u2013 Whether to include induced contributions in the simulation. use_rwa ( bool , default: False ) \u2013 Whether to apply the rotating wave approximation. compute_only_at ( Optional [ any ] , default: None ) \u2013 Specific orbital indices at which the induced field computation is performed. coulomb_strength ( float , default: 1.0 ) \u2013 Strength of Coulomb interactions. solver ( Solver , default: Dopri5 () ) \u2013 The differential equation solver to use. stepsize_controller ( StepSizeController , default: PIDController (rtol=1e-10, atol=1e-10) ) \u2013 The controller for the solver's step size. Returns: \u2013 Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. Source code in src/granad/orbitals.py @recomputes def get_density_matrix_time_domain( self, end_time: float, illumination: Callable[[float], jax.Array], start_time: Optional[float] = None, steps_time: Optional[int] = None, skip: Optional[int] = None, relaxation_rate: Union[float, jax.Array] = None, saturation_functional: Callable[[float], float] = lambda x: 1 / (1 + jnp.exp(-1e6 * (2.0 - x))), use_old_method: bool = False, include_induced_contribution: bool = False, use_rwa=False, compute_only_at=None, coulomb_strength=1.0, solver=diffrax.Dopri5(), stepsize_controller=diffrax.PIDController(rtol=1e-10, atol=1e-10), ): \"\"\" Simulates the time evolution of the density matrix for a given system under specified conditions and external fields. Parameters: end_time (float): The end time for the simulation. illumination (Callable[[float], jax.Array]): A function that returns the electric field at a given time. start_time (Optional[float]): The start time for the simulation, defaults to zero. steps_time (Optional[int]): The number of time steps to simulate, defaults to int(end_time * 1000) skip (Optional[int]): The interval at which to record results, defaults to 1, i.e. record every density matrix. relaxation_rate (Union[float, jax.Array]): The relaxation rates to be applied: if constant, the phenomenological term is applied, if an NxN array, the saturated lindblad model is applied. saturation_functional (Callable[[float], float]): A function defining the saturation behavior, defaults to smoothed-out step function. use_old_method (bool): Flag to use the old RK method. include_induced_contribution (bool): Whether to include induced contributions in the simulation. use_rwa (bool): Whether to apply the rotating wave approximation. compute_only_at (Optional[any]): Specific orbital indices at which the induced field computation is performed. coulomb_strength (float): Strength of Coulomb interactions. solver (diffrax.Solver): The differential equation solver to use. stepsize_controller (diffrax.StepSizeController): The controller for the solver's step size. Returns: Tuple[jax.Array, jax.Array]: The time axis and the simulated density matrices at specified time intervals. \"\"\" # Time axis creation start_time = float(start_time) if start_time is not None else 0.0 steps_time = int(steps_time) if steps_time is not None else int(end_time * 1000) time_axis = jnp.linspace(start_time, end_time, steps_time) skip = skip if skip is not None else 1 # Determine relaxation function based on the input type if relaxation_rate is None: relaxation_function = lambda r: 0.0 elif isinstance(relaxation_rate, jax.Array): relaxation_function = _numerics.lindblad_saturation_functional( self._eigenvectors, relaxation_rate, saturation_functional, self.electrons, self._stationary_density_matrix, ) else: relaxation_function = _numerics.relaxation_time_approximation( relaxation_rate, self.transform_to_site_basis(self._stationary_density_matrix), ) # Verify that illumination is a callable if not callable(illumination): raise TypeError(\"Provide a function for e-field\") # Initialize common variables initial_density_matrix = self.transform_to_site_basis( self._initial_density_matrix ) stationary_density_matrix = self.transform_to_site_basis( self._stationary_density_matrix ) coulomb_field_to_from = _numerics.get_coulomb_field_to_from( self.positions, self.positions, compute_only_at ) # TODO: not very elegant: we just dump every argument in there by default return time_axis[::skip], _numerics.integrate_master_equation( self._hamiltonian, coulomb_strength * self._coulomb, self.dipole_operator, self.electrons, self.velocity_operator, initial_density_matrix, stationary_density_matrix, time_axis, illumination, relaxation_function, coulomb_field_to_from, include_induced_contribution, use_rwa, solver, stepsize_controller, use_old_method, skip, )","title":"get_density_matrix_time_domain"},{"location":"api/#granad.orbitals.OrbitalList.get_dos","text":"Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the DOS. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The integrated density of states at the specified frequency. Source code in src/granad/orbitals.py @recomputes def get_dos(self, omega: float, broadening: float = 0.1): \"\"\" Calculates the density of states (DOS) of a nanomaterial stack at a given frequency with broadening. Parameters: omega (float): The frequency at which to evaluate the DOS. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The integrated density of states at the specified frequency. \"\"\" broadening = 1 / broadening prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening) gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2) return prefactor * jnp.sum(gaussians)","title":"get_dos"},{"location":"api/#granad.orbitals.OrbitalList.get_epi","text":"Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho ( Array ) \u2013 The density matrix to consider for EPI calculation. omega ( float ) \u2013 The frequency to evaluate the EPI at. epsilon ( float , default: None ) \u2013 The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float ( float ) \u2013 The EPI. Source code in src/granad/orbitals.py @recomputes def get_epi(self, rho: jax.Array, omega: float, epsilon: float = None) -> float: \"\"\" Calculates the energy-based plasmonicity index (EPI) for a given density matrix and frequency. Parameters: rho (jax.Array): The density matrix to consider for EPI calculation. omega (float): The frequency to evaluate the EPI at. epsilon (float, optional): The small imaginary part to stabilize the calculation, defaults to internal epsilon if not provided. Returns: float: The EPI. \"\"\" epsilon = self.params.eps if epsilon is None else epsilon rho_without_diagonal = jnp.abs(rho - jnp.diag(jnp.diag(rho))) rho_normalized = rho_without_diagonal / jnp.linalg.norm(rho_without_diagonal) te = self.transition_energies excitonic_transitions = ( rho_normalized / (te * (te > self.eps) - omega + 1j * epsilon) ** 2 ) return 1 - jnp.sum(jnp.abs(excitonic_transitions * rho_normalized)) / ( jnp.linalg.norm(rho_normalized) * jnp.linalg.norm(excitonic_transitions) )","title":"get_epi"},{"location":"api/#granad.orbitals.OrbitalList.get_expectation_value","text":"Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator ( Array ) \u2013 The operator for which the expectation value is calculated. density_matrix ( Array ) \u2013 The density matrix representing the state of the system. Returns: \u2013 jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. Source code in src/granad/orbitals.py @staticmethod def get_expectation_value(operator, density_matrix): \"\"\" Calculates the expectation value of an operator with respect to a given density matrix using tensor contractions specified for different dimensionalities of the input arrays. Parameters: operator (jax.Array): The operator for which the expectation value is calculated. density_matrix (jax.Array): The density matrix representing the state of the system. Returns: jax.Array: The calculated expectation value(s) depending on the dimensions of the operator and the density matrix. \"\"\" dims_einsum_strings = { (3, 2): \"ijk,kj->i\", (3, 3): \"ijk,lkj->il\", (2, 3): \"ij,kji->k\", (2, 2): \"ij,ji->\", } return jnp.einsum( dims_einsum_strings[(operator.ndim, density_matrix.ndim)], operator, density_matrix, )","title":"get_expectation_value"},{"location":"api/#granad.orbitals.OrbitalList.get_expectation_value_frequency_domain","text":"Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: \u2013 Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. Source code in src/granad/orbitals.py def get_expectation_value_frequency_domain(self, *args, **kwargs): \"\"\" Computes the frequency-domain expectation values by transforming time-domain data obtained from expectation values calculations. Parameters: The same as for get_density_matrix_time_domain, except omega_min, omega_max and the operator. Returns: Tuple[jax.Array, jax.Array, jax.Array]: Frequencies and corresponding expectation values, and optionally transformed electric field data. \"\"\" omega_min = kwargs.pop(\"omega_min\", 0) omega_max = kwargs.pop(\"omega_max\", 100) time_axis, exp_val_td = self.get_expectation_value_time_domain(*args, **kwargs) omega, exp_val_omega = _numerics.get_fourier_transform(time_axis, exp_val_td) mask = (omega >= omega_min) & (omega <= omega_max) try: electric_field = jax.vmap(kwargs[\"illumination\"])(time_axis) field_omega = _numerics.get_fourier_transform( time_axis, electric_field, return_omega_axis=False ) return omega[mask], exp_val_omega[mask], field_omega[mask] except KeyError: return omega[mask], exp_val_omega[mask]","title":"get_expectation_value_frequency_domain"},{"location":"api/#granad.orbitals.OrbitalList.get_expectation_value_time_domain","text":"Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: \u2013 Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. Source code in src/granad/orbitals.py def get_expectation_value_time_domain(self, *args, **kwargs): \"\"\" Calculates the time-domain expectation value of an operator, corrected for induced effects based on the stationary density matrix. Parameters: The same as for get_density_matrix_time_domain, except operator Returns: Tuple[jax.Array, jax.Array]: A tuple containing the time axis and the calculated expectation values over time. \"\"\" operator = kwargs.pop(\"operator\", None) correction = self.transform_to_site_basis(self.stationary_density_matrix) time_axis, density_matrices = self.get_density_matrix_time_domain( *args, **kwargs ) try: return time_axis, self.electrons * self.get_expectation_value( correction - density_matrices.ys, operator ) except AttributeError: return time_axis, self.electrons * self.get_expectation_value( correction - density_matrices, operator )","title":"get_expectation_value_time_domain"},{"location":"api/#granad.orbitals.OrbitalList.get_group_ids","text":"Retrieves a list of group IDs for all orbitals managed by this object. Returns: \u2013 List[int]: A list of group IDs for each orbital. Source code in src/granad/orbitals.py def get_group_ids(self): \"\"\" Retrieves a list of group IDs for all orbitals managed by this object. Returns: List[int]: A list of group IDs for each orbital. \"\"\" return [orb.group_id for orb in self._list]","title":"get_group_ids"},{"location":"api/#granad.orbitals.OrbitalList.get_induced_field","text":"Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions ( Array ) \u2013 The positions at which to evaluate the induced field. density_matrix ( Array ) \u2013 The density matrix used to calculate the induced field. Returns: \u2013 jax.Array: The resulting electric field vector at each position. Source code in src/granad/orbitals.py @recomputes def get_induced_field(self, positions: jax.Array, density_matrix): \"\"\" Calculates the induced electric field at specified positions based on a given density matrix. Parameters: positions (jax.Array): The positions at which to evaluate the induced field. density_matrix (jax.Array): The density matrix used to calculate the induced field. Returns: jax.Array: The resulting electric field vector at each position. \"\"\" # distance vector array from field sources to positions to evaluate field on vec_r = self._positions[:, None] - positions # scalar distances denominator = jnp.linalg.norm(vec_r, axis=2) ** 3 # normalize distance vector array point_charge = jnp.nan_to_num( vec_r / denominator[:, :, None], posinf=0.0, neginf=0.0 ) # compute charge via occupations in site basis charge = self.electrons * self.transform_to_site_basis(density_matrix).real # induced field is a sum of point charges, i.e. \\vec{r} / r^3 e_field = 14.39 * jnp.sum(point_charge * charge[:, None, None], axis=0) return e_field","title":"get_induced_field"},{"location":"api/#granad.orbitals.OrbitalList.get_ldos","text":"Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega ( float ) \u2013 The frequency at which to evaluate the LDOS. site_index ( int ) \u2013 The site index to evaluate the LDOS at. broadening ( float , default: 0.1 ) \u2013 The numerical broadening parameter to replace Dirac Deltas. Returns: float \u2013 The local density of states at the specified site and frequency. Source code in src/granad/orbitals.py @recomputes def get_ldos(self, omega: float, site_index: int, broadening: float = 0.1): \"\"\" Calculates the local density of states (LDOS) at a specific site and frequency within a nanomaterial stack. Parameters: omega (float): The frequency at which to evaluate the LDOS. site_index (int): The site index to evaluate the LDOS at. broadening (float, optional): The numerical broadening parameter to replace Dirac Deltas. Returns: float: The local density of states at the specified site and frequency. \"\"\" broadening = 1 / broadening weight = jnp.abs(self._eigenvectors[site_index, :]) ** 2 prefactor = 1 / (jnp.sqrt(2 * jnp.pi) * broadening) gaussians = jnp.exp(-((self._energies - omega) ** 2) / 2 * broadening**2) return prefactor * jnp.sum(weight * gaussians)","title":"get_ldos"},{"location":"api/#granad.orbitals.OrbitalList.get_polarizability_rpa","text":"Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas ( Array ) \u2013 Frequencies at which to calculate polarizability. relaxation_rate ( float ) \u2013 The relaxation time parameter. polarization ( Array ) \u2013 Polarization directions or modes. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interaction in the calculations. hungry ( bool , default: False ) \u2013 speed up the simulation up, taking more RAM. phi_ext ( Optional [ Array ] , default: None ) \u2013 External potential influences, if any. Returns: \u2013 jax.Array: The calculated polarizabilities at the specified frequencies. Source code in src/granad/orbitals.py def get_polarizability_rpa( self, omegas, relaxation_rate, polarization, coulomb_strength=1.0, hungry=False, phi_ext=None, ): \"\"\" Calculates the random phase approximation (RPA) polarizability of the system at given frequencies under specified conditions. Parameters: omegas (jax.Array): Frequencies at which to calculate polarizability. relaxation_rate (float): The relaxation time parameter. polarization (jax.Array): Polarization directions or modes. coulomb_strength (float): The strength of Coulomb interaction in the calculations. hungry (bool): speed up the simulation up, taking more RAM. phi_ext (Optional[jax.Array]): External potential influences, if any. Returns: jax.Array: The calculated polarizabilities at the specified frequencies. \"\"\" alpha = _numerics.rpa_polarizability_function( self, relaxation_rate, polarization, coulomb_strength, phi_ext, hungry ) return jax.lax.map(alpha, omegas)","title":"get_polarizability_rpa"},{"location":"api/#granad.orbitals.OrbitalList.get_susceptibility_rpa","text":"Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas ( Array ) \u2013 The frequencies at which to compute susceptibility. relaxation_rate ( float ) \u2013 The relaxation time affecting susceptibility calculations. coulomb_strength ( float , default: 1.0 ) \u2013 The strength of Coulomb interactions considered in the calculations. hungry ( bool , default: False ) \u2013 speed up the simulation up, taking more RAM. Returns: \u2013 jax.Array: The susceptibility values at the given frequencies. Source code in src/granad/orbitals.py def get_susceptibility_rpa( self, omegas, relaxation_rate, coulomb_strength=1.0, hungry=False ): \"\"\" Computes the random phase approximation (RPA) susceptibility of the system over a range of frequencies. Parameters: omegas (jax.Array): The frequencies at which to compute susceptibility. relaxation_rate (float): The relaxation time affecting susceptibility calculations. coulomb_strength (float): The strength of Coulomb interactions considered in the calculations. hungry (bool): speed up the simulation up, taking more RAM. Returns: jax.Array: The susceptibility values at the given frequencies. \"\"\" sus = _numerics.rpa_polarizability_function( self, relaxation_rate, coulomb_strength, hungry ) return jax.lax.map(sus, omegas)","title":"get_susceptibility_rpa"},{"location":"api/#granad.orbitals.OrbitalList.get_unique_group_ids","text":"Retrieves a unique set of group IDs from all orbitals. Returns: \u2013 List[int]: A list of unique group IDs. Source code in src/granad/orbitals.py def get_unique_group_ids(self): \"\"\" Retrieves a unique set of group IDs from all orbitals. Returns: List[int]: A list of unique group IDs. \"\"\" return list(set(self.get_group_ids()))","title":"get_unique_group_ids"},{"location":"api/#granad.orbitals.OrbitalList.make_self_consistent","text":"Configures the list for self-consistent field calculations. Parameters: sc_params ( dict ) \u2013 Parameters for self-consistency. Source code in src/granad/orbitals.py @mutates def make_self_consistent(self, sc_params): \"\"\" Configures the list for self-consistent field calculations. Parameters: sc_params (dict): Parameters for self-consistency. \"\"\" self.self_consistency_params = sc_params","title":"make_self_consistent"},{"location":"api/#granad.orbitals.OrbitalList.set_coulomb_element","text":"Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Coulomb interaction element. Source code in src/granad/orbitals.py def set_coulomb_element(self, orb_or_index1, orb_or_index2, val): \"\"\" Sets a Coulomb interaction element between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Coulomb interaction element. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._set_coupling(orb1, orb2, self._ensure_complex(val), self._coulomb_dict)","title":"set_coulomb_element"},{"location":"api/#granad.orbitals.OrbitalList.set_dipole_transition","text":"Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first part of the transition. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second part of the transition. arr ( Array ) \u2013 The 3-element array containing dipole transition elements. Source code in src/granad/orbitals.py @mutates def set_dipole_transition(self, orb_or_index1, orb_or_index2, arr): \"\"\" Sets a dipole transition for specified orbital or index pairs. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first part of the transition. orb_or_index2 (int or Orbital): Identifier or orbital for the second part of the transition. arr (jax.Array): The 3-element array containing dipole transition elements. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._transitions[(orb_or_index1, orb_or_index2)] = jnp.array(arr).astype( complex )","title":"set_dipole_transition"},{"location":"api/#granad.orbitals.OrbitalList.set_excitation","text":"Sets up an excitation process from one state to another with specified electrons. Parameters: from_state ( int, list, or jax.Array ) \u2013 The initial state index or indices. to_state ( int, list, or jax.Array ) \u2013 The final state index or indices. excited_electrons ( int, list, or jax.Array ) \u2013 The indices of electrons to be excited. Notes The states and electron indices may be specified as scalars, lists, or arrays. Source code in src/granad/orbitals.py @mutates def set_excitation(self, from_state, to_state, excited_electrons): \"\"\" Sets up an excitation process from one state to another with specified electrons. Parameters: from_state (int, list, or jax.Array): The initial state index or indices. to_state (int, list, or jax.Array): The final state index or indices. excited_electrons (int, list, or jax.Array): The indices of electrons to be excited. Notes: The states and electron indices may be specified as scalars, lists, or arrays. \"\"\" def maybe_int_to_arr(maybe_int): if isinstance(maybe_int, int): return jnp.array([maybe_int]) if isinstance(maybe_int, list): maybe_int = jnp.array(maybe_int) if isinstance(maybe_int, jax.Array): return ( jnp.array(maybe_int) if maybe_int.ndim > 1 else jnp.array([maybe_int]) ) raise TypeError self.from_state = maybe_int_to_arr(from_state) self.to_state = maybe_int_to_arr(to_state) self.excited_electrons = maybe_int_to_arr(excited_electrons)","title":"set_excitation"},{"location":"api/#granad.orbitals.OrbitalList.set_groups_coulomb","text":"Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the Coulomb interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py def set_groups_coulomb(self, orb_or_group_id1, orb_or_group_id2, func): \"\"\" Sets the Coulomb coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the Coulomb interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1, group_id2 = self._maybe_orbs_to_group_ids( (orb_or_group_id1, orb_or_group_id2) ) self._set_coupling( group_id1, group_id2, self._ensure_complex(func), self._coulomb_dict )","title":"set_groups_coulomb"},{"location":"api/#granad.orbitals.OrbitalList.set_groups_hopping","text":"Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 ( int or Orbital ) \u2013 Identifier or orbital for the first group. orb_or_group_id2 ( int or Orbital ) \u2013 Identifier or orbital for the second group. func ( callable ) \u2013 Function that defines the hopping interaction. Notes The function func should be complex-valued. Source code in src/granad/orbitals.py def set_groups_hopping(self, orb_or_group_id1, orb_or_group_id2, func): \"\"\" Sets the hopping coupling between two groups of orbitals. Parameters: orb_or_group_id1 (int or Orbital): Identifier or orbital for the first group. orb_or_group_id2 (int or Orbital): Identifier or orbital for the second group. func (callable): Function that defines the hopping interaction. Notes: The function `func` should be complex-valued. \"\"\" group_id1, group_id2 = self._maybe_orbs_to_group_ids( (orb_or_group_id1, orb_or_group_id2) ) self._set_coupling( group_id1, group_id2, self._ensure_complex(func), self._hopping_dict )","title":"set_groups_hopping"},{"location":"api/#granad.orbitals.OrbitalList.set_hamiltonian_element","text":"Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 ( int or Orbital ) \u2013 Identifier or orbital for the first element. orb_or_index2 ( int or Orbital ) \u2013 Identifier or orbital for the second element. val ( complex ) \u2013 The complex value to set for the Hamiltonian element. Source code in src/granad/orbitals.py def set_hamiltonian_element(self, orb_or_index1, orb_or_index2, val): \"\"\" Sets an element of the Hamiltonian matrix between two orbitals or indices. Parameters: orb_or_index1 (int or Orbital): Identifier or orbital for the first element. orb_or_index2 (int or Orbital): Identifier or orbital for the second element. val (complex): The complex value to set for the Hamiltonian element. \"\"\" orb1, orb2 = self._maybe_indices_to_orbs((orb_or_index1, orb_or_index2)) self._set_coupling(orb1, orb2, self._ensure_complex(val), self._hopping_dict)","title":"set_hamiltonian_element"},{"location":"api/#granad.orbitals.OrbitalList.shift_by_vector","text":"Shifts all orbitals with a specific tag by a given vector. Parameters: tag ( str ) \u2013 The tag to match orbitals. translation_vector ( Array ) \u2013 The vector by which to translate the orbital positions. Notes This operation mutates the positions of the matched orbitals. Source code in src/granad/orbitals.py @mutates def shift_by_vector(self, tag, translation_vector): \"\"\" Shifts all orbitals with a specific tag by a given vector. Parameters: tag (str): The tag to match orbitals. translation_vector (jax.Array): The vector by which to translate the orbital positions. Notes: This operation mutates the positions of the matched orbitals. \"\"\" orbs = [orb for orb in self._list if orb.tag == tag] for orb in orbs: orb.position += translation_vector","title":"shift_by_vector"},{"location":"api/#granad.orbitals.OrbitalList.transform_to_energy_basis","text":"Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the energy basis. Source code in src/granad/orbitals.py def transform_to_energy_basis(self, observable):# \"\"\" Transforms an observable to the energy basis using the conjugate transpose of the system's eigenvectors. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the energy basis. \"\"\" return self._transform_basis(observable, self._eigenvectors.conj().T)","title":"transform_to_energy_basis"},{"location":"api/#granad.orbitals.OrbitalList.transform_to_site_basis","text":"Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable ( Array ) \u2013 The observable to transform. Returns: \u2013 jax.Array: The transformed observable in the site basis. Source code in src/granad/orbitals.py def transform_to_site_basis(self, observable): \"\"\" Transforms an observable to the site basis using eigenvectors of the system. Parameters: observable (jax.Array): The observable to transform. Returns: jax.Array: The transformed observable in the site basis. \"\"\" return self._transform_basis(observable, self._eigenvectors)","title":"transform_to_site_basis"},{"location":"units/","text":"Units GRANAD uses the following unit conventions Quantity Unit Energy eV Distance \u00c5ngstr\u00f6m Time \\(0.659 \\cdot 10^{-15}\\) s Charge \\(1.6 \\cdot 10^{-19}\\) C Electric field strength \\(10^{10}\\) V/m","title":"Units"},{"location":"units/#units","text":"GRANAD uses the following unit conventions Quantity Unit Energy eV Distance \u00c5ngstr\u00f6m Time \\(0.659 \\cdot 10^{-15}\\) s Charge \\(1.6 \\cdot 10^{-19}\\) C Electric field strength \\(10^{10}\\) V/m","title":"Units"},{"location":"tutorials/getting_started/","text":"Getting started We introduce the basics of GRANAD and do a quick simulation. Orbitals At its core, GRANAD is all about orbitals. Let's create one at the origin and inspect it. from granad import Orbital my_first_orbital = Orbital( position = (0, 0, 0), tag = \"a tag contains arbitrary information\", ) print(my_first_orbital) {'position': Array([0., 0., 0.], dtype=float64), 'layer_index': None, 'tag': 'a tag contains arbitrary information', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 1} The group_id, unsurprisingly, groups orbitals. For example: if you create a two-level adatom, you need two orbitals that share the same group_id. In the same way, all orbitals in a graphene sheet share the same group_id. my_second_orbital = Orbital( position = (1, 1, 1), tag = \"a new, shifted orbital\", ) print(my_second_orbital) {'position': Array([1., 1., 1.], dtype=float64), 'layer_index': None, 'tag': 'a new, shifted orbital', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 2} This is all there is to know about orbitals! Materials Materials are stuff you can cut orbitals from. We will see below how this works. from granad import Material2D Material2D.available() Available materials: graphene Let's pick a material and move on. graphene = Material2D.get(\"graphene\") OrbitalLists OrbitalLists are the last class you need to know. Unsurprisingly, an OrbitalList is a list of orbitals. You can create one yourself from the two orbitals you created above from granad import OrbitalList my_first_orbital_list = OrbitalList([my_first_orbital, my_second_orbital]) print(my_first_orbital_list) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals Alternatively, you get orbital lists if you cut a flake from a material. You do this by specifying the shape of the flake. You can specify any shape you want, but this is covered in a separate tutorial. For now, we will use a built-in shape: an equilateral triangle with a side length of 15 Angstr\u00f6m. from granad import Triangle import jax.numpy as jnp triangle = Triangle(15, armchair = True) + jnp.array([10,10]) Now, our shape is ready and we can start cutting. To make sure that we are satisfied with what we get, we plot the flake. By default, GRANAD cuts any \"dangling\" atoms. my_first_flake = graphene.cut_orbitals(triangle, plot = True) print(my_first_flake) List with 36 orbitals, 36 electrons. [0] electrons excited from [0] to [0]. group id 3 : 36 orbitals For more information on cutting, including different edge types and how to keep dangling atoms, have a look at the corresponding tutorial. A first simulation To get a feeling of the setup, we first inspect the energies of the flake my_first_flake.show_energies() Physical observables are expectation values of Hermitian operators. GRANAD offers access to the time-resolved density matrix \\(\\rho(t)\\) of a system by integrating a nonlinear master equation. As a result, it is possible to track the evolution of the physical observable associated with a Hermitian operator \\(A\\) by computing \\(a(t) = Tr[\\rho(t) A]\\) . Optical properties in particular are largely determined by the polarization or dipole operator \\(\\hat{P}\\) and they are usually expressed in frequency domain. To this end, GRANAD offers a way to compute the Fourier transform \\(a(\\omega)\\) directly after time propagation. We will look at an example tracking the time evolution of the dipole operator below, where the computation proceeds in two steps: Excite the flake with an electric field. Compute its dipole moment \\(p(\\omega)\\) from the expectation value of its dipole operator. We first do step 1. To obtain a broad frequency spectrum, we must pick a narrow pulse in time-domain from granad import Pulse my_first_illumination = Pulse( amplitudes=[1e-5, 0, 0], frequency=2.3, peak=5, fwhm=2 ) For step 2, a few parameters have to be chosen Simulation duration: we go from 0 to 40 in 1e5 steps. Relaxation rate: this is \\(r\\) in the dissipation term \\(D[\\rho] = r \\cdot(\\rho - \\rho_0)\\) in the master equation. Frequency domain limits: we choose the interval [0, 16]. Density matrix sampling rate: producing 1e5 density matrices can quickly exhaust RAM ressources. So we only save every 100th density matrix, such that we get 1000 density matrices. A simulation is just passing all of these parameters to the corresponding method of our flake. omegas, dipole_omega, pulse_omega = my_first_flake.get_expectation_value_frequency_domain( operator=my_first_flake.dipole_operator, end_time=40, steps_time=1e5, relaxation_rate=1 / 10, illumination=my_first_illumination, omega_min=0, omega_max=10, skip=100, ) We see that three variables are returned: the omega axis we have specified, the dipole moment and the pulse in freqeuency domain. There is no way to control the number of points in the omega axis, because it is the result of a Fourier transform. We now plot the dipole moment and the pulse in frequency domain. import matplotlib.pyplot as plt plt.plot(omegas, dipole_omega) plt.plot(omegas, pulse_omega, \"--\") plt.show()","title":"Getting started"},{"location":"tutorials/getting_started/#getting-started","text":"We introduce the basics of GRANAD and do a quick simulation.","title":"Getting started"},{"location":"tutorials/getting_started/#orbitals","text":"At its core, GRANAD is all about orbitals. Let's create one at the origin and inspect it. from granad import Orbital my_first_orbital = Orbital( position = (0, 0, 0), tag = \"a tag contains arbitrary information\", ) print(my_first_orbital) {'position': Array([0., 0., 0.], dtype=float64), 'layer_index': None, 'tag': 'a tag contains arbitrary information', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 1} The group_id, unsurprisingly, groups orbitals. For example: if you create a two-level adatom, you need two orbitals that share the same group_id. In the same way, all orbitals in a graphene sheet share the same group_id. my_second_orbital = Orbital( position = (1, 1, 1), tag = \"a new, shifted orbital\", ) print(my_second_orbital) {'position': Array([1., 1., 1.], dtype=float64), 'layer_index': None, 'tag': 'a new, shifted orbital', 'energy_level': None, 'angular_momentum': None, 'angular_momentum_z': None, 'spin': None, 'atom_name': None, 'group_id': 2} This is all there is to know about orbitals!","title":"Orbitals"},{"location":"tutorials/getting_started/#materials","text":"Materials are stuff you can cut orbitals from. We will see below how this works. from granad import Material2D Material2D.available() Available materials: graphene Let's pick a material and move on. graphene = Material2D.get(\"graphene\")","title":"Materials"},{"location":"tutorials/getting_started/#orbitallists","text":"OrbitalLists are the last class you need to know. Unsurprisingly, an OrbitalList is a list of orbitals. You can create one yourself from the two orbitals you created above from granad import OrbitalList my_first_orbital_list = OrbitalList([my_first_orbital, my_second_orbital]) print(my_first_orbital_list) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals Alternatively, you get orbital lists if you cut a flake from a material. You do this by specifying the shape of the flake. You can specify any shape you want, but this is covered in a separate tutorial. For now, we will use a built-in shape: an equilateral triangle with a side length of 15 Angstr\u00f6m. from granad import Triangle import jax.numpy as jnp triangle = Triangle(15, armchair = True) + jnp.array([10,10]) Now, our shape is ready and we can start cutting. To make sure that we are satisfied with what we get, we plot the flake. By default, GRANAD cuts any \"dangling\" atoms. my_first_flake = graphene.cut_orbitals(triangle, plot = True) print(my_first_flake) List with 36 orbitals, 36 electrons. [0] electrons excited from [0] to [0]. group id 3 : 36 orbitals For more information on cutting, including different edge types and how to keep dangling atoms, have a look at the corresponding tutorial.","title":"OrbitalLists"},{"location":"tutorials/getting_started/#a-first-simulation","text":"To get a feeling of the setup, we first inspect the energies of the flake my_first_flake.show_energies() Physical observables are expectation values of Hermitian operators. GRANAD offers access to the time-resolved density matrix \\(\\rho(t)\\) of a system by integrating a nonlinear master equation. As a result, it is possible to track the evolution of the physical observable associated with a Hermitian operator \\(A\\) by computing \\(a(t) = Tr[\\rho(t) A]\\) . Optical properties in particular are largely determined by the polarization or dipole operator \\(\\hat{P}\\) and they are usually expressed in frequency domain. To this end, GRANAD offers a way to compute the Fourier transform \\(a(\\omega)\\) directly after time propagation. We will look at an example tracking the time evolution of the dipole operator below, where the computation proceeds in two steps: Excite the flake with an electric field. Compute its dipole moment \\(p(\\omega)\\) from the expectation value of its dipole operator. We first do step 1. To obtain a broad frequency spectrum, we must pick a narrow pulse in time-domain from granad import Pulse my_first_illumination = Pulse( amplitudes=[1e-5, 0, 0], frequency=2.3, peak=5, fwhm=2 ) For step 2, a few parameters have to be chosen Simulation duration: we go from 0 to 40 in 1e5 steps. Relaxation rate: this is \\(r\\) in the dissipation term \\(D[\\rho] = r \\cdot(\\rho - \\rho_0)\\) in the master equation. Frequency domain limits: we choose the interval [0, 16]. Density matrix sampling rate: producing 1e5 density matrices can quickly exhaust RAM ressources. So we only save every 100th density matrix, such that we get 1000 density matrices. A simulation is just passing all of these parameters to the corresponding method of our flake. omegas, dipole_omega, pulse_omega = my_first_flake.get_expectation_value_frequency_domain( operator=my_first_flake.dipole_operator, end_time=40, steps_time=1e5, relaxation_rate=1 / 10, illumination=my_first_illumination, omega_min=0, omega_max=10, skip=100, ) We see that three variables are returned: the omega axis we have specified, the dipole moment and the pulse in freqeuency domain. There is no way to control the number of points in the omega axis, because it is the result of a Fourier transform. We now plot the dipole moment and the pulse in frequency domain. import matplotlib.pyplot as plt plt.plot(omegas, dipole_omega) plt.plot(omegas, pulse_omega, \"--\") plt.show()","title":"A first simulation"},{"location":"tutorials/linear_response_absorption_cross_section_with_td_and_rpa_simulations/","text":"Linear response absorption cross section with TD and RPA simulations We will calculate the optical absorption in the RPA and compare it to TD simulations with a weak external field. RPA First, we set up the RPA simulation. We will consider a small triangle such that the required simulation time stays in the seconds range. import jax.numpy as jnp from granad import Material2D, Triangle # get material graphene = Material2D.get( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene.cut_orbitals( Triangle(15) ) # frequencies omegas_rpa = jnp.linspace( 0, 5, 40 ) We obtain the polarizability for an external \\(x\\) polarized field and from its imaginary part the absorption. polarizability = flake.get_polarizability_rpa( omegas_rpa, relaxation_rate = 1/10, polarization = 0, hungry = True ) absorption_rpa = jnp.abs( polarizability.imag * 4 * jnp.pi * omegas_rpa ) TD For the TD simulations, we specify a spectrally broad external illumination (i.e. a narrow pulse in time domain) to capture the system's response over a large frequency range. from granad import Pulse pulse = Pulse( amplitudes=[1e-5, 0, 0], frequency=2.3, peak=5, fwhm=2 ) We then compute the TD dipole moment and Fourier transform it. omegas, dipole_omega, pulse_omega = flake.get_expectation_value_frequency_domain( operator=flake.dipole_operator, # the dipole moment is the expectation value of the dipole operator end_time=40, steps_time=1e5, relaxation_rate=1/10, illumination=pulse, omega_min=0, omega_max=5, skip=100, ) The polarizability is given by \\(p / E\\) (we only take the \\(x\\) - component). absorption_td = jnp.abs( -omegas * jnp.imag( dipole_omega[:,0] / pulse_omega[:,0] ) ) We can now compare the two results. import matplotlib.pyplot as plt plt.style.use('ggplot') plt.figure(figsize=(10, 6)) plt.plot(omegas_rpa, absorption_rpa / jnp.max(absorption_rpa), 'o', linewidth=2, label = 'RPA') plt.plot(omegas, absorption_td / jnp.max(absorption_td), linewidth=2, ls = '--', label = 'TD' ) plt.xlabel(r'$\\hbar\\omega$', fontsize=20) plt.ylabel(r'$\\sigma(\\omega)$', fontsize=25) plt.title('Absorption Spectrum as a Function of Photon Energy', fontsize=15) plt.legend() plt.grid(True) plt.show()","title":"Linear response absorption cross section with td and rpa simulations"},{"location":"tutorials/linear_response_absorption_cross_section_with_td_and_rpa_simulations/#linear-response-absorption-cross-section-with-td-and-rpa-simulations","text":"We will calculate the optical absorption in the RPA and compare it to TD simulations with a weak external field.","title":"Linear response absorption cross section with TD and RPA simulations"},{"location":"tutorials/linear_response_absorption_cross_section_with_td_and_rpa_simulations/#rpa","text":"First, we set up the RPA simulation. We will consider a small triangle such that the required simulation time stays in the seconds range. import jax.numpy as jnp from granad import Material2D, Triangle # get material graphene = Material2D.get( \"graphene\" ) # cut a 15 Angstr\u00f6m wide triangle from the lattice (can also be an arbitrary polygon) flake = graphene.cut_orbitals( Triangle(15) ) # frequencies omegas_rpa = jnp.linspace( 0, 5, 40 ) We obtain the polarizability for an external \\(x\\) polarized field and from its imaginary part the absorption. polarizability = flake.get_polarizability_rpa( omegas_rpa, relaxation_rate = 1/10, polarization = 0, hungry = True ) absorption_rpa = jnp.abs( polarizability.imag * 4 * jnp.pi * omegas_rpa )","title":"RPA"},{"location":"tutorials/linear_response_absorption_cross_section_with_td_and_rpa_simulations/#td","text":"For the TD simulations, we specify a spectrally broad external illumination (i.e. a narrow pulse in time domain) to capture the system's response over a large frequency range. from granad import Pulse pulse = Pulse( amplitudes=[1e-5, 0, 0], frequency=2.3, peak=5, fwhm=2 ) We then compute the TD dipole moment and Fourier transform it. omegas, dipole_omega, pulse_omega = flake.get_expectation_value_frequency_domain( operator=flake.dipole_operator, # the dipole moment is the expectation value of the dipole operator end_time=40, steps_time=1e5, relaxation_rate=1/10, illumination=pulse, omega_min=0, omega_max=5, skip=100, ) The polarizability is given by \\(p / E\\) (we only take the \\(x\\) - component). absorption_td = jnp.abs( -omegas * jnp.imag( dipole_omega[:,0] / pulse_omega[:,0] ) ) We can now compare the two results. import matplotlib.pyplot as plt plt.style.use('ggplot') plt.figure(figsize=(10, 6)) plt.plot(omegas_rpa, absorption_rpa / jnp.max(absorption_rpa), 'o', linewidth=2, label = 'RPA') plt.plot(omegas, absorption_td / jnp.max(absorption_td), linewidth=2, ls = '--', label = 'TD' ) plt.xlabel(r'$\\hbar\\omega$', fontsize=20) plt.ylabel(r'$\\sigma(\\omega)$', fontsize=25) plt.title('Absorption Spectrum as a Function of Photon Energy', fontsize=15) plt.legend() plt.grid(True) plt.show()","title":"TD"},{"location":"tutorials/rabi_oscillations_in_tls/","text":"Rabi Oscillations in TLS We study Rabi oscillations in isolated two-level system. NOTE: this tutorial makes heavy use of the liberal way GRANAD lets you group orbitals. You might want to consult the tutorial on orbital lists first. Building a two-level system Consider an isolated atom, modelled as a two-level system. Each level is an orbital, so let's combine them in a list. from granad import Orbital, OrbitalList lower_level = Orbital(tag=\"atom\") upper_level = Orbital(tag=\"atom\") atom = OrbitalList([lower_level, upper_level]) We have used a tag to signify that these the orbitals belong to the same atom. Let's see what we have done. print(atom) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We see that GRANAD assumes that every orbital is filled. But we want only the one of the levels filled. So, we set the electron number to 1. atom.electrons = 1 print(atom) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We now need to specify the Hamiltonian. We can do so by setting the elements corresponding to the orbitals. atom.set_hamiltonian_element(upper_level, lower_level, 2.0) atom.set_hamiltonian_element(upper_level, upper_level, 0.5) atom.set_hamiltonian_element(lower_level, lower_level, -0.5) print(atom) print(atom.hamiltonian) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals [[-0.5+0.j 2. +0.j] [ 2. +0.j 0.5+0.j]] Setting dipole transitions is similar. We want the lower and upper level to be connected by a dipole transition in z-direction. atom.set_dipole_transition(upper_level, lower_level, [1, 0, 0]) print(atom) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We set the initial excited state (in our point of view, this is a HOMO-LUMO transition). atom.set_excitation(atom.homo, atom.homo + 1, 1) print(atom) List with 2 orbitals, 1 electrons. [1] electrons excited from [0] to [1]. group id 1 : 1 orbitals group id 2 : 1 orbitals We consider a continuous wave as an external illumination. from granad import Wave wave = Wave(amplitudes=[0.05, 0, 0], frequency=2) We propagate the system in time. time, density_matrices = atom.get_density_matrix_time_domain( end_time=10, relaxation_rate=1, illumination=wave, use_rwa=True ) atom.show_energy_occupations(density_matrices, time=time)","title":"Rabi oscillations in tls"},{"location":"tutorials/rabi_oscillations_in_tls/#rabi-oscillations-in-tls","text":"We study Rabi oscillations in isolated two-level system. NOTE: this tutorial makes heavy use of the liberal way GRANAD lets you group orbitals. You might want to consult the tutorial on orbital lists first.","title":"Rabi Oscillations in TLS"},{"location":"tutorials/rabi_oscillations_in_tls/#building-a-two-level-system","text":"Consider an isolated atom, modelled as a two-level system. Each level is an orbital, so let's combine them in a list. from granad import Orbital, OrbitalList lower_level = Orbital(tag=\"atom\") upper_level = Orbital(tag=\"atom\") atom = OrbitalList([lower_level, upper_level]) We have used a tag to signify that these the orbitals belong to the same atom. Let's see what we have done. print(atom) List with 2 orbitals, 2 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We see that GRANAD assumes that every orbital is filled. But we want only the one of the levels filled. So, we set the electron number to 1. atom.electrons = 1 print(atom) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We now need to specify the Hamiltonian. We can do so by setting the elements corresponding to the orbitals. atom.set_hamiltonian_element(upper_level, lower_level, 2.0) atom.set_hamiltonian_element(upper_level, upper_level, 0.5) atom.set_hamiltonian_element(lower_level, lower_level, -0.5) print(atom) print(atom.hamiltonian) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals [[-0.5+0.j 2. +0.j] [ 2. +0.j 0.5+0.j]] Setting dipole transitions is similar. We want the lower and upper level to be connected by a dipole transition in z-direction. atom.set_dipole_transition(upper_level, lower_level, [1, 0, 0]) print(atom) List with 2 orbitals, 1 electrons. [0] electrons excited from [0] to [0]. group id 1 : 1 orbitals group id 2 : 1 orbitals We set the initial excited state (in our point of view, this is a HOMO-LUMO transition). atom.set_excitation(atom.homo, atom.homo + 1, 1) print(atom) List with 2 orbitals, 1 electrons. [1] electrons excited from [0] to [1]. group id 1 : 1 orbitals group id 2 : 1 orbitals We consider a continuous wave as an external illumination. from granad import Wave wave = Wave(amplitudes=[0.05, 0, 0], frequency=2) We propagate the system in time. time, density_matrices = atom.get_density_matrix_time_domain( end_time=10, relaxation_rate=1, illumination=wave, use_rwa=True ) atom.show_energy_occupations(density_matrices, time=time)","title":"Building a two-level system"}]}